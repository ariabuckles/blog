/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// For legacy reasons, Perseus assumes that some modules (such as knumber) are
	// executed immediately when the exercise content bundle is loaded, so we load
	// them all here.

	__webpack_require__(1);

	__webpack_require__(2);
	__webpack_require__(3);
	__webpack_require__(4);
	__webpack_require__(5);
	__webpack_require__(6);
	__webpack_require__(7);
	__webpack_require__(8);
	__webpack_require__(9);
	__webpack_require__(10);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* khan-exercise.js

	    The main entry point here is essentially the onjQueryLoaded method around
	    line 750. It loads in many of the pre-reqs and then calls, one way or
	    another, setUserExercise and loadModule for each required module in utils/.

	    setProblemNum updates some instance vars that get looked at by other
	    functions.

	    loadModule will load an individual exercise util module (e.g.,
	    word-problems.js, etc). It _also_ loads in the Khan Academy site skin and
	    exercise template via injectSite which runs prepareSite first then
	    makeProblem when it finishes loading dependencies.

	    prepareSite and makeProblem are both fairly heavyweight functions.

	    If you are trying to register some behavior when the page loads, you
	    probably want it to go in either prepareSite here or, if it makes sense, in
	    problemTemplateRendered in interface.js. By the time prepareSite is called,
	    jQuery and any core plugins are already available.

	    If you are trying to do something each time a problem loads, you probably
	    want to look at makeProblem.

	    At the end of evaluation, the inner Khan object is returned/exposed as well
	    as the inner Util object.


	    Catalog of events fired on the Khan object by khan-exercises:

	    * newProblem -- when a new problem has completely finished rendering

	    * hintUsed -- when a hint has been used by the user

	    * checkAnswer -- when the user attempts to check an answer, incorrect or
	      correct

	    * problemDone -- when the user has completed a problem which, in this case,
	      usually means supplying the correct answer. Note the user may have made
	      multiple attempts to finally get at the correct answer. A summary object
	      including {attempts: <number>, card: <Object>} is included as an
	      event parameter.

	    * attemptError -- when an error occurs during an API attempt

	    * apiRequestStarted / apiRequestEnded -- when an API request is sent
	      outbound or completed, respectively. Listeners can keep track of whether
	      or not khan-exercises is still waiting on API responses.

	    * updateUserExercise -- when an updated userExercise has been received
	      and is being used by khan-exercises, either via the result of an API
	      call or initialization

	    * showGuess -- when a guess is populated in the answer area in problem
	      history mode

	    * attemptMessageShown -- when a user attempts a problem and a message is
	      shown in response, e.g. "We don't understand your answer."
	*/
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var crc32 = __webpack_require__(11);

	// Numbers which are coprime to the number of bins, used for jumping through
	// exercises.  To quickly test a number in python use code like:
	// import fractions
	// fractions.gcd( 197, 200)
	var primes = [197, 3, 193, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,
	47, 53, 59, 61, 67, 71, 73, 79, 83],

	    userExercise,

	    // Check to see if we're in local mode
	    localMode = Exercises.localMode,

	    // Set in prepareSite when Exercises.init() has already been called
	    assessmentMode,

	    // The ID, filename, and name of the exercise -- these will only be set here in localMode
	    currentExerciseId = ((/([^\/.]+)(?:\.html)?$/.exec(window.location.pathname) || [])[1]) || "",
	    currentExerciseFile = currentExerciseId + ".html",
	    currentExerciseName = deslugify(currentExerciseId),

	    // Bin users into a certain number of realms so that
	    // there is some level of reproducability in their questions.
	    // If you change this, make sure all entries in the array "primes"
	    // set above are coprime to the new value.
	    bins = 200,

	    // Number of past problems to consider when avoiding duplicates
	    dupWindowSize = 5,

	    // The seed information
	    randomSeed,

	    // Holds the current username
	    user = null,
	    userCRC32,

	    // The current problem and its corresponding exercise
	    problem,    // the unprocessed contents of a specific problem type
	    exercise,   // the unprocessed contents of all problem types and vars

	    // The number of the current problem that we're on
	    problemNum = 1,

	    // Info for constructing the seed
	    seedOffset = 0,
	    jumpNum = 1,
	    currentProblemSeed = 0,
	    seedsSkipped = 0,
	    consecutiveSkips = 0,

	    currentProblemType,

	    // The current validator function
	    answerData,
	    validator,
	    getAnswer,

	    hints,

	    // The exercise elements
	    exercises,

	    hintsUsed,

	    // Bug-hunting "undefined" attempt content
	    debugLogLog = ["start of log"],
	    debugLog = function(l) {
	        debugLogLog.push(l);
	    },

	    // Dictionary of loading and loaded exercises; keys are exercise IDs,
	    // values are promises that are resolved when the exercise is loaded
	    exerciseFilePromises = {},

	    // A promise for each loaded or loading module, keyed by module filename
	    // (module.src) -- will be resolved when the module is loaded (on the live
	    // site, immediately)
	    modulePromises = {},
	    initialModulesPromise = $.Deferred(),

	    urlBase = localMode ?  "../" :
	        Exercises.khanExercisesUrlBase != null ?
	            Exercises.khanExercisesUrlBase :
	            "/khan-exercises/",

	    // In local mode, we use khan-exercises local copy of the /images
	    // directory.  But in production (on www.khanacademy.org), we use
	    // the canonical location of images, which is under '/'.
	    imageBase = localMode ? urlBase + "images/" : "/images/",

	    lastFocusedSolutionInput = null,

	    // Keeps track of failures in MakeProblem so we don't endlessly try and
	    // re-Make a bad problem
	    failureRetryCount = 0,

	    // The ul#examples (keep in a global because we need to modify it even when it's out of the DOM)
	    examples = null;

	// Add in the site stylesheets
	if (localMode) {
	    (function() {
	        var addLink = function(url) {
	            var link = document.createElement("link");
	            link.rel = "stylesheet";
	            link.href = urlBase + url;
	            document.getElementsByTagName("head")[0].appendChild(link);
	        };

	        addLink("css/khan-site.css");
	        addLink("css/khan-exercise.css");
	        addLink("local-only/katex/katex.css");
	        addLink("local-only/katex/fonts/fonts.css");
	    })();
	}

	// The main Khan Module
	var Khan = {

	    // Set of modules currently in use -- keys are module names, value is
	    // always true
	    modules: {},

	    // Map from exercise ID to a list of required modules (data-require),
	    // These module names are used in resetModules() and indirectly by
	    // runModules(), where $.fn["module-name"], $.fn["module-nameLoad"],
	    // and $.fn["module-nameCleanup"] are called.
	    exerciseModulesMap: {},

	    // So modules can use file paths properly
	    urlBase: urlBase,

	    imageBase: imageBase,

	    // Inter-util dependencies. This map is currently necessary so that we
	    // can expose only the appropriate $.fn["module-nameLoad"] hooks used
	    // by each problem. Dependencies on third-party files need not be
	    // listed here.
	    // TODO(alpert): Now that these deps are now encoded in require()
	    // lines, find a way to remove this map.
	    moduleDependencies: {
	        "math": ["knumber"],
	        "exponents": ["math", "math-format"],
	        "kinematics": ["math"],
	        "math-format": ["math", "expressions"],
	        "polynomials": ["math", "expressions"],
	        "stat": ["math"],
	        "word-problems": ["math"],
	        "interactive": ["graphie", "knumber", "kvector", "kpoint", "kline"],
	        "mean-and-median": ["stat"],
	        "congruency": ["angles", "interactive", "graphie-helpers"],
	        "graphie": ["kpoint"],
	        "graphie-3d": ["graphie", "kmatrix", "kvector"],
	        "graphie-geometry": ["graphie", "kmatrix", "kvector", "kline"],
	        "graphie-helpers": ["math-format"],
	        "kmatrix": ["expressions"],
	        "chemistry": ["math-format"],
	        "kvector": ["knumber"],
	        "kpoint": ["kvector", "knumber"],
	        "kray": ["kpoint", "kvector"],
	        "kline": ["kpoint", "kvector"],
	        "constructions": ["kmatrix"]
	    },

	    warnTimeout: function() {
	        $(Exercises).trigger("warning", [$._("Your internet might be too " +
	                "slow to see an exercise. Refresh the page or " +
	                "<a href='' id='warn-report'>report a problem</a>."),
	                false]);
	        // TODO(alpert): This event binding is kind of gross
	        $("#warn-report").click(function(e) {
	            e.preventDefault();
	            $("#report").click();
	        });
	    },

	    warnFont: function() {
	        var warning;
	        if ($.browser.msie) {
	            warning = $._("You should " +
	                "<a href='http://missmarcialee.com/2011/08/" +
	                "how-to-enable-font-download-in-internet-explorer-8/' " +
	                "target='_blank'>enable font download</a> " +
	                "to improve the appearance of math expressions."
	            );
	        } else {
	            warning = $._("You should enable font download in your " +
	                "browser to improve the appearance of math expressions");
	        }

	        $(Exercises).trigger("warning", [warning, true]);
	    },

	    // TODO(alpert): This doesn't need to be in the Khan object.
	    getBaseModules: function() {
	        var mods = [];
	        // Base modules required for every problem.  These are specified
	        // as filenames (minus the .js extension) relative to util/.
	        // subhints is here to support the intervention experiment.
	        mods.push(
	            "answer-types", "tmpl", "tex", "jquery.adhesion",
	            "scratchpad", "subhints");

	        return mods;
	    },

	    resetModules: function(exerciseId) {
	        var modules = Khan.getBaseModules().concat(
	                Khan.exerciseModulesMap[exerciseId]);
	        var moduleSet = {};

	        $.each(modules, function(i, mod) {
	            useModule(mod);
	        });

	        Khan.modules = moduleSet;

	        function useModule(modNameOrObject) {
	            if (typeof modNameOrObject === "string") {
	                moduleSet[modNameOrObject] = true;
	                var deps = Khan.moduleDependencies[modNameOrObject] || [];

	                $.each(deps, function(i, mod) {
	                    useModule(mod);
	                });
	            } else if (modNameOrObject.name) {
	                moduleSet[modNameOrObject.name] = true;
	            }
	        }
	    },

	    loadLocalModeSiteWhenReady: function() {
	        initialModulesPromise.then(function() {
	            loadLocalModeSite();
	        });
	    },

	    // Populate this with modules
	    Util: {
	        debugLog: debugLog,

	        // http://burtleburtle.net/bob/hash/integer.html
	        // This is also used as a PRNG in the V8 benchmark suite
	        random: function() {
	            // Robert Jenkins' 32 bit integer hash function.
	            var seed = randomSeed;
	            seed = ((seed + 0x7ed55d16) + (seed << 12)) & 0xffffffff;
	            seed = ((seed ^ 0xc761c23c) ^ (seed >>> 19)) & 0xffffffff;
	            seed = ((seed + 0x165667b1) + (seed << 5)) & 0xffffffff;
	            seed = ((seed + 0xd3a2646c) ^ (seed << 9)) & 0xffffffff;
	            seed = ((seed + 0xfd7046c5) + (seed << 3)) & 0xffffffff;
	            seed = ((seed ^ 0xb55a4f09) ^ (seed >>> 16)) & 0xffffffff;
	            return (randomSeed = (seed & 0xfffffff)) / 0x10000000;
	        },

	        // Rounds num to X places, and uses the proper decimal seperator.
	        // But does *not* insert thousands separators.
	        localeToFixed: function(num, places) {
	            var localeDecimalSeperator = icu.getDecimalFormatSymbols().decimal_separator;
	            var localeFixed = num.toFixed(places).replace(".", localeDecimalSeperator);
	            if (localeFixed === "-0") {
	                localeFixed = "0";
	            }
	            return localeFixed;
	        }
	    },

	    // Query String Parser
	    // Original from:
	    // http://stackoverflow.com/questions/901115/get-querystring-values-in-javascript/2880929#2880929
	    queryString: function() {
	        var urlParams = {},
	            e,
	            a = /\+/g,  // Regex for replacing addition symbol with a space
	            r = /([^&=]+)=?([^&]*)/g,
	            d = function(s) { return decodeURIComponent(s.replace(a, " ")); },
	            q = window.location.search.substring(1);

	        while ((e = r.exec(q))) {
	            urlParams[d(e[1])] = d(e[2]);
	        }

	        return urlParams;
	    },

	    // Display error messages
	    error: function() {
	        if (typeof console !== "undefined") {
	            $.each(arguments, function(ix, arg) {
	                debugLog("error: " + arg);
	                console.error(arg);
	            });
	        }
	    },

	    scratchpad: (function() {
	        var disabled = false, wasVisible, pad;

	        var actions = {
	            disable: function() {
	                wasVisible = actions.isVisible();
	                actions.hide();

	                $("#scratchpad-show").hide();
	                $("#scratchpad-not-available").show();
	                disabled = true;
	            },

	            enable: function() {
	                if (wasVisible) {
	                    actions.show();
	                    wasVisible = false;
	                }

	                $("#scratchpad-show").show();
	                $("#scratchpad-not-available").hide();
	                disabled = false;
	            },

	            isVisible: function() {
	                return $("#scratchpad").is(":visible");
	            },

	            show: function() {

	                if (actions.isVisible()) {
	                    return;
	                }

	                var makeVisible = function() {
	                    if (!$("#scratchpad").length) {
	                        // Scratchpad's gone! The exercise template
	                        // probably isn't on screen right now, so let's
	                        // just not try and initialize stuff otherwise
	                        // Raphael will attach an <svg> to the body.
	                        return;
	                    }

	                    $("#scratchpad").show();
	                    $("#scratchpad-show").text($._("Hide scratchpad"));

	                    // If pad has never been created or if it's empty
	                    // because it was removed from the DOM, recreate a new
	                    // scratchpad.
	                    if (!pad || !$("#scratchpad div").children().length) {
	                        pad = new DrawingScratchpad(
	                            $("#scratchpad div")[0]);
	                    }

	                    // Outline things floating on top of the scratchpad
	                    $(".above-scratchpad").css("border", "1px solid #ccc");
	                };

	                makeVisible();
	            },

	            hide: function() {
	                if (!actions.isVisible()) {
	                    return;
	                }

	                $("#scratchpad").hide();
	                // Un-outline things floating on top of the scratchpad
	                $(".above-scratchpad").css("border", "");
	                $("#scratchpad-show").text($._("Show scratchpad"));
	            },

	            toggle: function() {
	                actions.isVisible() ? actions.hide() : actions.show();
	            },

	            clear: function() {
	                if (pad) {
	                    pad.clear();
	                }
	            },

	            resize: function() {
	                if (pad) {
	                    pad.resize();
	                }
	            }
	        };

	        return actions;
	    })(),

	    getSeedInfo: function() {
	        return {
	            // A hash representing the exercise version
	            sha1: typeof userExercise !== "undefined" ?
	                    userExercise.exerciseModel.sha1 : currentExerciseId,
	            seed: currentProblemSeed,
	            problem_type: currentProblemType
	        };
	    },

	    getPreviewUrl: function() {
	        return window.location.protocol + "//" + window.location.host +
	            "/preview/content/e/" + currentExerciseId + "?seed=" +
	            currentProblemSeed + "&problem=" + currentProblemType;
	    },

	    getIssueInfo: function() {
	        return {
	            framework: "khan-exercises",
	            pretitle: currentExerciseName,
	            exercise: currentExerciseId,
	            item: currentProblemType + "/" + currentProblemSeed,
	            sha: userExercise.exerciseModel.sha1,
	            previewUrl: "http://sandcastle.kasandbox.org/media/castles/Khan:master/exercises/" +
	                    currentExerciseFile + "?seed=" + currentProblemSeed + "&problem=" +
	                    currentProblemType + "&debug&lang=" + icu.getLocale(),
	            editUrl: "http://exercises.ka.local/exercises/" +
	                    currentExerciseFile + "?seed=" + currentProblemSeed + "&problem=" +
	                    currentProblemType + "&debug",
	            bodyInfo: JSON.stringify(Exercises.guessLog)
	        };
	    },

	    scoreInput: function() {
	        return validator(getAnswer());
	    },

	    submitIssue: function(issueInfo, onSuccess, onFailure) {
	        var dataObj = {
	            fields: {
	                project: { key: "AI" },
	                issuetype: { name: "Item issue report" },
	                summary: issueInfo.pretitle + " - " + issueInfo.title,
	                description: issueInfo.bodyInfo,
	                customfield_10024: [issueInfo.exercise],  // exercise
	                customfield_10026: issueInfo.sha,         // sha
	                customfield_10027: issueInfo.previewUrl,  // preview url
	                customfield_10028: issueInfo.editUrl,     // edit url
	                customfield_10025: [issueInfo.item],      // item
	                customfield_10029: { value: issueInfo.framework },  // framework
	                customfield_10202: issueInfo.debugInfo,   // debug info
	                customfield_10204: issueInfo.userFlags,   // User Type
	                customfield_10205: navigator.userAgent,   // user agent
	                customfield_10300: { value: issueInfo.type || "Other" },  // issue type
	                customfield_10301: [icu.getLocale()]      // locale
	            }
	        };

	        $.ajax({
	            url: "/jirapost",
	            type: "POST",
	            data: JSON.stringify(dataObj),
	            contentType: "application/json",
	            dataType: "json",
	            success: onSuccess,
	            error: onFailure
	        });
	    },

	    autoSubmitIssue: function(title, description) {
	        // Capture a stack trace for easier debugging. Safari requires an
	        // exception to be thrown in order for .stack to be set
	        var err;
	        try {
	            throw new Error();
	        } catch (e) {
	            err = e;
	        }
	        description += "\n\n" + err.stack;

	        var framework = Exercises.getCurrentFramework();
	        var issueInfo = framework === "khan-exercises" ?
	            Khan.getIssueInfo() :
	            Exercises.PerseusBridge.getIssueInfo();
	        $.extend(issueInfo, {
	            pretitle: "AutoGenerated",
	            title: title,
	            bodyInfo: description,
	            type: "Other",
	            userFlags: [{ value: "Auto-generated by a robot" }],
	            debugInfo: description + "\n\n" +
	                JSON.stringify(Khan.getSeedInfo()) +
	                "\n\n" + debugLogLog.join("\n")
	        });

	        Khan.submitIssue(issueInfo);
	    },

	    /**
	     * Hijacks a specified link so that it opens up the issue form.
	     * @param {string} selector The link selector - defaults to "#report"
	     */
	    initReportIssueLink: function(selector) {
	        selector = selector || "#report";
	        $(selector).click(function(e) {
	            e.preventDefault();

	            if (typeof KA !== "undefined" && KA.vipIssueReporter) {
	                $("#issue .info-box-header").text($._("VIP Issue Report"));
	            }

	            // If the hint button isn't visible, we don't want the user to
	            // see hints for some reason (e.g., this is an assessment).
	            // So also hide the show answer button.
	            if (!$("#hint").is(':visible')) {
	                $("#issue-show-answer").hide();
	            }

	            var report = $("#issue").css("display") !== "none";
	            var form = $("#issue .issue-form").css("display") !== "none";

	            if (report && form) {
	                $("#issue").hide();
	            } else if (!report || !form) {
	                $("#issue-status").removeClass("error").hide();
	                $("#issue, #issue .issue-form").show();
	                $("html, body").animate({
	                    scrollTop: $("#issue").offset().top
	                }, 500, function() {
	                    $("#issue-title").focus();
	                });
	            }
	        });

	        $("input[name=issue-type]").on("click", function() {
	            if ($(this).prop("id") === "issue-hints-wrong") {
	                $("#issue-body").prop("placeholder", $._("Tell us exactly " +
	                        "what's wrong with the hints. What answer did " +
	                        "you get and how did you get it?"));
	            } else if ($(this).prop("id") === "issue-answer-wrong") {
	                $("#issue-body").prop("placeholder", $._("Tell us exactly " +
	                        "how you tried to input the answer from the " +
	                        "hints. Did a different answer work instead?"));
	            } else if ($(this).prop("id") === "issue-confusing") {
	                $("#issue-body").prop("placeholder", $._("Tell us exactly " +
	                        "what you found confusing. How would you reword " +
	                        "the question or hints to be less confusing?"));
	            } else {
	                $("#issue-body").prop("placeholder", "");
	            }
	        });

	        // Hide "Question or hints are in English" option for english users
	        if (icu.getLanguage() === "en") {
	            $("#issue-i18n").parent().hide();
	        }

	        // Hide issue form.
	        $("#issue-cancel").click(function(e) {
	            e.preventDefault();

	            $("#issue").hide(500);
	            $("#issue-title, #issue-body").val("");
	        });

	        $("#issue-show-answer").click(function(e) {
	            e.preventDefault();
	            while (hints.length > 0) {
	                $("#hint").click();
	            }
	            $(this).addClass("disabled");
	        });
	        $(Exercises).bind("newProblem", function() {
	            $("#issue-show-answer").removeClass("disabled");
	        });

	        // Submit an issue.
	        $("#issue .issue-form input:submit").click(function(e) {

	            e.preventDefault();

	            var framework = Exercises.getCurrentFramework();
	            var issueInfo = framework === "khan-exercises" ?
	                Khan.getIssueInfo() :
	                Exercises.PerseusBridge.getIssueInfo();

	            // don't do anything if the user clicked a second time quickly
	            if ($("#issue .issue-form").css("display") === "none") {
	                return;
	            }

	            // Validate body
	            var body = $("#issue-body").val();
	            if (body === "") {
	                $("#issue-status").addClass("error")
	                    .html($._("Please provide a description of the issue.")).show();
	                return;
	            }
	            issueInfo.bodyInfo = body + "\n\n" + issueInfo.bodyInfo;

	            // Title is first 50 characters of description
	            issueInfo.title = body.substr(0, 50).replace(/\n/g, " ") +
	                    (body.length > 50 ? "..." : "");

	            // Validate type
	            var type = $("input[name=issue-type]:checked").prop("id");
	            if (!type) {
	                $("#issue-status").addClass("error")
	                    .html($._("Please specify the issue type.")).show();
	                return;
	            }

	            issueInfo.type = {
	                "issue-hints-wrong": "Answer in hints is wrong",
	                "issue-answer-wrong": "Answer in hints not accepted",
	                "issue-confusing": "Question or hints confusing",
	                "issue-i18n": "Not translated"
	            }[type];


	            // Construct debug info
	            var mathjaxInfo = "MathJax is " + (typeof MathJax === "undefined" ? "NOT loaded" :
	                    ("loaded, " + (MathJax.isReady ? "" : "NOT ") + "ready, queue length: " +
	                    MathJax.Hub.queue.queue.length));
	            var sessionStorageInfo = (typeof sessionStorage === "undefined" ||
	                    typeof sessionStorage.getItem === "undefined" ?
	                    "sessionStorage NOT enabled" : null);
	            var warningInfo = $("#warning-bar-content").text();
	            var parts = [sessionStorageInfo, mathjaxInfo, warningInfo];
	            var debugInfo = $.grep(parts, function(e) { return e != null; }).join("\n\n");
	            var mathjaxLoadFailures = $.map(MathJax.Ajax.loading, function(info, script) {
	                if (info.status === -1) {
	                    return [script + ": error"];
	                } else {
	                    return [];
	                }
	            }).join("\n");
	            if (mathjaxLoadFailures.length > 0) {
	                debugInfo += "\n\n" + mathjaxLoadFailures;
	            }
	            issueInfo.debugInfo += "\n\n" + debugLogLog.join("\n");


	            // Flag special users
	            var profile = typeof KA !== "undefined" && KA.getUserProfile();
	            var powerUser = profile && profile.get("points") >= 500000;
	            var vip = typeof KA !== "undefined" && KA.vipIssueReporter;
	            issueInfo.userFlags = [];
	            if (powerUser) {
	                issueInfo.userFlags.push({ value: "500k+ points" });
	            }
	            if (vip) {
	                issueInfo.userFlags.push({ value: "VIP" });
	                if (profile) {
	                    issueInfo.bodyInfo = "VIP issue from " +
	                            profile.get("nickname") + " (" +
	                            profile.get("email") + ")\n\n" +
	                            issueInfo.bodyInfo;
	                }
	            }

	            var formElements = $("#issue input").add("#issue textarea");

	            // disable the form elements while waiting for a server response
	            formElements.attr("disabled", true);
	            $("#issue-cancel").hide();
	            $("#issue-throbber").show();

	            var onSuccess = function(data) {
	                // hide the form
	                $("#issue-throbber").hide();
	                $("#issue .issue-form").hide();

	                var bugid = data.key;
	                // VIPs get a link to the issue
	                if (vip) {
	                    bugid = "<a href='https://khanacademy.atlassian.net/browse/" +
	                            data.key + "'>" + data.key + "</a>";
	                }

	                // show status message
	                $("#issue-status").removeClass("error")
	                    .html($._("<p>Thank you for your feedback! " +
	                        "Issue <b>%(bugid)s</b> has been opened and " +
	                        "we'll look into it shortly.</p>",
	                        {bugid: bugid}))
	                    .show();

	                // reset the form elements
	                formElements.attr("disabled", false)
	                    .not("input:submit").val("");

	                // replace throbber with the cancel button
	                $("#issue-cancel").show();
	                $("#issue-throbber").hide();
	            };

	            var onFailure = function() {
	                // show status message
	                $("#issue-status").addClass("error")
	                    .html($._("Communication with issue tracker isn't " +
	                        "working. Please file the issue manually at " +
	                        "<a href='http://github.com/Khan/khan-exercises/issues/new'>GitHub</a>. " +
	                        "Please reference item: <b>%(item)s</b>.",
	                        {item: issueInfo.exercise + "/" + issueInfo.item}))
	                    .show();

	                // enable the inputs
	                formElements.attr("disabled", false);

	                // replace throbber with the cancel button
	                $("#issue-cancel").show();
	                $("#issue-throbber").hide();
	            };

	            $.post("/api/internal/bigbingo/mark_conversions", {
	                conversion_ids: "exercise_submit_issue"
	            });

	            Khan.submitIssue(issueInfo, onSuccess, onFailure);
	        });
	    },

	    cleanupProblem: function() {
	        $("#workarea, #hintsarea").runModules(problem, "Cleanup");
	    }
	};
	// see line 178. this ends the main Khan module

	// Assign these here so that when we load the base modules, `Khan` is already
	// defined on the global namespace
	window.Khan = Khan;
	window.KhanUtil = Khan.Util;

	// Load query string params
	Khan.query = Khan.queryString();

	if (Khan.query.activity !== undefined) {
	    userExercise = {
	        current: true,
	        exerciseModel: {},
	        readOnly: true,
	        userActivity: JSON.parse(Khan.query.activity)
	    };
	}

	// Seed the random number generator with the user's hash
	if (localMode && Khan.query.seed) {
	    randomSeed = parseFloat(Khan.query.seed);
	} else {
	    randomSeed = userCRC32 || (new Date().getTime() & 0xffffffff);
	}

	onjQueryLoaded();

	function onjQueryLoaded() {
	    initEvents();

	    // Initialize to an empty jQuery set
	    exercises = $();

	    Khan.mathJaxLoaded = loadMathJax();

	    $(function() {
	        var promises = [];

	        // Load all base modules, and if this is local mode, any specified
	        // in the data-require on <html>
	        var mods = Khan.getBaseModules();
	        if (localMode) {
	            var modString = document.documentElement.getAttribute(
	                    "data-require") || "";
	            var exMods = modString.length ? modString.split(" ") : [];

	            Khan.exerciseModulesMap[currentExerciseId] = exMods;
	            mods.push.apply(mods, exMods);
	        }

	        $.each(mods, function(i, mod) {
	            promises.push(loadModule(mod));
	        });

	        promises.push(Khan.mathJaxLoaded);

	        // Ensure that all local exercises get tagged with the exercise ID
	        $("div.exercise").data("name", currentExerciseId);

	        $.when.apply($, promises).then(function() {
	            // All modules have now been loaded
	            initialModulesPromise.resolve();
	        });
	    });

	    $.fn.extend({
	        // Run the methods provided by a module against some elements
	        runModules: function(problem, type) {
	            type = type || "";

	            var info = {
	                localMode: localMode,
	                exerciseId: currentExerciseId
	            };

	            this.each(function(i, elem) {
	                elem = $(elem);

	                // Run the main method of any modules
	                $.each(Khan.modules, function(mod) {
	                    if ($.fn[mod + type]) {
	                        elem[mod + type](problem, info);
	                    }
	                });
	            });
	            return this;
	        }
	    });
	}

	function loadAndRenderExercise(nextUserExercise) {
	    debugLog("loadAndRenderExercise(" + (nextUserExercise && nextUserExercise.exercise) + ")");

	    setUserExercise(nextUserExercise);

	    var typeOverride = userExercise.problemType,
	        seedOverride = userExercise.seed;

	    var exerciseId = userExercise.exerciseModel.name,
	        exerciseFile = userExercise.exerciseModel.fileName;

	    function finishRender() {
	        // Get all problems of this exercise type...
	        var problems = exercises.filter(function() {
	            return $.data(this, "name") === exerciseId;
	        }).children(".problems").children();

	        // Make scratchpad persistent per-user
	        if (user && window.LocalStore) {
	            var lastScratchpad = LocalStore.get("scratchpad:" + user);
	            if (typeof lastScratchpad !== "undefined" && JSON.parse(lastScratchpad)) {
	                Khan.scratchpad.show();
	            }
	        }

	        $(Exercises).trigger("clearExistingProblem");

	        // Generate a new problem
	        makeProblem(exerciseId, typeOverride, seedOverride);
	    }

	    debugLog("loading and rendering " + exerciseId);
	    loadExercise(exerciseId, exerciseFile).then(
	        function() {
	            debugLog("loaded " + exerciseId + ", now rendering");
	            finishRender();
	        });
	}

	/**
	 * Returns whether we should skip the current problem because it's
	 * a duplicate (or too similar) to a recently done problem in the same
	 * exercise.
	 */
	function shouldSkipProblem() {
	    // We don't need to skip duplicate problems in test mode, which allows
	    // us to use the LocalStore localStorage abstraction from shared-package
	    if (typeof LocalStore === "undefined") {
	        return false;
	    }

	    var cacheKey = "prevProblems:" + user + ":" + currentExerciseName;
	    var cached = LocalStore.get(cacheKey);
	    var lastProblemNum = (cached && cached["lastProblemNum"]) || 0;

	    if (lastProblemNum === problemNum) {
	        // Getting here means the user refreshed the page or returned to
	        // this exercise after being away. So, we don't need to and
	        // shouldn't skip this problem.
	        return false;
	    }

	    var pastHashes = (cached && cached["history"]) || [];
	    var varsHash = $.tmpl.getVarsHash();

	    // Should skip the current problem if we've already seen it in the past
	    // few problems, but not if we've been fruitlessly skipping for a while.
	    // The latter situation could happen if a problem has very few unique
	    // problems (eg. exterior angles problem type of angles_of_a_polygon).
	    if (_.contains(pastHashes, varsHash) && consecutiveSkips < dupWindowSize) {
	        consecutiveSkips++;
	        return true;
	    } else {
	        consecutiveSkips = 0;
	        pastHashes.push(varsHash);
	        while (pastHashes.length > dupWindowSize) {
	            pastHashes.shift();
	        }

	        if (LocalStore.isEnabled()) {
	            LocalStore.set(cacheKey, {
	                lastProblemNum: problemNum,
	                history: pastHashes
	            });
	        }
	        return false;
	    }
	}


	function checkIfAnswerEmpty(guess) {
	    // If multiple-answer, join all responses and check if that's empty
	    // Remove commas left by joining nested arrays in case multiple-answer is nested
	    return $.trim(guess) === "" || (guess instanceof Array &&
	             $.trim(guess.join("").replace(/,/g, "")) === "");
	}

	function makeProblem(exerciseId, typeOverride, seedOverride) {
	    debugLog("makeProblem(" + exerciseId + ", " + typeOverride + ", " + seedOverride + ")");

	    Khan.scratchpad.enable();

	    // Allow passing in an arbitrary seed
	    if (typeof seedOverride !== "undefined") {
	        currentProblemSeed = seedOverride;

	    // If no user, just pick a random seed
	    } else if (user == null) {
	        currentProblemSeed = Math.abs(randomSeed % bins);
	    }
	    debugLog("  using seed " + currentProblemSeed + " for " + exerciseId);

	    // Set randomSeed to what currentProblemSeed is (save currentProblemSeed for recall later)
	    randomSeed = currentProblemSeed;

	    // Check to see if we want to test a specific problem
	    if (localMode) {
	        typeOverride = typeof typeOverride !== "undefined" ? typeOverride : Khan.query.problem;
	    }

	    // problems contains the unprocessed contents of each problem type within exerciseId
	    var problems = exercises.filter(function() {
	        return $.data(this, "name") === exerciseId;
	    }).children(".problems").children();

	    if (!problems.length) {
	        Khan.error("No problem matching exerciseId " + exerciseId);
	    }

	    if (typeof typeOverride !== "undefined") {
	        problem = /^\d+$/.test(typeOverride) ?
	            // Access a problem by number
	            problems.eq(parseFloat(typeOverride)) :

	            // Or by its ID
	            problems.filter("#" + typeOverride);

	        currentProblemType = typeOverride;

	    // Otherwise create a random problem from weights
	    } else {
	        var typeIndex = [];
	        $.each(problems, function(index) {
	            if ($(this).data("weight") === 0) { return; }
	            var weight = $(this).data("weight") || 1;
	            _.times(weight, function(){ typeIndex.push(index); });
	        });
	        var typeNum = typeIndex[Math.floor(Math.random() * typeIndex.length)];
	        problem = problems.eq(typeNum);
	        currentProblemType = $(problem).attr("id") || "" + typeNum;
	    }

	    // TODO(brianmerlob): If we still don't have a problem then it's time to fail as gracefully
	    // as we can. This probably occurs during mastery challenges when some sort of race
	    // condition causes the type for one problem to sneak it's way in for another problem
	    // and then `problem = problems.eq(type)` returns an empty object (thus length === 0).
	    // This should _never_ happen, and hopefully these autoSubmitIssues will help debug.
	    if (!problem.length && problems.length) {
	        Khan.autoSubmitIssue("type was for the incorrect problem; failed gracefully");
	        problem = problems.eq(Math.floor(Math.random() * problems.length));
	    }

	    // Find which exercise this problem is from
	    exercise = problem.parents("div.exercise").eq(0);

	    debugLog("  chose problem type [" + currentProblemType + "] and seed [" + currentProblemSeed + "] for " + exerciseId);

	    // Work with a clone to avoid modifying the original
	    problem = problem.clone();

	    debugLog("cloned problem");

	    // problem has to be child of visible #workarea for MathJax metrics to all work right
	    $("#workarea").append(problem);

	    // If there's an original problem, add inherited elements
	    var parentType = problem.data("type");

	    while (parentType) {
	        // Copy over the parent element to the child
	        var original = exercise.find(".problems #" + parentType).clone();
	        problem.prepend(original.children().data("inherited", true));

	        // Keep copying over the parent elements (allowing for deep inheritance)
	        parentType = original.data("type");
	    }

	    // Add any global exercise defined elements
	    problem.prepend(exercise.children(":not(.problems)").clone().data("inherited", true));

	    debugLog("cloned global elements");

	    // Apply templating
	    var children = problem
	        // var blocks append their contents to the parent
	        .find(".vars").tmplApply({attribute: "class", defaultApply: "appendVars"}).end()

	        // Individual variables override other variables with the same name
	        .find(".vars [id]").tmplApply().end()

	        // We also look at the main blocks within the problem itself to override,
	        // ignoring graphie and spin blocks
	        .children("[class][class!='graphie'][class!='spin']").tmplApply({attribute: "class"});

	    debugLog("ran tmplApply to vars and main elements");

	    // Finally we do any inheritance to the individual child blocks (such as problem, question, etc.)
	    children.each(function() {
	        // Apply while adding problem.children() to include
	        // template definitions within problem scope
	        $(this).find("[id]").add(children).tmplApply();
	    });

	    debugLog("ran tmplApply to [id]");

	    // Remove and store hints to delay running modules on it
	    hints = problem.children(".hints").remove();

	    // Only show the calculator if it's specifically allowed for this problem
	    if (problem.data("calculator") == null) {
	        $("#calculator").hide();
	    } else {
	        $("#calculator").show();
	    }

	    debugLog("removed hints from DOM");

	    // Evaluate any inline script tags in this exercise's source
	    $.each(exercise.data("script") || [], function(i, scriptContents) {
	        $.globalEval(scriptContents);
	    });

	    debugLog("evaled inline scripts");

	    // ...and inline style tags.
	    if (exercise.data("style")) {
	        var exerciseStyleElem = $("#exercise-inline-style");

	        // Clear old exercise style definitions
	        if (exerciseStyleElem.length && exerciseStyleElem[0].styleSheet) {
	            // IE refuses to modify the contents of <style> the normal way
	            exerciseStyleElem[0].styleSheet.cssText = "";
	        } else {
	            exerciseStyleElem.empty();
	        }

	        // Then add rules specific to this exercise.
	        $.each(exercise.data("style"), function(i, styleContents) {
	            if (exerciseStyleElem.length && exerciseStyleElem[0].styleSheet) {
	                // IE refuses to modify the contents of <style> the normal way
	                exerciseStyleElem[0].styleSheet.cssText = exerciseStyleElem[0].styleSheet.cssText + styleContents;
	            } else {
	                exerciseStyleElem.append(styleContents);
	            }
	        });
	    }

	    debugLog("added inline styles");

	    // Reset modules to only those required by the current exercise
	    Khan.resetModules(exerciseId);

	    // Run the main method of any modules
	    problem.runModules(problem, "Load");
	    debugLog("done with runModules Load");
	    problem.runModules(problem);
	    debugLog("done with runModules");

	    if (typeof seedOverride === "undefined" && shouldSkipProblem()) {
	        // If this is a duplicate problem we should skip, just generate
	        // another problem of the same problem type but w/ a different seed.
	        debugLog("duplicate problem!");
	        $(Exercises).trigger("clearExistingProblem");
	        nextSeed(1);
	        return makeProblem(exerciseId);
	    }

	    // Store the solution to the problem
	    var solution = problem.find(".solution"),

	        // Get the multiple choice problems
	        choices = problem.find(".choices"),

	        // Get the area into which solutions will be inserted,
	        // Removing any previous answer
	        solutionarea = $("#solutionarea").empty(),

	        // See if we're looking for a specific style of answer
	        answerType = solution.data("type");

	    // Make sure that the answer type exists
	    if (answerType) {
	        if (Khan.answerTypes && !Khan.answerTypes[answerType]) {
	            Khan.error("Unknown answer type specified: " + answerType);
	            return;
	        }
	    }

	    if (!answerType) {
	        // If a multiple choice block exists
	        if (choices.length) {
	            answerType = "radio";

	        // Otherwise we assume the smart number type
	        } else {
	            answerType = "number";
	        }
	    }

	    // Generate a type of problem
	    // (this includes possibly generating the multiple choice problems,
	    // if this fails then we will need to try generating another one.)
	    debugLog("decided on answer type " + answerType);
	    answerData = Khan.answerTypes[answerType].setup(solutionarea, solution);

	    validator = answerData.validator;
	    getAnswer = answerData.answer;
	    debugLog("validator created");

	    // A working solution was generated
	    if (validator) {
	        // Have MathJax redo the font metrics for the solution area
	        // (ugh, this is gross)
	        KhanUtil.processAllMath($("#solutionarea")[0], true);

	        // Focus the first input
	        // Use .select() and on a delay to make IE happy
	        var firstInput = solutionarea.find(":input").first();
	        if ($(".calculator input:visible").length) {
	            firstInput = $(".calculator input");
	        }

	        setTimeout(function() {
	            if (!firstInput.is(":disabled")) {
	                firstInput.focus();
	                if (firstInput.is("input:text")) {
	                    firstInput.select();
	                }
	            }
	        }, 1);

	        lastFocusedSolutionInput = firstInput;
	        solutionarea.find(":input").focus(function() {
	            // Save which input is focused so we can refocus it after the user hits Check Answer
	            lastFocusedSolutionInput = this;
	        });
	    } else {
	        // Making the problem failed, let's try again (up to 3 times)
	        debugLog("validator was falsey");
	        problem.remove();
	        if (failureRetryCount < 100) {
	            failureRetryCount++;
	            // If this seed didn't work for some reason, just try the next
	            // seed for the same problem type. This probably happens because:
	            //
	            // 1)  Something with a multiple-choice answer requires, say 4
	            //     choices, but this seed was only able to generate three
	            //     choices.
	            // 1a) A multiple choice question doesn't require a specific number
	            //     of choices and therefore requires all choices to be shown,
	            //     but there were duplicates among the generate choices leading
	            //     to fewer than all of them able to be shown, so we give up
	            //     and have to try with a different seed.
	            //
	            // TODO(eater): Handle this case better. Since this leads to
	            // potentially duplicate problems (e.g., when seed 10, 11, and 12
	            // all fall back to seed 12), users see less variety.
	            var newSeed = (currentProblemSeed + 1) % bins;

	            makeProblem(exerciseId, typeOverride, newSeed);
	        } else {
	            debugLog("Failed making problem too many times");
	            Khan.error("Failed while attempting to MakeProblem too many " +
	                "times in a row");
	        }
	        return;
	    }

	    // Remove the solution and choices elements from the display
	    // Some exercises (e.g., parabola_intuition_3) break if we don't remove
	    // so always do it unless ?noremovesolution is explicitly passed
	    if (localMode && Khan.query.noremovesolution != null) {
	        solution.hide();
	        choices.hide();
	    } else {
	        solution.remove();
	        choices.remove();
	    }

	    // Add the problem into the page
	    Khan.scratchpad.resize();

	    // Enable the all answer input elements except the check answer button.
	    $("#answercontent input")
	        .not("#check-answer-button, #show-prereqs-button")
	        .prop("disabled", false);

	    // Show acceptable formats
	    if (examples !== null && answerData.examples && answerData.examples.length > 0) {
	        $("#examples-show").show();
	        examples.empty();

	        $.each(answerData.examples, function(i, example) {
	            examples.append("<li>" + example + "</li>");
	        });

	        if ($("#examples-show").data("qtip")) {
	            $("#examples-show").qtip("destroy", /* immediate */ true);
	        }

	        $("#examples-show").qtip({
	            content: {
	                text: examples.remove(),
	                prerender: true
	            },
	            style: {classes: "qtip-light leaf-tooltip"},
	            position: {
	                my: "center right",
	                at: "center left"
	            },
	            show: {
	                delay: 200,
	                effect: {
	                    length: 0
	                }
	            },
	            hide: {delay: 0},
	            events: {
	                render: function() {
	                    // Only run the modules when the qtip is actually shown
	                    examples.children().runModules();
	                }
	            }
	        });
	    } else {
	        $("#examples-show").hide();
	    }
	    // save a normal JS array of hints so we can shift() through them later
	    hints = hints.tmpl().children().get();

	    // Hook out for exercise test runner
	    if (localMode && parent !== window && typeof parent.jQuery !== "undefined") {
	        parent.jQuery(parent.document).trigger("problemLoaded", [makeProblem, answerData.solution]);
	    }

	    $("#hint").val($._("I'd like a hint"));

	    $(Exercises).trigger("newProblem", {
	        numHints: hints.length,
	        userExercise: userExercise,
	        answerData: answerData,
	        answerType: answerType,
	        solution: solution,
	        hints: hints,
	        problem: problem
	    });

	    hintsUsed = userExercise ? userExercise.lastCountHints : 0;

	    // The server says the user has taken hints on this problem already
	    // show all lastCountHints it says we have seen
	    _(hintsUsed).times(showHint);

	    // Add autocomplete="off" attribute so IE doesn't try to display previous answers
	    $("#problem-and-answer").find("input[type='text'], input[type='number']")
	                            .attr("autocomplete", "off");

	    // If the textbox is empty disable "Check Answer" button
	    // Note: We don't do this for multiple choice, number line, etc.
	    if (answerType === "text" || answerType === "number") {
	        var checkAnswerButton = $("#check-answer-button");
	        var skipQuestionButton = $("#skip-question-button");
	        checkAnswerButton.attr("disabled", "disabled").attr(
	            "title", $._("Type in an answer first."));
	        // Enables the check answer button - added so that people who type
	        // in a number and hit enter quickly do not have to wait for the
	        // button to be enabled by the key up
	        $("#solutionarea")
	            .on("keypress.emptyAnswer", function(e) {
	                if (e.keyCode !== 13) {
	                    checkAnswerButton.prop("disabled", false)
	                        .removeAttr("title");
	                }
	            })
	            .on("keyup.emptyAnswer", function(e) {
	                var guess = getAnswer();
	                if (checkIfAnswerEmpty(guess)) {
	                    skipQuestionButton.prop("disabled", false);
	                    checkAnswerButton.prop("disabled", true);
	                } else if (e.keyCode !== 13) {
	                    // Enable check answer button again as long as it is
	                    // not the enter key
	                    checkAnswerButton.prop("disabled", false);
	                    skipQuestionButton.prop("disabled", true);
	                }
	            });

	    }

	    return answerType;
	}

	function showHint() {
	    debugLog("showHint()");
	    // Called when user hits hint button triggering showHint event or when
	    // the server side data says the last_count_hints is not 0 when
	    // exercise is loaded.
	    var hint = hints.shift();
	    if (!hint) {
	        // :(
	        return;
	    }

	    hintsUsed++;

	    var problem = $(hint).parent();

	    // Append first so MathJax can sense the surrounding CSS context properly
	    $(hint).appendTo("#hintsarea").runModules(problem);

	    if (hints.length === 0) {
	        $(hint).addClass("last-hint");
	    }

	    // TODO(james): figure out a way to trigger hintUsed to ensure that the
	    // cards are updated properly, but make sure the ajax calls to
	    // submit the hints are not resubmited for the case where we are
	    // calling this function because last_count_hints was not 0
	}

	function renderDebugInfo() {
	    debugLog("renderDebugInfo()");
	    // triggered on newProblem

	    if (userExercise == null || Khan.query.debug != null) {
	        $("#problem-permalink").text("Permalink: " +
	                                     currentProblemType + " #" +
	                                     currentProblemSeed)
	            .attr("href", window.location.protocol + "//" + window.location.host + window.location.pathname + "?debug&problem=" + currentProblemType + "&seed=" + currentProblemSeed);
	    }

	    // Show the debug info
	    if (localMode && Khan.query.debug != null) {
	        $(document).keypress(function(e) {
	            if (e.charCode === 104) {
	                $("#hint").click();
	            }
	        });
	        var debugWrap = $("#debug").css({"margin-right": "15px"}).empty();
	        var debugURL = window.location.protocol + "//" + window.location.host + window.location.pathname +
	            "?debug&problem=" + currentProblemType;

	        $("<h3>Debug Info</h3>").appendTo(debugWrap);

	        var src = exercise.data("src");
	        if (src != null) {
	            var srcInfo = $("<p>").appendTo(debugWrap);
	            srcInfo.append("From ");

	            $("<a>")
	                .text(src)
	                .attr("href", src + "?debug")
	                .appendTo(srcInfo);
	        }

	        var links = $("<p>").appendTo(debugWrap);

	        if (!Khan.query.activity) {
	            var historyURL = debugURL + "&seed=" + currentProblemSeed + "&activity=";
	            $("<a>Problem history</a>").attr("href", "javascript:").click(function() {
	                window.location.href = historyURL + encodeURIComponent(
	                        JSON.stringify(Exercises.userActivityLog));
	            }).appendTo(links);
	        } else {
	            $("<a>Random problem</a>")
	                .attr("href", window.location.protocol + "//" +
	                        window.location.host + window.location.pathname +
	                        "?debug")
	                .appendTo(links);
	        }

	        links.append("<br><b>Problem types:</b><br>");

	        exercises.children(".problems").children().each(function(n, prob) {
	            var probID = $(prob).attr("id") || "" + n;
	            links.append($("<div>")
	                .css({
	                    "padding-left": "20px",
	                    "outline":
	                        (currentProblemType === probID) ?
	                        "1px dashed gray" : ""
	                })
	                .append($("<span>").text(n + ": "))
	                .append($("<a>")
	                    .text(probID)
	                    .attr("href", window.location.protocol + "//" +
	                        window.location.host + window.location.pathname +
	                        "?debug&problem=" + probID)
	                ));
	        });


	        // If this is a child exercise, show which one it came from
	        if (exercise.data("name") !== currentExerciseId) {
	            links.append("<br>");
	            links.append("Original exercise: " + exercise.data("name"));
	        }

	        if ($.tmpl.DATA_ENSURE_LOOPS > 0) {
	            var dataEnsureInfo = $("<p>");
	            dataEnsureInfo.append("Data-ensure loops: " + $.tmpl.DATA_ENSURE_LOOPS);
	            if ($.tmpl.DATA_ENSURE_LOOPS > 15) {
	                dataEnsureInfo.css("background-color", "yellow");
	            }
	            if ($.tmpl.DATA_ENSURE_LOOPS > 30) {
	                dataEnsureInfo.css("background-color", "orange");
	            }
	            if ($.tmpl.DATA_ENSURE_LOOPS > 50) {
	                dataEnsureInfo.css("background-color", "red");
	            }
	            dataEnsureInfo.appendTo(debugWrap);
	        }

	        if (typeof $.tmpl.VARS !== "undefined") {
	            var varInfo = $("<p>");

	            $.each($.tmpl.VARS, function(name, value) {
	                var str;

	                if (typeof value === "function") {
	                    str = value.toString();
	                } else {
	                    // JSON is prettier (when it works)
	                    try {
	                        str = JSON.stringify(value);
	                    } catch (e) {
	                        str = value.toString();
	                    }
	                }

	                varInfo.append($("<b>").text(name));
	                varInfo.append(": ");
	                varInfo.append($("<var>").text(str));
	                varInfo.append("<br>");
	            });

	            varInfo.appendTo(debugWrap);
	        }

	        // for special style rules

	        $("body").addClass("debug");
	    }
	}

	function renderExerciseBrowserPreview() {
	    debugLog("renderExerciseBrowserPreview()");
	    // triggered on newProblem

	    // Version of the site used by Khan/exercise-browser for the iframe
	    // preview
	    if (localMode && Khan.query.browse != null) {
	        $("html").addClass("exercise-browser");

	        var browseWrap = $("#browse").empty();

	        var links = $("<div>").addClass("problem-types");

	        links.append($("<b>").text("Problem types:"));

	        exercises.children(".problems").children().each(function(n, prob) {
	            var probName = $(prob).attr("id");
	            var probID = probName || n;
	            var weight = $(prob).data("weight");
	            weight = weight != null ? weight : 1;

	            if (weight !== 0) {
	                $("<a>").addClass("problem-type-link")
	                    .text("#" + (n + 1) +
	                        (probName != null ? ": " + probName : ""))
	                    .attr("href", window.location.protocol + "//" +
	                        window.location.host + window.location.pathname +
	                        "?browse&problem=" + probID)
	                    .appendTo(links);
	            }
	        });

	        browseWrap.append(links);
	    }
	}

	function renderNextProblem(data) {
	    if (localMode) {
	        // Just generate a new problem from existing exercise
	        $(Exercises).trigger("clearExistingProblem");
	        makeProblem(currentExerciseId);
	    } else {
	        loadAndRenderExercise(data.userExercise);
	    }
	}

	/**
	 * Called once each time an exercise page is initialized.
	 * For multi-exercise pages, this can be called multiple times!
	 * (e.g. in a tutorial view, where there is client side navigation between
	 * different exercises).
	 */
	function prepareSite() {
	    debugLog("prepareSite()");
	    // Grab example answer format container
	    examples = $("#examples");

	    assessmentMode = !localMode && Exercises.assessmentMode;
	    function initializeCalculator() {
	        var ansChars = ["+", "-", "/", "*", "^", " "];
	        var calculator = $(".calculator"),
	            history = calculator.children(".history"),
	            output = $("#calc-output-content"),
	            outputContainer = $("#calc-output"),
	            inputRow = history.children(".calc-row.input"),
	            input = inputRow.children("input"),
	            buttons = calculator.find("a"),
	            previousInstrs = [],
	            currentInstrIndex = -1,
	            lastInstr = "",
	            ans = 0,
	            prevAnswer,
	            containsAns = false,
	            separator = icu.getDecimalFormatSymbols().decimal_separator;

	        var formatInputHistory = function(text) {
	            return text.replace(/pi/g, "\u03c0") + " =";
	        };

	        var appendDiv = function(div) {
	            output.append(div);
	            output.scrollTop(output[0].scrollHeight);
	        };

	        var insertPrevAnswer = function() {
	            var outdiv;
	            if (prevAnswer !== undefined) {
	                outdiv = $("<div>").addClass("output").text(prevAnswer);
	                prevAnswer = undefined;
	                appendDiv(outdiv);
	            }
	        };

	        var evaluate = function() {
	            var instr = input.val();
	            var indiv, output, outstr;
	            var isError = false;
	            var newInputVal = instr;
	            if ($.trim(instr) !== "") {
	                lastInstr = instr;
	                previousInstrs.unshift(instr);
	                indiv = $("<div>").addClass("input-history")
	                                  .text(formatInputHistory(instr));
	                try {
	                    if (separator !== ".") {
	                        // i18nize the input numbers' decimal point
	                        instr = instr.split(separator).join(".");
	                    }
	                    output = ans = Calculator.calculate(instr, ans);
	                    if (typeof output === "number") {
	                        outstr = Math.round(output * 1000000000) / 1000000000;
	                        if (separator !== ".") {
	                            // i18nize the output number's decimal point
	                            outstr = ("" + outstr).replace(".", separator);
	                        }
	                    } else {
	                        outstr = output;
	                    }
	                    newInputVal = outstr;
	                } catch (e) {
	                    if (e instanceof Calculator.CalculatorError) {
	                        outstr = e.message;
	                        newInputVal = instr;
	                        isError = true;
	                        containsAns = false;
	                        input.css({
	                            backgroundColor: "#ffcccc"
	                        });
	                        return;
	                    } else {
	                        throw e;
	                    }
	                }
	                insertPrevAnswer();
	                appendDiv(indiv);
	                prevAnswer = outstr;
	                // errors should appear immediately
	                if (isError) {
	                    insertPrevAnswer();
	                }
	            }

	            containsAns = true;
	            currentInstrIndex = -1;
	            input.val(newInputVal);
	        };

	        var selected = function(text) {
	            return "<span class='selected-anglemode'>" + text + "</span>";
	        };

	        var unselected = function(text) {
	            return "<span class='unselected-anglemode'>" + text + "</span>";
	        };

	        var updateAngleMode = function() {
	            // I18N: "DEGrees" calculator button (3 chars or less)
	            var deg = $._("DEG");
	            // I18N: "RADians" calculator button (3 chars or less)
	            var rad = $._("RAD");
	            if (Calculator.settings.angleMode === "DEG") {
	                $(".calculator-angle-mode").html(unselected(rad) +
	                                                 "<br>" +
	                                                 selected(deg));
	            } else {
	                $(".calculator-angle-mode").html(selected(rad) +
	                                                 "<br>" +
	                                                 unselected(deg));
	            }
	        };

	        // backspace etc isn't caught by keypress...
	        var BACKSPACE = 8;
	        var LEFT = 37;
	        var RIGHT = 39;
	        var UP = 38;
	        var DOWN = 40;
	        var keysToCancel = [LEFT, RIGHT];
	        input.on("keydown", function(e) {
	            if (_.contains(keysToCancel, e.keyCode)) {
	                containsAns = false;
	            }
	            if (e.which === BACKSPACE) {
	                if (containsAns) {
	                    input.val("");
	                    insertPrevAnswer();
	                    return false;
	                }
	            }

	            if (e.which === UP) {
	                insertPrevAnswer();
	                currentInstrIndex += 1;
	                if (currentInstrIndex >= previousInstrs.length) {
	                    currentInstrIndex = previousInstrs.length - 1;
	                }
	                input.val(previousInstrs[currentInstrIndex]);
	                return false;
	            }
	            if (e.which === DOWN) {
	                insertPrevAnswer();
	                currentInstrIndex -= 1;
	                if (currentInstrIndex < -1) {
	                    currentInstrIndex = -1;
	                }
	                input.val(previousInstrs[currentInstrIndex] || ans);
	                return false;
	            }
	        });

	        var insertText = function(inputtedChar) {
	            var shouldOverwriteAns = !_.contains(ansChars, inputtedChar) &&
	                                    containsAns;

	            insertPrevAnswer();
	            containsAns = false;
	            if (shouldOverwriteAns) {
	                input.val("");
	            }
	            input.css({
	                backgroundColor: "white"
	            });
	        };

	        history.on("click", function(e) {
	            input.focus();
	        });

	        // The enter handler needs to bind to keypress to prevent the
	        // surrounding form submit... (http://stackoverflow.com/a/587575)
	        var ENTER = 13;
	        var EQUALS = 61;
	        input.on("keypress", function(e) {
	            if (e.which === ENTER || e.which === EQUALS) {
	                evaluate();
	                return false;
	            }
	            insertText(String.fromCharCode(e.charCode));
	        });

	        input.on("click", function(e) {
	            containsAns = false;
	        });

	        buttons.on("click", function() {
	            var jel = $(this),
	                behavior = jel.data("behavior");

	            if (behavior != null) {
	                if (behavior === "bs") {
	                    var val = input.val();
	                    input.val(val.slice(0, val.length - 1));
	                } else if (behavior === "clear") {
	                    input.val("");
	                    ans = undefined;
	                    prevAnswer = undefined;
	                    previousInstrs = [];
	                    currentInstrIndex = -1;
	                    containsAns = false;
	                    output.empty();
	                } else if (behavior === "angle-mode") {
	                    Calculator.settings.angleMode =
	                        Calculator.settings.angleMode === "DEG" ?
	                        "RAD" : "DEG";
	                    if (typeof window.localStorage !== "undefined") {
	                        window.localStorage["calculator_settings:" +
	                            window.USERNAME] = JSON.stringify(
	                            Calculator.settings);
	                    }
	                    updateAngleMode();
	                } else if (behavior === "evaluate") {
	                    evaluate();
	                }
	            } else {
	                var text = jel.data("text") || jel.text();
	                insertText(text);
	                input.val(input.val() + text);
	            }

	            input.focus();
	            return false;
	        });

	        $(Exercises).on("gotoNextProblem", function() {
	            input.val("");
	            output.children().not(inputRow).remove();
	        });

	        updateAngleMode();

	        // i18nize the decimal point button
	        $(".calculator-decimal").html(separator);
	    }

	    !/* require */(/* limit */function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(15)]; (initializeCalculator.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}());
	    Khan.initReportIssueLink("#extras .report-issue-link");

	    $("#answer_area").delegate("input.button, select", "keydown", function(e) {
	        // Don't want to go back to exercise dashboard; just do nothing on backspace
	        if (e.keyCode === 8) {
	            return false;
	        }
	    });

	    // Prepare for the debug info if requested
	    if (localMode && Khan.query.debug != null) {
	        $('<div id="debug"></div>').appendTo("#answer_area");
	    }

	    // Likewise, if we're in browse mode, setup for that
	    if (localMode && Khan.query.browse != null) {
	        $('<div id="browse"></div>').appendTo("#answer_area");
	    }

	    $(Khan)
	        .bind("updateUserExercise", function(ev, data) {
	            // TODO(alpert): Why isn't this in setUserExercise?
	            // Any time we update userExercise, check if we're
	            // setting/switching usernames
	            if (data && data.userExercise) {
	                user = data.userExercise.user || user;
	                userCRC32 = user != null ? crc32(user) : null;
	                randomSeed = userCRC32 || randomSeed;
	            }
	        });

	    $(Khan).bind("gotoNextProblem", function() {
	        if (localMode) {
	            // Automatically advance to the next problem
	            nextProblem(1);
	            renderNextProblem();
	        } else {
	            // Just listen for the readyForNextProblem event, which will
	            // include an updated userExercise (and thus an updated problem
	            // number)
	        }
	    });
	}

	function initEvents() {
	    // This function gets called as soon as jQuery is loaded -- on the live
	    // site, that's immediately upon execution
	    $(Khan)
	        .bind("problemTemplateRendered", prepareSite)
	        .bind("readyForNextProblem", function(ev, data) {
	            renderNextProblem(data);
	        })
	        .bind("upcomingExercise", function(ev, data) {
	            var userExercise = data.userExercise;
	            loadExercise(
	                    userExercise.exercise,
	                    userExercise.exerciseModel.fileName);
	        })
	        .bind("showHint", function() {
	            showHint();
	            $(Exercises).trigger("hintShown", {
	                card: Exercises.currentCard
	            });
	        })
	        .bind("refocusSolutionInput", function() {
	            // Refocus text field so user can type a new answer
	            if (lastFocusedSolutionInput != null) {
	                setTimeout(function() {
	                    var focusInput = $(lastFocusedSolutionInput);

	                    if (!focusInput.is(":disabled")) {
	                        // focus should always work; hopefully select
	                        // will work for text fields
	                        focusInput.focus();
	                        if (focusInput.is("input:text")) {
	                            focusInput.select();
	                        }
	                    }
	                }, 1);
	            }
	        });
	    $(Exercises)
	        .bind("newProblem", renderDebugInfo)
	        .bind("newProblem", renderExerciseBrowserPreview);
	}

	function deslugify(name) {
	    name = name.replace(/_/g, " ");
	    return name.charAt(0).toUpperCase() + name.slice(1);
	}

	function setProblemNum(num) {
	    problemNum = num;
	    currentProblemSeed = (seedOffset + jumpNum * (problemNum - 1 + seedsSkipped)) % bins;
	}

	function getSeedsSkippedCacheKey() {
	    return "seedsSkipped:" + user + ":" + currentExerciseName;
	}

	/**
	 * Advances the seed (as if the problem number had been advanced) without
	 * actually changing the problem number. Caches how many seeds we've skipped
	 * so that refreshing does not change the generated problem.
	 * @param {number} num Number of times to advance the seed.
	 */
	function nextSeed(num) {
	    seedsSkipped += num;
	    if (typeof LocalStore !== "undefined") {
	        LocalStore.set(getSeedsSkippedCacheKey(), seedsSkipped);
	    }
	    setProblemNum(problemNum);
	}

	function nextProblem(num) {
	    setProblemNum(problemNum + num);
	}

	function setUserExercise(data) {
	    userExercise = data;

	    if (data && data.exercise) {
	        currentExerciseId = data.exercise;
	        currentExerciseName = data.exerciseModel.displayName;
	        currentExerciseFile = data.exerciseModel.fileName;
	    }

	    if (user != null) {
	        // How far to jump through the problems
	        jumpNum = primes[userCRC32 % primes.length];

	        // The starting problem of the user
	        seedOffset = userCRC32 % bins;

	        // The number of seeds that were skipped due to duplicate problems
	        seedsSkipped = (typeof LocalStore !== "undefined" &&
	            LocalStore.get(getSeedsSkippedCacheKey()) || 0);

	        // Advance to the current problem seed
	        setProblemNum(userExercise.totalDone + 1);
	    }
	}

	/**
	 * Load an exercise and return a promise that is resolved when an exercise
	 * is loaded
	 *
	 * @param {string} exerciseId uniquely identifies exercise (e.g. addition_1)
	 * @param {string} fileName identifies the exercise's path
	 */
	function loadExercise(exerciseId, fileName) {
	    var promise = exerciseFilePromises[exerciseId];
	    if (promise != null) {
	        // Already started (or finished) loading this exercise
	        return promise;
	    } else {
	        promise = exerciseFilePromises[exerciseId] = $.Deferred();
	    }

	    // Promises for remote exercises contained within this one
	    var subpromises = [];

	    debugLog("loadExercise start " + fileName);
	    // Packing occurs on the server but at the same "exercises/" URL
	    $.get(urlBase + "exercises/" + fileName).done(function(data) {
	        debugLog("loadExercise got " + fileName);

	        // Get rid of any external scripts in data before we shove data
	        // into a jQuery object. IE8 will attempt to fetch these external
	        // scripts otherwise.
	        // See https://github.com/Khan/khan-exercises/issues/10957
	        data = data.replace(/<script(\s)+src=([^<])*<\/script>/, "");

	        var newContents = $(data).filter(".exercise");

	        // ...then save the exercise ID and fileName for later
	        newContents.data({
	            name: exerciseId,
	            fileName: fileName
	        });

	        // Add the new exercise elements to the exercises DOM set
	        exercises = exercises.add(newContents);

	        // Extract data-require
	        var match = data.match(
	                /<html(?:[^>]+)data-require=(['"])((?:(?!\1).)*)\1/);
	        var requires;
	        if (match != null) {
	            requires = match[2].length ? match[2].split(" ") : [];
	        } else {
	            requires = [];
	        }

	        $.each(requires.concat(Khan.getBaseModules()), function(i, mod) {
	            debugLog("loadExercise submod " + (mod.src || mod));
	            subpromises.push(loadModule(mod));
	        });

	        // Store the module requirements in exerciseModulesMap
	        Khan.exerciseModulesMap[exerciseId] = requires;

	        // Extract contents from various tags and save them up for parsing
	        // when actually showing this particular exercise.
	        var tagsToExtract = {
	            // TODO(alpert): Do we use title?
	            title: /<title>([^<]*(?:(?!<\/title>)<[^<]*)*)<\/title>/gi,

	            // Scripts with no src
	            script: /<(?:)script\b[^s>]*(?:(?!src=)s[^s>]*)*>([^<]*(?:(?!<\/script>)<[^<]*)*)<\/script>/gi,

	            style: /<style[^>]*>([\s\S]*?)<\/style>/gi
	        };

	        $.each(tagsToExtract, function(tag, regex) {
	            var result = [];
	            while ((match = regex.exec(data)) != null) {
	                result.push(match[1]);
	            }

	            newContents.data(tag, result);
	        });

	        // Wait for any modules to load, then resolve the promise
	        $.when.apply($, subpromises).then(function() {
	            // Success; all modules loaded
	            debugLog("loadExercise finish " + fileName);
	            promise.resolve();
	        }, function() {
	            // Failure; some modules failed to load
	            // TODO(alpert): Find a useful error message
	            debugLog("loadExercise subfail " + fileName);
	            promise.reject();
	        });
	    }).fail(function(xhr, status) {
	        debugLog("loadExercise err " + xhr.status + " " + fileName);
	        Khan.warnTimeout();
	    });

	    return promise;
	}

	function loadModule(moduleName) {
	    // Return the promise if it exists already
	    var selfPromise = modulePromises[moduleName];
	    if (selfPromise) {
	        return selfPromise;
	    } else {
	        selfPromise = $.Deferred();
	    }
	    debugLog("loadModule mod " + moduleName);

	    // Load the module
	    !/* require */(/* limit */function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(12)("./" + moduleName + ".js")]; (function() {
	        selfPromise.resolve();
	    }.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}());

	    modulePromises[moduleName] = selfPromise;
	    return selfPromise;
	}

	// Load a script by URL, then execute callback
	function loadScript(url, callback) {
	    var head = document.getElementsByTagName("head")[0];

	    debugLog("loadScript loading " + url);

	    // Adapted from jQuery getScript (ajax/script.js) -- can't use
	    // jQuery here because we load jQuery using this routine
	    var script = document.createElement("script");
	    script.async = "async";
	    script.src = url;

	    script.onerror = function() {
	        // No error in IE, but this is mostly for debugging during
	        // development so it's probably okay
	        // http://stackoverflow.com/questions/2027849/how-to-trigger-script-onerror-in-internet-explorer
	        Khan.error("Error loading script " + script.src);
	    };

	    script.onload = script.onreadystatechange = function() {
	        if (!script.readyState ||
	                (/loaded|complete/).test(script.readyState)) {
	            debugLog("loadScript loaded " + url);

	            // Handle memory leak in IE
	            script.onload = script.onreadystatechange = null;

	            // Remove the script
	            if (script.parentNode) {
	                script.parentNode.removeChild(script);
	            }

	            // Dereference the script
	            script = undefined;

	            callback();
	        }
	    };

	    head.appendChild(script);
	}

	function loadMathJax() {
	    var deferred = $.Deferred();

	    // We don't want to finish until MathJax is done loading all of its
	    // dependencies.

	    if (window.MathJax) {
	        waitForMathJaxReady();
	    } else {
	        loadScript(urlBase + "third_party/MathJax/2.1/MathJax.js?config=KAthJax-8f02f65cba7722b3e529bd9dfa6ac25d", waitForMathJaxReady);
	    }

	    function waitForMathJaxReady() {
	        MathJax.Hub.Queue(deferred.resolve);
	    }

	    return deferred.promise();
	}

	function loadLocalModeSite() {
	    // TODO(alpert): Is the DOM really not yet ready?
	    $(function() {
	        // Inject the site markup
	        if (localMode) {
	            $.get(urlBase + "exercises/khan-site.html", function(site) {
	                $.get(urlBase + "exercises/khan-exercise.html",
	                    function(ex) {
	                        injectLocalModeSite(site, ex);
	                    });
	            });
	        }
	    });
	}

	function injectLocalModeSite(html, htmlExercise) {
	    $("body").prepend(html);
	    $("#container .exercises-header h2").append(document.title);
	    $("#container .exercises-body .current-card-contents").html(
	            htmlExercise);

	    if (Khan.query.layout === "lite") {
	        $("html").addClass("lite");
	    }

	    $(Exercises).trigger("problemTemplateRendered");

	    exercises = exercises.add($("div.exercise").detach());
	    var problems = exercises.children(".problems").children();

	    // Generate the initial problem when dependencies are done being loaded
	    makeProblem(currentExerciseId);
	}

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var MAXERROR_EPSILON = Math.pow(2, -42);

	// Function used to get the text of the choices, which is then used
	// to check against the correct answer
	var extractRawCode = function(elem) {
	    var $elem = $(elem).clone(true);
	    var code = $elem.find("code");
	    if (code.length) {
	        // If there are <code> tags in the element, remove them and replace
	        // them with their original formulas
	        $.each(code, function(i, elem) {
	            $(elem).replaceWith(
	                // TODO(emily): Adding <code> and <script> tags around this is
	                // a horrible hack to make this code backwards-compatible with
	                // the old extractRawCode (so that timeline works, etc). Remove
	                // this at some point and make it just return the formula, not
	                // the wrapping.
	                '<code><script type="math/tex">' +
	                KhanUtil.retrieveMathFormula(elem) +
	                '</script></code>'
	            );
	        });
	    }
	    return $elem.html();
	};

	function getTextSquish(elem) {
	    return $(elem).text().replace(/\s+/g, "");
	}

	// TODO(alpert): Don't duplicate from khan-exercise.js
	function checkIfAnswerEmpty(guess) {
	    // If multiple-answer, join all responses and check if that's empty
	    // Remove commas left by joining nested arrays in case multiple-answer is
	    // nested
	    return $.trim(guess) === "" || (guess instanceof Array &&
	             $.trim(guess.join("").replace(/,/g, "")) === "");
	}

	/*
	 * Answer types
	 *
	 * Utility for creating answerable questions displayed in exercises
	 *
	 * Different answer types produce different kinds of input displays, and do
	 * different kinds of checking on the solutions.
	 *
	 * Each of the objects contain two functions, setup and createValidator.
	 *
	 * The setup function takes a solutionarea and solution, and performs setup
	 * within the solutionarea, and then returns an object which contains:
	 *
	 * answer: a function which, when called, will retrieve the current answer from
	 *         the solutionarea, which can then be validated using the validator
	 *         function
	 * validator: a function returned from the createValidator function (defined
	 *            below)
	 * solution: the correct answer to the problem
	 * examples: a list of example formats to be shown in the "acceptable formats"
	 *           popup
	 * showGuess: a function which, when given a guess, shows the guess within the
	 *            provided solutionarea
	 * showGuessCustom: a function which displays parts of a guess that are not
	 *                  within the solutionarea; currently only used for custom
	 *                  answers
	 *
	 * The createValidator function only takes a solution, and it returns a
	 * function which can be used to validate an answer.
	 *
	 * The resulting validator function returns:
	 * - true: if the answer is fully correct
	 * - false: if the answer is incorrect
	 * - "" (the empty string): if no answer has been provided (e.g. the answer box
	 *   is left unfilled)
	 * - a string: if there is some slight error
	 *
	 * In most cases, setup and createValidator don't really need the solution DOM
	 * element so we have setupFunctional and createValidatorFunctional for them
	 * which take only $solution.text() and $solution.data(). This makes it easier
	 * to reuse specific answer types.
	 *
	 * TODO(alpert): Think of a less-absurd name for createValidatorFunctional.
	 *
	 */

	Khan.answerTypes = $.extend(Khan.answerTypes, {
	    /*
	     * text answer type
	     *
	     * Displays a simple text box, and performs direct string matching on the
	     * value typed in an the answer provided
	     */
	    text: {
	        setupFunctional: function(solutionarea, solutionText, solutionData) {
	            // Add a text box
	            var input;
	            if (window.Modernizr && Modernizr.touchevents) {
	                // special flag for iOS devices
	                input = $('<input type="text" autocapitalize="off">');
	            } else {
	                input = $('<input type="text">');
	            }
	            $(solutionarea).append(input);

	            return {
	                validator: Khan.answerTypes.text.createValidatorFunctional(
	                        solutionText, solutionData),
	                answer: function() {
	                    return input.val();
	                },
	                solution: $.trim(solutionText),
	                examples: [],
	                showGuess: function(guess) {
	                    input.val(guess === undefined ? "" : guess);
	                }
	            };
	        },
	        createValidatorFunctional: function(correct, options) {
	            options = $.extend({
	                correctCase: "required"
	            }, options);

	            correct = $.trim(correct);

	            return function(guess) {
	                // The fallback variable is used in place of the answer, if no
	                // answer is provided (i.e. the field is left blank)
	                var fallback =
	                    options.fallback != null ? "" + options.fallback : "";

	                guess = $.trim(guess) || fallback;
	                var score = {
	                    empty: false,
	                    correct: false,
	                    message: null,
	                    guess: guess
	                };
	                if (guess.toLowerCase() === correct.toLowerCase()) {
	                    if (correct === guess || options.correctCase === "optional") {
	                        score.correct = true;
	                    } else {
	                        if (guess === guess.toLowerCase()) {
	                            score.message = $._("Your answer is almost correct, but " +
	                                       "must be in capital letters.");
	                        } else if (guess === guess.toUpperCase()) {
	                            score.message = $._("Your answer is almost correct, but " +
	                                       "must not be in capital letters.");
	                        } else {
	                            score.message = $._("Your answer is almost correct, but " +
	                                       "must be in the correct case.");
	                        }
	                    }
	                }
	                return score;
	            };
	        }
	    },

	    /*
	     * predicate answer type
	     *
	     * performs simple predicate-based checking of a numeric solution, with
	     * different kinds of number formats
	     *
	     * Uses the data-forms option on the solution to choose which number formats
	     * are acceptable. Available data-forms:
	     *
	     * - integer:  3
	     * - proper:   3/5
	     * - improper: 5/3
	     * - pi:       3 pi
	     * - log:      log(5)
	     * - percent:  15%
	     * - mixed:    1 1/3
	     * - decimal:  1.7
	     *
	     * The solution should be a predicate of the form:
	     *
	     * function(guess, maxError) {
	     *     return abs(guess - 3) < maxError;
	     * }
	     *
	     */
	    predicate: {
	        defaultForms: "integer, proper, improper, mixed, decimal",
	        setupFunctional: function(solutionarea, solutionText, solutionData) {
	            // retrieve the options from the solution data
	            var options = $.extend({
	                simplify: "required",
	                ratio: false,
	                forms: Khan.answerTypes.predicate.defaultForms
	            }, solutionData);
	            var acceptableForms = options.forms.split(/\s*,\s*/);

	            // TODO(jack): remove options.inexact in favor of options.maxError
	            if (options.inexact === undefined) {
	                // If we aren't allowing inexact, ensure that we don't have a
	                // large maxError as well.
	                options.maxError = 0;
	            }
	            // Allow a small tolerance on maxError, to avoid numerical
	            // representation issues (2.3 should be correct for a solution of
	            // 2.45 with maxError=0.15).
	            options.maxError = +options.maxError + MAXERROR_EPSILON;

	            var input = $('<input type="text" autocapitalize="off">');
	            $(solutionarea).append(input);

	            // retrieve the example texts from the different forms
	            var exampleForms = {
	                integer: $._("an integer, like <code>6</code>"),

	                proper: (function() {
	                        if (options.simplify === "optional") {
	                            return $._("a <em>proper</em> fraction, like " +
	                                       "<code>1/2</code> or <code>6/10</code>");
	                        } else {
	                            return $._("a <em>simplified proper</em> " +
	                                       "fraction, like <code>3/5</code>");
	                        }
	                    })(),

	                improper: (function() {
	                        if (options.simplify === "optional") {
	                            return $._("an <em>improper</em> fraction, like " +
	                                       "<code>10/7</code> or <code>14/8</code>");
	                        } else {
	                            return $._("a <em>simplified improper</em> " +
	                                       "fraction, like <code>7/4</code>");
	                        }
	                    })(),

	                pi: $._("a multiple of pi, like <code>12\\ \\text{pi}</code> " +
	                    "or <code>2/3\\ \\text{pi}</code>"),

	                log: $._("an expression, like <code>\\log(100)</code>"),

	                percent: $._("a percent, like <code>%(NUM)s\\%</code>", {NUM: KhanUtil.localeToFixed(12.34, 2)}),

	                mixed: $._("a mixed number, like <code>1\\ 3/4</code>"),

	                decimal: (function() {
	                        if (options.inexact === undefined) {
	                            return $._("an <em>exact</em> decimal, like " +
	                                "<code>%(NUM)s</code>", {NUM: KhanUtil.localeToFixed(0.75, 2)});
	                        } else {
	                            return $._("a decimal, like <code>%(NUM)s</code>", {NUM: KhanUtil.localeToFixed(0.75, 2)});
	                        }
	                    })()
	            };

	            // extract the examples for the given forms
	            var examples = [];
	            $.each(acceptableForms, function(i, form) {
	                if (exampleForms[form] != null) {
	                    examples.push(exampleForms[form]);
	                }
	            });

	            return {
	                validator: Khan.answerTypes.predicate.createValidatorFunctional(
	                        solutionText, solutionData),
	                answer: function() {
	                    return input.val();
	                },
	                solution: $.trim(solutionText),
	                examples: examples,
	                showGuess: function(guess) {
	                    input.val(guess === undefined ? "" : guess);
	                }
	            };
	        },
	        createValidatorFunctional: function(predicate, options) {
	            // Extract the options from the given solution object
	            options = $.extend({
	                simplify: "required",
	                ratio: false,
	                forms: Khan.answerTypes.predicate.defaultForms
	            }, options);
	            var acceptableForms;
	            // this is maintaining backwards compatibility
	            // TODO(merlob) fix all places that depend on this, then delete
	            if (!_.isArray(options.forms)) {
	                acceptableForms = options.forms.split(/\s*,\s*/);
	            } else {
	                acceptableForms = options.forms;
	            }

	            // TODO(jack): remove options.inexact in favor of options.maxError
	            if (options.inexact === undefined) {
	                // If we aren't allowing inexact, ensure that we don't have a
	                // large maxError as well.
	                options.maxError = 0;
	            }
	            // Allow a small tolerance on maxError, to avoid numerical
	            // representation issues (2.3 should be correct for a solution of
	            // 2.45 with maxError=0.15).
	            options.maxError = +options.maxError + MAXERROR_EPSILON;

	            // If percent is an acceptable form, make sure it's the last one
	            // in the list so we don't prematurely complain about not having
	            // a percent sign when the user entered the correct answer in a
	            // different form (such as a decimal or fraction)
	            if (_.contains(acceptableForms, "percent")) {
	                acceptableForms = _.without(acceptableForms, "percent");
	                acceptableForms.push("percent");
	            }

	            predicate = _.isFunction(predicate) ?
	                    predicate :
	                    KhanUtil.tmpl.getVAR(predicate);

	            // Take text looking like a fraction, and turn it into a number
	            var fractionTransformer = function(text) {
	                text = text
	                    // Replace unicode minus sign with hyphen
	                    .replace(/\u2212/, "-")

	                    // Remove space after +, -
	                    .replace(/([+-])\s+/g, "$1")

	                    // Remove leading/trailing whitespace
	                    .replace(/(^\s*)|(\s*$)/gi, "");

	                    // Extract numerator and denominator
	                var match = text.match(/^([+-]?\d+)\s*\/\s*([+-]?\d+)$/);
	                var parsedInt = parseInt(text, 10);
	                if (match) {
	                    var num = parseFloat(match[1]),
	                        denom = parseFloat(match[2]);
	                    var simplified = denom > 0 &&
	                        (options.ratio || match[2] !== "1") &&
	                        KhanUtil.getGCD(num, denom) === 1;
	                    return [{
	                        value: num / denom,
	                        exact: simplified
	                    }];
	                } else if (!isNaN(parsedInt) && "" + parsedInt === text) {
	                    return [{
	                        value: parsedInt,
	                        exact: true
	                    }];
	                }

	                return [];
	            };

	            /*
	             * Different forms of numbers
	             *
	             * Each function returns a list of objects of the form:
	             *
	             * {
	             *    value: numerical value,
	             *    exact: true/false
	             * }
	             */
	            var forms = {
	                // integer, which is encompassed by decimal
	                integer: function(text) {
	                    // Compare the decimal form to the decimal form rounded to
	                    // an integer. Only accept if the user actually entered an
	                    // integer.
	                    var decimal = forms.decimal(text);
	                    var rounded = forms.decimal(text, 1);
	                    if ((decimal[0].value != null &&
	                            decimal[0].value === rounded[0].value) ||
	                            (decimal[1].value != null &&
	                            decimal[1].value === rounded[1].value)) {
	                        return decimal;
	                    }
	                    return [];
	                },

	                // A proper fraction
	                proper: function(text) {
	                    return $.map(fractionTransformer(text), function(o) {
	                        // All fractions that are less than 1
	                        if (Math.abs(o.value) < 1) {
	                            return [o];
	                        } else {
	                            return [];
	                        }
	                    });
	                },

	                // an improper fraction
	                improper: function(text) {
	                    return $.map(fractionTransformer(text), function(o) {
	                        // All fractions that are greater than 1
	                        if (Math.abs(o.value) >= 1) {
	                            return [o];
	                        } else {
	                            return [];
	                        }
	                    });
	                },

	                // pi-like numbers
	                pi: function(text) {
	                    var match, possibilities = [];

	                    // Replace unicode minus sign with hyphen
	                    text = text.replace(/\u2212/, "-");

	                    // - pi
	                    // (Note: we also support \pi (for TeX), p, tau (and \tau,
	                    // and t), pau.)
	                    if ((match = text.match(
	                                    /^([+-]?)\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i
	                                ))) {
	                        possibilities = [{ value: parseFloat(match[1] + "1"), exact: true }];

	                    // 5 / 6 pi
	                    } else if ((match = text.match(/^([+-]?\s*\d+\s*(?:\/\s*[+-]?\s*\d+)?)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i))) {
	                        possibilities = fractionTransformer(match[1]);

	                    // 4 5 / 6 pi
	                    } else if ((match = text.match(/^([+-]?)\s*(\d+)\s*([+-]?\d+)\s*\/\s*([+-]?\d+)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i))) {
	                        var sign = parseFloat(match[1] + "1"),
	                            integ = parseFloat(match[2]),
	                            num = parseFloat(match[3]),
	                            denom = parseFloat(match[4]);
	                        var simplified = num < denom &&
	                            KhanUtil.getGCD(num, denom) === 1;

	                        possibilities = [{
	                            value: sign * (integ + num / denom),
	                            exact: simplified
	                        }];

	                    // 5 pi / 6
	                    } else if ((match = text.match(/^([+-]?\s*\d+)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)\s*(?:\/\s*([+-]?\s*\d+))?$/i))) {
	                        possibilities = fractionTransformer(match[1] +
	                                                            "/" + match[3]);

	                    // - pi / 4
	                    } else if ((match = text.match(/^([+-]?)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)\s*(?:\/\s*([+-]?\d+))?$/i))) {
	                        possibilities = fractionTransformer(match[1] +
	                                                            "1/" + match[3]);

	                    // 0
	                    } else if (text === "0") {
	                        possibilities = [{ value: 0, exact: true }];

	                    // 0.5 pi (fallback)
	                    } else if ((match = text.match(
	                                /^(.+)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i
	                                        ))) {
	                        possibilities = forms.decimal(match[1]);
	                    } else {
	                        possibilities = _.reduce(Khan.answerTypes.predicate.defaultForms.split(/\s*,\s*/), function(memo, form) {
	                            return memo.concat(forms[form](text));
	                        }, []);
	                        $.each(possibilities, function(ix, possibility) {
	                            possibility.piApprox = true;
	                        });
	                        return possibilities;
	                    }

	                    var multiplier = Math.PI;
	                    if (text.match(/\\?tau|t|\u03c4/)) {
	                        multiplier = Math.PI * 2;
	                    }

	                    // We're taking an early stand along side xkcd in the
	                    // inevitable ti vs. pau debate... http://xkcd.com/1292
	                    if (text.match(/pau/)) {
	                        multiplier = Math.PI * 1.5;
	                    }

	                    $.each(possibilities, function(ix, possibility) {
	                        possibility.value *= multiplier;
	                    });
	                    return possibilities;
	                },

	                // Converts '' to 1 and '-' to -1 so you can write "[___] x"
	                // and accept sane things
	                coefficient: function(text) {
	                    var possibilities = [];

	                    // Replace unicode minus sign with hyphen
	                    text = text.replace(/\u2212/, "-");

	                    if (text === "") {
	                        possibilities = [{ value: 1, exact: true }];
	                    } else if (text === "-") {
	                        possibilities = [{ value: -1, exact: true }];
	                    }
	                    return possibilities;
	                },

	                // simple log(c) form
	                log: function(text) {
	                    var match, possibilities = [];

	                    // Replace unicode minus sign with hyphen
	                    text = text.replace(/\u2212/, "-");
	                    text = text.replace(/[ \(\)]/g, "");

	                    if ((match = text.match(/^log\s*(\S+)\s*$/i))) {
	                        possibilities = forms.decimal(match[1]);
	                    } else if (text === "0") {
	                        possibilities = [{ value: 0, exact: true }];
	                    }
	                    return possibilities;
	                },

	                // Numbers with percent signs
	                percent: function(text) {
	                    text = $.trim(text);
	                    // store whether or not there is a percent sign
	                    var hasPercentSign = false;

	                    if (text.indexOf("%") === (text.length - 1)) {
	                        text = $.trim(text.substring(0, text.length - 1));
	                        hasPercentSign = true;
	                    }

	                    var transformed = forms.decimal(text);
	                    $.each(transformed, function(ix, t) {
	                        t.exact = hasPercentSign;
	                        t.value = t.value / 100;
	                    });
	                    return transformed;
	                },

	                // Mixed numbers, like 1 3/4
	                mixed: function(text) {
	                    var match = text
	                        // Replace unicode minus sign with hyphen
	                        .replace(/\u2212/, "-")

	                        // Remove space after +, -
	                        .replace(/([+-])\s+/g, "$1")

	                        // Extract integer, numerator and denominator
	                        .match(/^([+-]?)(\d+)\s+(\d+)\s*\/\s*(\d+)$/);

	                    if (match) {
	                        var sign = parseFloat(match[1] + "1"),
	                            integ = parseFloat(match[2]),
	                            num = parseFloat(match[3]),
	                            denom = parseFloat(match[4]);
	                        var simplified = num < denom &&
	                            KhanUtil.getGCD(num, denom) === 1;

	                        return [{
	                            value: sign * (integ + num / denom),
	                            exact: simplified
	                        }];
	                    }

	                    return [];
	                },

	                // Decimal numbers -- compare entered text rounded to
	                // 'precision' Reciprical of the precision against the correct
	                // answer. We round to 1/1e10 by default, which is healthily
	                // less than machine epsilon but should be more than any real
	                // decimal answer would use. (The 'integer' answer type uses
	                // precision == 1.)
	                decimal: function(text, precision) {
	                    if (precision == null) {
	                        precision = 1e10;
	                    }

	                    var normal = function(text) {
	                        text = $.trim(text);

	                        var match = text
	                            // Replace unicode minus sign with hyphen
	                            .replace(/\u2212/, "-")
	                            // Remove space after +, -
	                            .replace(/([+-])\s+/g, "$1")
	                            // Extract integer, numerator and denominator. If
	                            // commas or spaces are used, they must be in the
	                            // "correct" places
	                            .match(/^([+-]?(?:\d{1,3}(?:[, ]?\d{3})*\.?|\d{0,3}(?:[, ]?\d{3})*\.(?:\d{3}[, ]?)*\d{1,3}))$/);

	                        // You can't start a number with `0,`, to prevent us
	                        // interpeting '0.342' as correct for '342'
	                        var badLeadingZero = text.match(/^0[0,]*,/);

	                        if (match && !badLeadingZero) {
	                            var x = parseFloat(match[1].replace(/[, ]/g, ""));

	                            if (options.inexact === undefined) {
	                                x = Math.round(x * precision) / precision;
	                            }

	                            return x;
	                        }
	                    };

	                    var commas = function(text) {
	                        text = text.replace(/([\.,])/g, function(_, c) {
	                            return (c === "." ? "," : ".");
	                        });
	                        return normal(text);
	                    };

	                    return [
	                        { value: normal(text), exact: true },
	                        { value: commas(text), exact: true }
	                    ];
	                }
	            };

	            // validator function
	            return function(guess) {
	                // The fallback variable is used in place of the answer, if no
	                // answer is provided (i.e. the field is left blank)
	                var fallback =
	                    options.fallback != null ? "" + options.fallback : "";

	                guess = $.trim(guess) || fallback;
	                var score = {
	                    empty: guess === "",
	                    correct: false,
	                    message: null,
	                    guess: guess
	                };

	                // iterate over all the acceptable forms, and if one of the
	                // answers is correct, return true
	                $.each(acceptableForms, function(i, form) {
	                    var transformed = forms[form](guess);

	                    for (var j = 0, l = transformed.length; j < l; j++) {
	                        var val = transformed[j].value;
	                        var exact = transformed[j].exact;
	                        var piApprox = transformed[j].piApprox;
	                        // If a string was returned, and it exactly matches,
	                        // return true
	                        if (predicate(val, options.maxError)) {
	                            // If the exact correct number was returned,
	                            // return true
	                            if (exact || options.simplify === "optional") {
	                                score.correct = true;
	                                score.message = options.message || null;
	                                // If the answer is correct, don't say it's
	                                // empty. This happens, for example, with the
	                                // coefficient type where guess === "" but is
	                                // interpreted as "1" which is correct.
	                                score.empty = false;
	                            } else if (form === "percent") {
	                                // Otherwise, an error was returned
	                                score.empty = true;
	                                score.message = $._("Your answer is almost correct, " +
	                                          "but it is missing a " +
	                                          "<code>\\%</code> at the end.");
	                            } else {
	                                if (options.simplify !== "enforced") {
	                                    score.empty = true;
	                                }
	                                score.message = $._("Your answer is almost correct, " +
	                                          "but it needs to be simplified.");
	                            }

	                            return false; // break;
	                        } else if (piApprox &&
	                                   predicate(val, Math.abs(val * 0.001))) {
	                            score.empty = true;
	                            score.message = $._("Your answer is close, but you may " +
	                                      "have approximated pi. Enter your " +
	                                      "answer as a multiple of pi, like " +
	                                      "<code>12\\ \\text{pi}</code> or " +
	                                      "<code>2/3\\ \\text{pi}</code>");
	                        }
	                    }
	                });

	                if (score.correct === false) {
	                    var interpretedGuess = false;
	                    _.each(forms, function(form) {
	                        if(_.any(form(guess), function(t) {
	                                return t.value != null && !_.isNaN(t.value);})) {
	                            interpretedGuess = true;
	                        }
	                    });
	                    if (!interpretedGuess) {
	                        score.empty = true;
	                        score.message = $._("We could not understand your answer. " +
	                            "Please check your answer for extra text or symbols.");
	                        return score;
	                    }
	                }

	                return score;
	            };
	        }
	    },

	    /*
	     * number answer type
	     *
	     * wraps the predicate answer type to performs simple number-based checking
	     * of a solution
	     */
	    number: {
	        convertToPredicate: function(correct, options) {
	            // TODO(alpert): Don't think this $.trim is necessary
	            var correctFloat = parseFloat($.trim(correct));

	            return [
	                    function(guess, maxError) {
	                        return Math.abs(guess - correctFloat) < maxError;
	                    },
	                    $.extend({}, options, {type: "predicate"})
	                ];
	        },
	        setupFunctional: function(solutionarea, solutionText, solutionData) {
	            var args = Khan.answerTypes.number.convertToPredicate(
	                    solutionText, solutionData);
	            return Khan.answerTypes.predicate.setupFunctional(
	                    solutionarea,
	                    /* text: */ args[0], /* data: */ args[1]);
	        },
	        createValidatorFunctional: function(correct, options) {
	            return Khan.answerTypes.predicate.createValidatorFunctional.apply(
	                Khan.answerTypes.predicate,
	                Khan.answerTypes.number.convertToPredicate(correct, options));
	        }
	    },

	    /*
	     * These next four answer types are just synonyms for number with given
	     * forms. Set the correct forms on the solution, and pass it on to number
	     */
	    decimal: numberAnswerType("decimal"),

	    rational: numberAnswerType("integer, proper, improper, mixed"),

	    // A little bit of a misnomer as proper fractions are also accepted
	    improper: numberAnswerType("integer, proper, improper"),

	    mixed: numberAnswerType("integer, proper, mixed"),

	    // Perform a regex match on the entered string
	    regex: {
	        setupFunctional: function(solutionarea, solutionText, solutionData) {
	            var input;
	            if (window.Modernizr && Modernizr.touchevents) {
	                // special flag for iOS devices
	                input = $('<input type="text" autocapitalize="off">');
	            } else {
	                input = $('<input type="text">');
	            }
	            $(solutionarea).append(input);

	            return {
	                validator: Khan.answerTypes.regex.createValidatorFunctional(
	                        solutionText, solutionData),
	                answer: function() {
	                   return input.val();
	                },
	                solution: $.trim(solutionText),
	                examples: [],
	                showGuess: function(guess) {
	                    input.val(guess === undefined ? "" : guess);
	                }
	            };
	        },
	        createValidatorFunctional: function(regex, options) {
	            var flags = "";

	            if (options.caseInsensitive != null) {
	                flags += "i";
	            }

	            regex = new RegExp($.trim(regex), flags);

	            return function(guess) {
	                // The fallback variable is used in place of the answer, if no
	                // answer is provided (i.e. the field is left blank)
	                var fallback =
	                    options.fallback != null ? "" + options.fallback : "";

	                guess = $.trim(guess) || fallback;
	                return {
	                    empty: false,
	                    correct: guess.match(regex) != null,
	                    message: null,
	                    guess: guess
	                };
	            };
	        }
	    },

	    // An answer type with two text boxes, for solutions of the form a sqrt(b)
	    radical: {
	        setupFunctional: function(solutionarea, solutionText, solutionData) {
	            var options = $.extend({
	                simplify: "required"
	            }, solutionData);

	            // Add two input boxes
	            var inte = $('<input type="text" autocapitalize="off">');
	            var rad = $('<input type="text" autocapitalize="off">');

	            // Make them look pretty
	            $("<div class='radical'>")
	                .append($("<span>").append(inte))
	                .append('<span class="surd">&radic;</span>')
	                .append($("<span>").append(rad).addClass("overline"))
	                .appendTo(solutionarea);

	            var ansSquared = parseFloat(solutionText);
	            var ans = KhanUtil.splitRadical(ansSquared);

	            return {
	                validator: Khan.answerTypes.radical.createValidatorFunctional(
	                        solutionText, solutionData),
	                answer: function() {
	                    return [$.trim(inte.val()), $.trim(rad.val())];
	                },
	                solution: ans,
	                examples: (options.simplify === "required") ?
	                    [$._("a simplified radical, like <code>\\sqrt{2}</code> " +
	                         "or <code>3\\sqrt{5}</code>")] :
	                    [$._("a radical, like <code>\\sqrt{8}</code> or " +
	                         "<code>2\\sqrt{2}</code>")],
	                showGuess: function(guess) {
	                    inte.val(guess ? guess[0] : "");
	                    rad.val(guess ? guess[1] : "");
	                }
	            };
	        },
	        createValidatorFunctional: function(ansSquared, options) {
	            options = $.extend({
	                simplify: "required"
	            }, options);

	            // The provided answer is the square of what is meant to be
	            // entered. Use KhanUtil.splitRadical to find the different parts
	            ansSquared = parseFloat(ansSquared);
	            var ans = KhanUtil.splitRadical(ansSquared);

	            return function(guess) {
	                // If nothing typed into either box, don't grade the answer
	                if (guess[0].length === 0 && guess[1].length === 0) {
	                    return {
	                        empty: true,
	                        correct: false,
	                        message: null,
	                        guess: guess
	                    };
	                }
	                // If nothing is typed into one of the boxes, use 1
	                guess[0] = guess[0].length > 0 ? guess[0] : "1";
	                guess[1] = guess[1].length > 0 ? guess[1] : "1";
	                // Parse the two floats from the guess
	                var inteGuess = parseFloat(guess[0]);
	                var radGuess = parseFloat(guess[1]);

	                // The answer is correct if the guess square is equal to the
	                // given solution
	                var correct =
	                    Math.abs(inteGuess) * inteGuess * radGuess === ansSquared;
	                // the answer is simplified if the sqrt portion and integer
	                // portion are the same as what is given by splitRadical
	                var simplified = inteGuess === ans[0] && radGuess === ans[1];

	                var score = {
	                    empty: false,
	                    correct: false,
	                    message: null,
	                    guess: guess
	                };

	                if (correct) {
	                    if (simplified || options.simplify === "optional") {
	                        score.correct = true;
	                    } else {
	                        score.message = $._("Your answer is almost correct, but it " +
	                                   "needs to be simplified.");
	                    }
	                }
	                return score;
	            };
	        }
	    },

	    // An answer type with two text boxes, for solutions of the form a cuberoot(b)
	    cuberoot: {
	        setupFunctional: function(solutionarea, solutionText, solutionData) {
	            var options = $.extend({
	                simplify: "required"
	            }, solutionData);

	            // Add two input boxes
	            var inte = $('<input type="text" autocapitalize="off">');
	            var rad = $('<input type="text" autocapitalize="off">');

	            // Make them look pretty
	            $("<div class='radical'>")
	                .append($("<span>").append(inte))
	                .append('<span class="surd" style="vertical-align: 6px;"><code>\\sqrt[3]{}</code></span>')
	                .append($("<span>").append(rad).addClass("overline"))
	                .appendTo(solutionarea).tex();

	            var ansCubed = parseFloat(solutionText);
	            var ans = KhanUtil.splitCube(ansCubed);

	            return {
	                validator: Khan.answerTypes.cuberoot.createValidatorFunctional(
	                        solutionText, solutionData),
	                answer: function() {
	                    return [inte.val(), rad.val()];
	                },
	                solution: ans,
	                examples: (options.simplify === "required") ?
	                    [$._("a simplified radical, like <code>\\sqrt[3]{2}</code> " +
	                         "or <code>3\\sqrt[3]{5}</code>")] :
	                    [$._("a radical, like <code>\\sqrt[3]{8}</code> or " +
	                         "<code>2\\sqrt[3]{2}</code>")],
	                showGuess: function(guess) {
	                    inte.val(guess ? guess[0] : "");
	                    rad.val(guess ? guess[1] : "");
	                }
	            };
	        },
	        createValidatorFunctional: function(ansCubed, options) {
	            options = $.extend({
	                simplify: "required"
	            }, options);

	            // The provided answer is the cube of what is meant to be
	            // entered. Use KhanUtil.splitCube to find the different parts
	            ansCubed = parseFloat(ansCubed);
	            var ans = KhanUtil.splitCube(ansCubed);

	            return function(guess) {
	                // If nothing typed into either box, don't grade the answer
	                if (guess[0].length === 0 && guess[1].length === 0) {
	                    return {
	                        empty: true,
	                        correct: false,
	                        message: null,
	                        guess: guess
	                    };
	                }
	                // If nothing is typed into one of the boxes, use 1
	                guess[0] = guess[0].length > 0 ? guess[0] : "1";
	                guess[1] = guess[1].length > 0 ? guess[1] : "1";
	                // Parse the two floats from the guess
	                var inteGuess = parseFloat(guess[0]);
	                var radGuess = parseFloat(guess[1]);

	                // The answer is correct if the guess square is equal to the
	                // given solution
	                var correct =
	                    Math.abs(inteGuess) * inteGuess * inteGuess * radGuess === ansCubed;
	                // the answer is simplified if the sqrt portion and integer
	                // portion are the same as what is given by splitCube
	                var simplified = inteGuess === ans[0] && radGuess === ans[1];

	                var score = {
	                    empty: false,
	                    correct: false,
	                    message: null,
	                    guess: guess
	                };

	                if (correct) {
	                    if (simplified || options.simplify === "optional") {
	                        score.correct = true;
	                    } else {
	                        score.message = $._("Your answer is almost correct, but it " +
	                                   "needs to be simplified.");
	                    }
	                }
	                return score;
	            };
	        }
	    },

	    /*
	     * Multiple answer type
	     *
	     * This answer type allows for multiple different other answer types to be
	     * combined into a single answer.
	     *
	     * It works by finding html elements with the "sol" class, and converting
	     * them into mini solutionareas, which are then filled in by the setup
	     * functions of their cooresponding answer types. In order to do solution
	     * checking, the answers of each of the areas are placed in an array, and
	     * then the validator works by iterating over the array and making sure
	     * each of the individual solutions are correct
	     */
	    multiple: {
	        setup: function(solutionarea, solution) {
	            // Very quickly place all of the elements in the solution area
	            // Clone it, because we don't want to modify or move it
	            $(solutionarea).append(
	                    $(solution).clone(true).texCleanup().contents()
	                        .runModules()
	            );

	            var answerDataArray = [];

	            // Iterate over each of the .sol elements
	            $(solutionarea).find(".sol").each(function(idx) {
	                var type = $(this).data("type");
	                type = type != null ? type : "number";

	                // find the corresponding answer
	                var sol = $(solution).find(".sol").eq(idx);

	                // empty the .sol element in preperation for treating it as a
	                // solutionarea
	                var solarea = $(this).empty();

	                // perform setup on each of the areas
	                var answerData = Khan.answerTypes[type].setup(solarea, sol);

	                // Store the returned data, for use later
	                answerDataArray.push(answerData);
	            });

	            // Remove the examples from the solutionarea
	            $(solutionarea).find(".example").remove();

	            return {
	                validator: Khan.answerTypes.multiple.createValidator(solution),
	                answer: function() {
	                    var answer = [];

	                    // Go through each of the answerDatas, and call the answer
	                    // functions in turn, storing each of the answers in an
	                    // array
	                    $.each(answerDataArray, function(i, answerData) {
	                        answer.push(answerData.answer());
	                    });

	                    return answer;
	                },
	                solution: (function() {
	                    // Retrieve each of the solutions from the answerDatas
	                    $.map(answerDataArray, function(answerData) {
	                        return answerData.solution;
	                    });
	                })(),
	                // Find all the example classes from the solution, and store
	                // those
	                examples: (function() {
	                    var ex = solution.find(".example").texCleanup()
	                                     .map(function(i, el) {
	                        return $(el).html();
	                    });
	                    if (ex.length === 0 && answerDataArray.length === 1) {
	                        ex = answerDataArray[0].examples;
	                    }
	                    return ex;
	                })(),
	                showGuess: function(guess) {
	                    // Iterate through each of the answerDatas, and show the
	                    // cooresponding guess for each
	                    $.each(answerDataArray, function(i, answerData) {
	                        if (guess !== undefined) {
	                            answerData.showGuess(guess[i]);
	                        } else {
	                            answerData.showGuess();
	                        }
	                    });
	                },
	                showCustomGuess: function(guess) {
	                    // Iterate through each of the answerDatas, and show the
	                    // cooresponding custom guess for each if it exists
	                    $.each(answerDataArray, function(i, answerData) {
	                        if (!_.isFunction(answerData.showCustomGuess)) {
	                            return;
	                        }
	                        if (guess !== undefined) {
	                            answerData.showCustomGuess(guess[i]);
	                        } else {
	                            answerData.showCustomGuess();
	                        }
	                    });
	                }
	            };
	        },
	        createValidator: function(solution) {
	            var validators = [];

	            // Iterate over all of the .sols in the answer
	            $(solution).find(".sol").each(function() {
	                var sol = $(this);

	                var type = sol.data("type");
	                type = type != null ? type : "number";

	                // create a validator for each of the solutions
	                var validator = Khan.answerTypes[type].createValidator(sol);
	                validators.push(validator);
	            });

	            return function(guess) {
	                var score = {
	                    empty: true,
	                    correct: true,
	                    message: null,
	                    guess: guess
	                };
	                var blockGradingMessage = null;

	                // If the answer is completely empty, don't grade it
	                if (checkIfAnswerEmpty(guess)) {
	                    score.empty = true;
	                    score.correct = false;
	                    return score;
	                }

	                // Iterate over each of the elements in the guess
	                $.each(guess, function(i, g) {
	                    // Check whether that answer is right by validating it
	                    // with the corresponding validator
	                    var pass = validators[i](g);

	                    if (pass.message && pass.empty) {
	                        // Special case where a validator returns a message
	                        // for an "empty" response. This probably means it's
	                        // not really empty, but a correct-but-not-simplified
	                        // answer. Rather that treating this as actually empty,
	                        // possibly leading to the entire multiple being marked
	                        // wrong for being incomplete, note the situation but
	                        // continue determining whether the entire answer is
	                        // otherwise correct or not before forwarding on the
	                        // message.
	                        blockGradingMessage = pass.message;
	                    } else {
	                        score.empty = score.empty && pass.empty;
	                        score.correct = score.correct && pass.correct;
	                        // TODO(eater): This just forwards one message
	                        score.message = score.message || pass.message;
	                    }
	                });

	                if (score.correct && blockGradingMessage != null) {
	                    return {
	                        empty: true,
	                        correct: false,
	                        message: blockGradingMessage,
	                        guess: guess
	                    };
	                } else {
	                    score.empty = false;
	                    return score;
	                }
	            };
	        }
	    },

	    /*
	     * The set answer type allows for multiple different answers with the same
	     * kind of input.
	     *
	     * The different correct answers are stored in .set-sol elements, each of
	     * which describes a different correct answer
	     *
	     * the method of input is stored in the .input-format element, with each
	     * .entry element within that describing an answer-type from which input
	     * should be retrieved
	     *
	     * The guess is retrieved as a list of the answers given from each of the
	     * .entry elements within the solution area
	     *
	     * If there are more solutions given than inputs, then all of the inputs
	     * must be filled. If there are more inputs than solutions, then all of the
	     * solutions must be given. Either way, every given solution must be
	     * correct, or the whole thing is wrong.
	     */
	    set: {
	        setup: function(solutionarea, solution) {
	            // Append the input format to the solution area
	            $(solutionarea).append(
	                $(solution).find(".input-format").clone(true).texCleanup()
	                        .contents().runModules()
	            );

	            var inputArray = [];
	            var showGuessArray = [];
	            // For each of the entry elements
	            $(solutionarea).find(".entry").each(function() {
	                var input = $(this), type = $(this).data("type");
	                type = type != null ? type : "number";

	                var sol = input.clone(true),
	                    solarea = input.empty();

	                // Perform setup within that element
	                var validator = Khan.answerTypes[type].setup(solarea, sol);
	                // Store the answer and showGuess functions
	                inputArray.push(validator.answer);
	                showGuessArray.push(validator.showGuess);
	            });

	            var solutionArray = [];

	            // Make fake solutionareas, and store the solutions from each
	            // TODO(emily): fix this horrible hack, by making the solution
	            //              easier to access
	            $(solution).find(".set-sol").clone(true).each(function() {
	                var type = $(this).data("type");
	                type = type != null ? type : "number";

	                var solarea = $("<div>");

	                var validator = Khan.answerTypes[type].setup(solarea, $(this));

	                solutionArray.push(validator.solution);
	            });

	            return {
	                validator: Khan.answerTypes.set.createValidator(solution),
	                answer: function() {
	                    var answer = [];

	                    // For each of the inputs, get the answer and store it in
	                    // the answer array
	                    $.each(inputArray, function(i, getAns) {
	                        answer.push(getAns());
	                    });

	                    return answer;
	                },
	                solution: solution,
	                examples: solution.find(".example").texCleanup()
	                                  .map(function(i, el) {
	                    return $(el).html();
	                }),
	                showGuess: function(guess) {
	                    // For each of the inputs, call the appropriate showGuess
	                    // function
	                    $.each(showGuessArray, function(i, showGuess) {
	                        if (guess === undefined) {
	                            showGuess();
	                        } else {
	                            showGuess(guess[i]);
	                        }
	                    });
	                }
	            };
	        },
	        createValidator: function(solution) {
	            var validatorArray = [];

	            // Fill validatorArray with validators for each acceptable answer
	            $(solution).find(".set-sol").clone(true).each(function() {
	                var type = $(this).data("type");
	                type = type != null ? type : "number";

	                var validator = Khan.answerTypes[type]
	                                    .createValidator($(this));

	                validatorArray.push(validator);
	            });

	            return function(guess) {
	                var score = {
	                    // If there are no validators, empty input is correct
	                    empty: validatorArray.length === 0 ? false : true,
	                    correct: true,
	                    message: null,
	                    guess: guess
	                };
	                var blockGradingMessage = null;

	                // Store a copy of each of the validators. If one correctly
	                // identifies a guess, remove it from this array, so duplicate
	                // answers aren't marked correct twice
	                var unusedValidators = validatorArray.slice(0);

	                // Go through each of the guesses
	                $.each(guess, function(i, g) {
	                    // Whether or not the guess is correct
	                    var correct = false;

	                    // Go through each of the unused validators
	                    $.each(unusedValidators, function(i, validator) {
	                        var pass = validator(g);

	                        // If this validator is trying to block grading
	                        if (pass.empty && pass.message) {
	                            // remove the working validator
	                            unusedValidators.splice(i, 1);
	                            // We want to block the entire answer from being
	                            // accepted as correct but continue checking in
	                            // case another part is wrong.
	                            blockGradingMessage = pass.message;
	                            correct = true;
	                            // break
	                            return false;
	                        }

	                        // If this validator completely accepts this answer
	                        if (pass.correct) {
	                            // store correct
	                            correct = pass.correct;
	                            // remove the matching validator
	                            unusedValidators.splice(i, 1);
	                            // break
	                            return false;
	                        }

	                        // If the validator matches, grades wrong, and provides
	                        // a message, we want to continue trying the other
	                        // validators in the hopes the answer may yet be
	                        // correct. But in case it isn't, store the message.
	                        if (!pass.correct && pass.message) {
	                            correct = pass.message;
	                        }
	                    });

	                    if (!checkIfAnswerEmpty(g) &&
	                            !checkIfAnswerEmpty(correct)) {
	                        score.empty = false;
	                    }

	                    // If we didn't get it right, and the answer isn't empty,
	                    // the entire solution is false
	                    //
	                    // TODO(emily): make the "is the answer empty" part of this
	                    //              work better for all the different answer
	                    //              types
	                    // TODO(emily): Perhaps provide insight to the student
	                    //              about whether or not part of their answer
	                    //              is correct? While this could be abused, it
	                    //              would seem more friendly.
	                    if (!correct && $.trim([g].join("")) !== "") {
	                        score.correct = false;
	                        return false;  // break
	                    }

	                    // If we have a check answer message
	                    if (typeof correct === "string") {
	                        score.message = correct;
	                        score.correct = false;
	                    }
	                });

	                // If there were more correct answers than possible guesses
	                if (validatorArray.length > guess.length) {
	                    // If not all of the guesses were filled in with correct
	                    // answers
	                    if (unusedValidators.length >
	                        validatorArray.length - guess.length) {
	                        // incorrect, more answers needed
	                        score.correct = false;
	                    }
	                // Otherwise, if not all of the answers were provided
	                } else if (unusedValidators.length > 0) {
	                    // incorrect, some of the answers are missing
	                    score.correct = false;
	                }

	                if (score.correct && blockGradingMessage != null) {
	                    return {
	                        empty: true,
	                        correct: false,
	                        message: blockGradingMessage,
	                        guess: guess
	                    };
	                } else {
	                    return score;
	                }
	            };
	        }
	    },

	    /*
	     * The radio answer type provides multiple choice type answers
	     *
	     * The different possible multiple choice answers are provided in a
	     * seperate .choices element siblings with the main .solution element, with
	     * the correct answer residing within the .solution element.
	     *
	     * There are two different modes of operation. Category mode and
	     * non-category mode.
	     *
	     * In non-category mode, the answers (which don't include the correct
	     * answer) combined with the correct answer are scrambled together. This is
	     * meant for questions where the answers radically change from question to
	     * question, and thus scrambling increases the difficulty, and makes the
	     * solutions harder to pattern match. This is the default.
	     *
	     * In category mode, the answers are provided in the order they are given
	     * within the .choices element, and the correct answer is duplicated in
	     * both the solution and within the choices. This is meant for questions
	     * where the solutions generally do not change from problem to problem.
	     * This is enabled by adding data-category to the .choices element.
	     */
	    radio: {
	        setup: function(solutionarea, solution) {
	            // Add a list to the solution area
	            var $list = $("<ul></ul>");
	            $(solutionarea).append($list);

	            // Retrieve the list of choices from the problem
	            var $choices = $(solution).siblings(".choices");

	            // Get the wrong choices and the solution. Note that we cleanup all
	            // the math here, so we don't have to deal with annoying MathJax
	            // stuff in our solutions, and also that we can directly compare
	            // the .text() values of all of the nodes
	            var $choicesClone = $choices.clone(true).texCleanup();
	            var $solutionClone = $(solution).clone(true).texCleanup();

	            // Retrieve the text of the solution so we can store it later
	            var solutionText = $solutionClone.text();

	            // Whether this is a category question, or if we should shuffle the
	            // answers up.
	            var isCategory = !!$choices.data("category");

	            var possibleChoices;
	            if (isCategory) {
	                // If it's a category question, insert the solution into the
	                // list of choices at the correct place, by comparing by the
	                // text value of the elements.
	                var correctText = getTextSquish($solutionClone);
	                possibleChoices = _.map(
	                    $choicesClone.children().get(),
	                    function(elem) {
	                        if (getTextSquish(elem) === correctText) {
	                            return $solutionClone[0];
	                        } else {
	                            return elem;
	                        }
	                    });
	            } else {
	                // Otherwise, the possible choices is just the correct answer
	                // and the other choices. We shuffle the choices here so that
	                // when we slice off some of the choices later, we don't always
	                // slice off the same ones.
	                possibleChoices = $solutionClone.get().concat(
	                    KhanUtil.shuffle($choicesClone.children().get())
	                );
	            }

	            // The number of choices is either the number specified or the
	            // number of choices in the list of possible choices.
	            var numChoices = +$choices.data("show") || possibleChoices.length;

	            // Whether to show a "none of the above" solution in our set of
	            // answers.
	            var showNone = !!$choices.data("none");

	            // This code removes duplicate answers by looking at the text
	            // values of the choices and keeping the non-duplicate answers
	            var shownChoices = _.uniq(possibleChoices, false, function(elem) {
	                return getTextSquish(elem);
	            });

	            // Here, we duplicate the old behaviour where, if there is one less
	            // choice than we want, we will just add in the "none of the above"
	            // choice instead of having it replace one of the real ones.
	            var addNoneChoice = showNone &&
	                    shownChoices.length === numChoices - 1;

	            // If removing duplicates made it so there aren't enough showing
	            // solutions (and we're not going to add in one last choice),
	            // regenerate the problem
	            if (shownChoices.length < numChoices && !addNoneChoice) {
	                return false;
	            // Otherwise, if there are too many choices, throw away some from
	            // the end
	            } else if (shownChoices.length > numChoices) {
	                shownChoices = shownChoices.slice(0, numChoices);
	            }

	            // Shuffle the answers if we're not in category mode
	            if (!isCategory) {
	                shownChoices = KhanUtil.shuffle(shownChoices);
	            }

	            // Find the index of the correct answer
	            var correctIndex;
	            _.each(shownChoices, function(choice, i) {
	                if (choice === $solutionClone[0]) {
	                    correctIndex = i;
	                }
	            });

	            // We figure out if the "none of the above" choice is correct if we
	            // have such an answer and if the last shown answer is correct.
	            // Note that we check against numChoices to decide if it is the
	            // last choice, not shownChoices.length, because in the case that
	            // we're going to be strictly adding the "none of the above"
	            // choice, shownChoices.length won't accurately show the number of
	            // choices that will be shown.
	            var noneIsCorrect = showNone && correctIndex === numChoices - 1;

	            // If showNone, replace the last solution with "None of the above",
	            // which reveals the correct answer when it is picked and is right.
	            if (showNone) {
	                var $none = $("<span>").html($._("None of the above"));
	                $none.data("noneOfTheAbove", true);

	                // If the answer is correct, we add some data about what the
	                // true answer is so we can show it later
	                if (noneIsCorrect) {
	                    $list.data("realAnswer",
	                        $("<span>").addClass("value").append(
	                            $solutionClone.clone(true).contents()
	                        )
	                    );
	                }

	                var noneIndex = shownChoices.length - 1;
	                if (addNoneChoice) {
	                    noneIndex = shownChoices.length;
	                }

	                shownChoices.splice(noneIndex, 1,
	                    // We have to wrap this in something so that when we unwrap
	                    // it below, it maintains its data attributes
	                    $("<span>").append($none));
	            }

	            // Wrap each of the choices in elements and add radio buttons
	            var wrappedChoices = _.map(shownChoices, function(choice, i) {
	                return $("<li><label></label></li>").find("label").append([
	                    $('<input type="radio" name="solution">').val(i),
	                    $('<span class="value"></span>').append(
	                        $(choice).contents()
	                    )
	                ]).end();
	            });

	            // Here we finally re-run modules, so that the math is reformatted
	            $list.append(wrappedChoices).runModules();

	            return {
	                // We send some extra data to the validator so that it is
	                // easier to grade
	                validator: Khan.answerTypes.radio.createValidator({
	                    solution: solution,
	                    index: correctIndex,
	                    noneIsCorrect: noneIsCorrect
	                }),
	                answer: function() {
	                    // Find the chosen answer
	                    var $choice = $list.find("input:checked");

	                    // If nothing's checked, return null immediately
	                    if ($choice.length === 0) {
	                        return null;
	                    }

	                    // Find it's cooresponding value
	                    var $choiceVal = $choice.siblings(".value");

	                    // This (probably) only does something useful when the
	                    // selected answer is the "none of the above" one
	                    var $choiceNoneChild = $choiceVal.children().eq(0);

	                    return {
	                        // Some data about the "none of the above" answer
	                        isNone: $choiceNoneChild.data("noneOfTheAbove"),
	                        // The raw text value that was chosen
	                        // TODO(emily): Remove this at the same time references
	                        // to guess.value are removed down below, maybe (unless
	                        // we want to have the text of the correct answer in
	                        // the database)
	                        value: extractRawCode($choiceVal),
	                        // The index of the value that was chosen
	                        index: +$choice.val()
	                    };
	                },
	                solution: solutionText,
	                examples: [],
	                showGuess: function(guess) {
	                    if (guess == null) {
	                        $(solutionarea).find("input:checked")
	                                       .attr("checked", false);
	                    } else {
	                        // Select the correct radio button
	                        $list.children().filter(function() {
	                            // Filter using the index to choose the radio
	                            return guess.index ===
	                                $(this).find("input").val();
	                        }).find("input").attr("checked", true);
	                    }
	                }
	            };
	        },
	        createValidator: function(solution) {
	            // TODO(emily): Remove this backwards compatible code sometime
	            // after 8/2013
	            var correct = extractRawCode(solution.solution || solution);

	            function showReal() {
	                // Hacky stuff to make the correct solution appear when "none
	                // of the above" is the correct answer
	                var $list = $("#solutionarea").find("ul");
	                var $choice =
	                    $list.children().filter(function() {
	                        return $(this).find("span.value > span")
	                                      .data("noneOfTheAbove");
	                    }).find("input");
	                $choice.next().fadeOut("fast", function() {
	                    var $real = $list.data("realAnswer");
	                    $(this).replaceWith($real);
	                    $real.tex().fadeIn("fast");
	                });
	            }

	            return function(guess) {
	                var score = {
	                    empty: false,
	                    correct: false,
	                    message: null,
	                    guess: guess
	                };

	                if (guess == null) {
	                    score.empty = true;
	                    return score;
	                }

	                if (guess.index) {
	                    // New solutions include information about the correct
	                    // answer like the correct index, etc. We can use that to
	                    // make checking a lot simpler.

	                    if (guess.isNone && solution.noneIsCorrect) {
	                        showReal();
	                        score.correct = true;
	                    } else {
	                        score.correct = guess.index === solution.index;
	                    }
	                } else {
	                    // Old solutions just included the solution element, so we
	                    // have to use the old checks to see if the solution is
	                    // correct
	                    // TODO(emily): Remove this backwards compatible code
	                    // sometime after 8/2013

	                    // Check to see if the "none of the above" answer is
	                    // checked
	                    if (guess.isNone &&
	                            $("#solutionarea").find("ul").data("real-answer") != null) {
	                        showReal();
	                        score.correct = true;
	                    // Otherwise, just compare the text
	                    } else if ($.trim(guess.value).replace(/\r\n?|\n/g, "") ===
	                               $.trim(correct.replace(/\r\n?|\n/g, ""))) {
	                        score.correct = true;
	                    } else {
	                        score.correct = false;
	                    }
	                }
	                return score;
	            };
	        }
	    },

	    /*
	     * The list answer type provides a drop-down menu to select from a list of
	     * different answers
	     *
	     * The different choices are stored as an array in the data-choices value
	     * of the solution element
	     */
	    list: {
	        setupFunctional: function(solutionarea, solutionText, solutionData) {
	            var input = $("<select></select>");
	            $(solutionarea).append(input);

	            // Get the choices
	            var choices = $.tmpl.getVAR(solutionData.choices);
	            $.each(choices, function(index, value) {
	                // Add each one to the selection
	                input.append('<option value="' + value + '">' +
	                    value + "</option>");
	            });

	            return {
	                validator: Khan.answerTypes.list.createValidatorFunctional(
	                        solutionText, solutionData),
	                answer: function() {
	                    return input.val();
	                },
	                solution: $.trim(solutionText),
	                examples: [],
	                showGuess: function(guess) {
	                    input.val(guess === undefined ? "" : guess);
	                }
	            };
	        },
	        createValidatorFunctional: function(correct, options) {
	            correct = $.trim(correct);

	            return function(guess) {
	                guess = $.trim(guess);
	                return {
	                    empty: false,
	                    correct: correct === guess,
	                    message: null,
	                    guess: guess
	                };
	            };
	        }
	    },

	    /*
	     * The custom answer type provides a very general way to create answers,
	     * which generally have input methods beyond the answer area, and have to
	     * do more complex checking for answers
	     *
	     * There are 6 elements within the custom solution that are used.
	     *
	     * The .instruction element is directly copied into the solution area. This
	     * is meant for instructions and any extra input needed by the question
	     *
	     * The .guess element is evaluated as javascript whenever the current
	     * answer needs to be checked. Its result is passed in to the validator,
	     * and show guess functions.
	     *
	     * The .validator element is evaluated as javascript with the added guess
	     * variable. It should return one of the usual return types depending on
	     * whether the answer is correct or not.
	     *
	     * The .show-guess and .show-guess-solutionarea elements are evaluated as
	     * javascript whenever the guess needs to be re-displayed (mostly in the
	     * timeline). The .show-guess function should be used to change elements
	     * outside of the solutionarea, and the .show-guess-solutionarea one should
	     * be used to modify elements within the solutionarea
	     *
	     * The text of the .example elements are used in the acceptable formats
	     * popup
	     */
	    custom: {
	        setup: function(solutionarea, solution) {
	            // copy the instruction element into the solution area
	            solution.find(".instruction")
	                    .appendTo(solutionarea)
	                    .runModules();

	            // Retrieve some code
	            var guessCode = solution.find(".guess").text();
	            var showCustomGuessCode = solution.find(".show-guess").text();
	            var showGuessCode = solution.find(".show-guess-solutionarea").text();

	            return {
	                validator: Khan.answerTypes.custom.createValidator(solution),
	                answer: function() {
	                    // Run the guess code
	                    return KhanUtil.tmpl.getVAR(guessCode,
	                                                KhanUtil.currentGraph);
	                },
	                solution: $.trim($(solution).text()),
	                examples: solution.find(".example").texCleanup()
	                                  .map(function(i, el) {
	                    return $(el).html();
	                }),
	                showCustomGuess: function(guess) {
	                    // run the show guess code
	                    var code =
	                        "(function() { " +
	                            "var guess = " + JSON.stringify(guess) + ";" +
	                            showCustomGuessCode +
	                        "})()";
	                    KhanUtil.tmpl.getVAR(code, KhanUtil.currentGraph);
	                },
	                showGuess: function(guess) {
	                    // run the answer area show guess code
	                    var code =
	                        "(function() { " +
	                            "var guess = " + JSON.stringify(guess) + ";" +
	                            showGuessCode +
	                        "})()";
	                    KhanUtil.tmpl.getVAR(code, KhanUtil.currentGraph);
	                }
	            };
	        },
	        createValidator: function(solution) {
	            // store some code
	            var validatorCode = $(solution).find(".validator-function").text();

	            var validator = function(guess) {
	                // run the validator code
	                var code = "(function() { " +
	                                "var guess = " + JSON.stringify(guess) + ";" +
	                                validatorCode +
	                            "})()";
	                return KhanUtil.tmpl.getVAR(code, KhanUtil.currentGraph);
	            };

	            return function(guess) {
	                var pass = validator(guess);
	                // If `pass` is an object, it's a new-style return type
	                if (typeof pass === "object") {
	                    return pass;
	                } else {
	                    // TODO(eater): For now most custom answers use the "old"
	                    // true/false/""/"..." return type.
	                    return {
	                        empty: pass === "",
	                        correct: pass === true,
	                        message: typeof pass === "string" ? pass : null,
	                        guess: guess
	                    };
	                }
	            };
	        }
	    },

	    /*
	     * The prime factorization answer type checks whether the correct list of
	     * prime factors matches the guess, by ordering the prime factors in
	     * ascending order, and placing "x"s between them
	     */
	    primeFactorization: {
	        // Same as the text function, the differences lie in the validator
	        // TODO(alpert): Use predicate or something like that?
	        setupFunctional: function(solutionarea, solutionText, solutionData) {
	            var input;
	            if (window.Modernizr && Modernizr.touchevents) {
	                // special flag for iOS devices
	                input = $('<input type="text" autocapitalize="off">');
	            } else {
	                input = $('<input type="text">');
	            }
	            $(solutionarea).append(input);

	            return {
	                validator: Khan.answerTypes.primeFactorization.createValidatorFunctional(
	                        solutionText, solutionData),
	                answer: function() {
	                    return input.val();
	                },
	                solution: $.trim(solutionText),
	                examples: [
	                    $._("a product of prime factors, like <code>2 \\times 3</code>"),
	                    $._("a single prime number, like <code>5</code>")
	                ],
	                showGuess: function(guess) {
	                    input.val(guess === undefined ? "" : guess);
	                }
	            };
	        },
	        createValidatorFunctional: function(correct, options) {
	            correct = $.trim(correct);

	            return function(guess) {
	                // Get rid of all the whitespace
	                guess = guess.split(" ").join("").toLowerCase();
	                // Split on x, *, or unicode x
	                guess = guess.split(/x|\*|\u00d7/);

	                // Replace a^b with b lots of axa
	                var terms = [];
	                for (var i = 0; i < guess.length; i++) {
	                    var t = guess[i].split('^');
	                    if (t.length > 1) {
	                        for (var j = 0; j < t[1]; j++) {
	                            terms.push(t[0]);
	                        }
	                    } else {
	                        terms.push(guess[i]);
	                    }
	                }

	                // Sort, and join with xs
	                guess = KhanUtil.sortNumbers(terms).join("x");
	                // perform simple string comparison
	                return {
	                    empty: guess === "",
	                    correct: guess === correct,
	                    message: null,
	                    guess: guess
	                };
	            };
	        }
	    },

	    /*
	     * The checkbox answer type provides a single checkbox, with the solution
	     * being true or false
	     */
	    checkbox: {
	        setupFunctional: function(solutionarea, solutionText, solutionData) {
	            // Make a checkbox
	            var input = $('<input type="checkbox">');
	            $(solutionarea).append(input);

	            return {
	                validator: Khan.answerTypes.checkbox.createValidatorFunctional(
	                        solutionText, solutionData),
	                answer: function() {
	                    // False as "" so that checkIfAnswerEmpty recognizes it as
	                    // empty
	                    return input.is(":checked") || "";
	                },
	                solution: $.trim(solutionText),
	                examples: [],
	                showGuess: function(guess) {
	                    input.attr("checked", guess === undefined ? false : guess);
	                }
	            };
	        },
	        createValidatorFunctional: function(correct, options) {
	            // store whether the correct answer is true or false
	            correct = $.trim(correct) === "true";

	            return function(guess) {
	                var score = {
	                    empty: false,
	                    correct: false,
	                    message: null,
	                    guess: guess
	                };
	                // If checkbox is unchecked, guess will be ""; cast to bool
	                /* jshint -W018 */
	                if (!!correct === !!guess) {
	                /* jshint +W018 */
	                    score.correct = true;
	                } else if (!guess) {
	                    // If unchecked, we'll say that the answer is empty, which
	                    // is necessary to ensure that a new question with
	                    // checkboxes counts as empty. Empty in a multiple grades
	                    // as false though so this shouldn't have any adverse
	                    // effects.
	                    score.empty = true;
	                } else {
	                    score.correct = false;
	                }
	                return score;
	            };
	        }
	    },

	    /*
	     * The expression answer type parses a given expression or equation
	     * and semantically compares it to the solution. In addition, instant
	     * feedback is provided by rendering the last answer that fully parsed.
	     *
	     * Parsing options:
	     * functions (e.g. data-functions="f g h")
	     *     A space or comma separated list of single-letter variables that
	     *     should be interpreted as functions. Case sensitive. "e" and "i"
	     *     are reserved.
	     *
	     *     no functions specified: f(x+y) == fx + fy
	     *     with "f" as a function: f(x+y) != fx + fy
	     *
	     * Comparison options:
	     * same-form (e.g. data-same-form)
	     *     If present, the answer must match the solution's structure in
	     *     addition to evaluating the same. Commutativity and excess negation
	     *     are ignored, but all other changes will trigger a rejection. Useful
	     *     for requiring a particular form of an equation, or if the answer
	     *     must be factored.
	     *
	     *     example question:    Factor x^2 + x - 2
	     *     example solution:    (x-1)(x+2)
	     *     accepted answers:    (x-1)(x+2), (x+2)(x-1), ---(-x-2)(-1+x), etc.
	     *     rejected answers:    x^2+x-2, x*x+x-2, x(x+1)-2, (x-1)(x+2)^1, etc.
	     *     rejection message:   Your answer is not in the correct form
	     *
	     * simplify (e.g. data-simplify)
	     *     If present, the answer must be fully expanded and simplified. Use
	     *     carefully - simplification is hard and there may be bugs, or you
	     *     might not agree on the definition of "simplified" used. You will
	     *     get an error if the provided solution is not itself fully expanded
	     *     and simplified.
	     *
	     *     example question:    Simplify ((n*x^5)^5) / (n^(-2)*x^2)^-3
	     *     example solution:    x^31 / n
	     *     accepted answers:    x^31 / n, x^31 / n^1, x^31 * n^(-1), etc.
	     *     rejected answers:    (x^25 * n^5) / (x^(-6) * n^6), etc.
	     *     rejection message:   Your answer is not fully expanded and simplified
	     *
	     * Rendering options:
	     * times (e.g. data-times)
	     *     If present, explicit multiplication (such as between numbers) will
	     *     be rendered with a cross/x symbol (TeX: \times) instead of the usual
	     *     center dot (TeX: \cdot).
	     *
	     *     normal rendering:    2 * 3^x -> 2 \cdot 3^{x}
	     *     but with "times":    2 * 3^x -> 2 \times 3^{x}
	     */
	    expression: {
	        parseSolution: function(solutionString, options) {
	            var solution = KAS.parse(solutionString, options);
	            if (!solution.parsed) {
	                throw new Error("The provided solution (" + solutionString +
	                    ") didn't parse.");
	            } else if (options.simplified && !solution.expr.isSimplified()) {
	                throw new Error("The provided solution (" + solutionString +
	                    ") isn't fully expanded and simplified.");
	            } else {
	                solution = solution.expr;
	            }
	            return solution;
	        },

	        _parseOptions: function(solutionData) {
	            // Convert options to a form KAS can understand
	            var form = solutionData.form !== undefined ?
	                solutionData.form :
	                solutionData.sameForm;
	            var notFalseOrNil = function(x) {
	                return x != null && x !== false;
	            };
	            var options = {
	                form: notFalseOrNil(form),
	                simplify: notFalseOrNil(solutionData.simplify),
	                times: notFalseOrNil(solutionData.times)
	            };
	            if (_.isString(solutionData.functions)) {
	                options.functions = _.compact(
	                    solutionData.functions.split(/[ ,]+/));
	            } else if (_.isArray(solutionData.functions)) {
	                options.functions = _.compact(solutionData.functions);
	            }
	            return options;
	        },

	        setupFunctional: function(solutionarea, solutionText, solutionData) {
	            var options = this._parseOptions(solutionData);
	            var solution = Khan.answerTypes.expression.parseSolution(solutionText, options);

	            // Assemble the solution area
	            var $input = $('<input type="text">');
	            var $tex = $('<span class="tex"/>');
	            var $error = $('<span class="error"/>').append(
	                $('<span class="buddy"/>'),
	                $('<span class="message">Sorry, I don\'t understand that!</span>')
	            );

	            $(solutionarea).append(
	                $('<span class="expression"/>').append(
	                    $input,
	                    $('<span class="output"/>').append(
	                        $tex,
	                        $('<span class="placeholder"/>').append(
	                            $error
	                        )
	                    )
	                )
	            );

	            // Specify how instant render (and error message) should update
	            var errorTimeout = null;
	            var lastParsedTex = "";

	            var update = function() {
	                clearTimeout(errorTimeout);
	                var result = KAS.parse($input.val(), options);
	                if (result.parsed) {
	                    hideError();
	                    $tex.css({opacity: 1.0});
	                    var tex = result.expr.asTex(options);
	                    if (tex !== lastParsedTex) {
	                        $tex.empty().append($("<code>").text(tex)).tex();
	                        lastParsedTex = tex;
	                    }
	                } else {
	                    errorTimeout = setTimeout(showError, 2000);
	                    $tex.css({opacity: 0.5});
	                }
	            };

	            var showError = function() {
	                if (!$error.is(":visible")) {
	                    $error.css({ top: 50, opacity: 0.1 }).show()
	                        .animate({ top: 0, opacity: 1.0 }, 300);
	                }
	            };

	            var hideError = function() {
	                if ($error.is(":visible")) {
	                    $error.animate({ top: 50, opacity: 0.1 }, 300, function() {
	                        $(this).hide();
	                    });
	                }
	            };

	            // Define event handlers
	            $input.on("input propertychange", update);

	            $input.on("keydown", function(event) {
	                var input = $input[0];

	                var start = input.selectionStart;
	                var end = input.selectionEnd;
	                var supported = start !== undefined;

	                if (supported && event.which === 8 /* backspace */) {
	                    var val = input.value;
	                    if (start === end && val.slice(start - 1, start + 1) === "()") {
	                        // "f(|)" + backspace -> "f|" (| is the cursor position)
	                        event.preventDefault();
	                        input.value = val.slice(0, start - 1) + val.slice(start + 1);
	                        input.selectionStart = start - 1;
	                        input.selectionEnd = end - 1;
	                        update();
	                    }
	                }
	            });

	            $input.on("keypress", function(event) {
	                var input = $input[0];

	                var start = input.selectionStart;
	                var end = input.selectionEnd;
	                var supported = start !== undefined;

	                if (supported && event.which === 40 /* left paren */) {
	                    var val = input.value;
	                    event.preventDefault();

	                    if (start === end) {
	                        // "f|" + "(" -> "f(|)"
	                        var insertMatched = _.any([" ", ")", ""], function(c) {
	                            return val.charAt(start) === c;
	                        });

	                        input.value = val.slice(0, start) +
	                                (insertMatched ? "()" : "(") + val.slice(end);
	                    } else {
	                        // "f|x+y|" + "(" -> "f(|x+y|)"
	                        input.value = val.slice(0, start) +
	                                "(" + val.slice(start, end) + ")" + val.slice(end);
	                    }

	                    input.selectionStart = start + 1;
	                    input.selectionEnd = end + 1;
	                    update();

	                } else if (supported && event.which === 41 /* right paren */) {
	                    var val = input.value;
	                    if (start === end && val.charAt(start) === ")") {
	                        // f(|) + ")" -> "f()|"
	                        event.preventDefault();
	                        input.selectionStart = start + 1;
	                        input.selectionEnd = end + 1;
	                        update();
	                    }
	                }
	            });

	            // Examples
	            var explicitMul = $._("For <code>2\\cdot2</code>, enter <strong>2*2</strong>");
	            if (options.times) {
	                explicitMul = explicitMul.replace(/\\cdot/g, "\\times");
	            }

	            return {
	                validator: Khan.answerTypes.expression.createValidatorFunctional(solution, solutionData),
	                answer: function() { return $input.val(); },
	                solution: solution.print(),
	                examples: [
	                    explicitMul,
	                    $._("For <code>3y</code>, enter <strong>3y</strong> or <strong>3*y</strong>"),
	                    $._("For <code>\\dfrac{1}{x}</code>, enter <strong>1/x</strong>"),
	                    $._("For <code>x^{y}</code>, enter <strong>x^y</strong>"),
	                    $._("For <code>\\sqrt{x}</code>, enter <strong>sqrt(x)</strong>"),
	                    $._("For <code>\\pi</code>, enter <strong>pi</strong>"),
	                    $._("For <code>\\sin \\theta</code>, enter <strong>sin(theta)</strong>"),
	                    $._("For <code>\\le</code> or <code>\\ge</code>, enter <strong><=</strong> or <strong>>=</strong>"),
	                    $._("For <code>\\neq</code>, enter <strong>=/=</strong>")
	                ],
	                showGuess: function(guess) {
	                    $input.val(guess === undefined ? "" : guess);
	                }
	            };
	        },
	        createValidatorFunctional: function(solution, solutionData) {
	            var options = this._parseOptions(solutionData);
	            return function(guess) {
	                var score = {
	                    empty: false,
	                    correct: false,
	                    message: null,
	                    guess: guess
	                };
	                // Don't bother parsing an empty input
	                if (!guess) {
	                    score.empty = true;
	                    return score;
	                }

	                var answer = KAS.parse(guess, options);

	                // An unsuccessful parse doesn't count as wrong
	                if (!answer.parsed) {
	                    score.empty = true;
	                    return score;
	                }

	                // Solution will need to be parsed again if we're creating
	                // this from a multiple question type
	                if (typeof solution === 'string') {
	                    solution = Khan.answerTypes.expression.parseSolution(solution, options);
	                }

	                var result = KAS.compare(answer.expr, solution, options);

	                if (result.equal) {
	                    // Correct answer
	                    score.correct = true;
	                } else if (result.message) {
	                    // Nearly correct answer
	                    score.message = result.message;
	                } else {
	                    // Replace x with * and see if it would have been correct
	                    var answerX = KAS.parse(guess.replace(/[xX]/g, "*"), options);
	                    if (answerX.parsed) {
	                        var resultX = KAS.compare(answerX.expr, solution, options);
	                        if (resultX.equal) {
	                            score.empty = true;
	                            score.message = "I'm a computer. I only " +
	                                    "understand multiplication if you use an " +
	                                    "asterisk (*) as the multiplication sign.";
	                        } else if (resultX.message) {
	                            score.message = resultX.message + " Also, " +
	                                    "I'm a computer. I only " +
	                                    "understand multiplication if you use an " +
	                                    "asterisk (*) as the multiplication sign.";
	                        }
	                    }
	                }
	                return score;
	            };
	        }
	    }
	});

	/**
	 * Return a new answer type that uses number but with the passed-in forms only.
	 */
	function numberAnswerType(forms) {
	    return {
	        setupFunctional: function(solutionarea, solutionText, solutionData) {
	            return Khan.answerTypes.number.setupFunctional(
	                    solutionarea,
	                    solutionText,
	                    $.extend({}, solutionData, {forms: forms}));
	        },
	        createValidatorFunctional: function(correct, options) {
	            return Khan.answerTypes.number.createValidatorFunctional(
	                    correct,
	                    $.extend({}, options, {forms: forms}));
	        }
	    };
	}

	_.each(Khan.answerTypes, function(info, type) {
	    if (!("setup" in info)) {
	        info.setup = function(solutionarea, solution) {
	            var $solution = $(solution);
	            return info.setupFunctional(
	                    solutionarea, $solution.text(), $solution.data());
	        };
	    }

	    if (!("createValidator" in info)) {
	        info.createValidator = function(solution) {
	            var $solution = $(solution);
	            return info.createValidatorFunctional(
	                    $solution.text(), $solution.data());
	        };
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var kpoint = __webpack_require__(7);
	__webpack_require__(13);  // for graphie.label()
	__webpack_require__(14);

	var Graphie = KhanUtil.Graphie = function() {
	};

	/* Convert cartesian coordinates [x, y] to polar coordinates [r,
	 * theta], with theta in degrees, or in radians if angleInRadians is
	 * specified.
	 */
	function cartToPolar(coord, angleInRadians) {
	    var r = Math.sqrt(Math.pow(coord[0], 2) + Math.pow(coord[1], 2));
	    var theta = Math.atan2(coord[1], coord[0]);
	    // convert angle range from [-pi, pi] to [0, 2pi]
	    if (theta < 0) {
	        theta += 2 * Math.PI;
	    }
	    if (!angleInRadians) {
	        theta = theta * 180 / Math.PI;
	    }
	    return [r, theta];
	}

	function polar(r, th) {
	    if (typeof r === "number") {
	        r = [r, r];
	    }
	    th = th * Math.PI / 180;
	    return [r[0] * Math.cos(th), r[1] * Math.sin(th)];
	}

	// Keep track of all the intervalIDs created by setInterval.
	// This lets us cancel all the intervals when cleaning up.
	var intervalIDs = [];
	function cleanupIntervals() {
	    _.each(intervalIDs, function(intervalID) {
	        window.clearInterval(intervalID);
	    });
	    intervalIDs.length = 0;
	}

	$.extend(KhanUtil, {
	    unscaledSvgPath: function(points) {
	        // If this is an empty closed path, return "" instead of "z", which
	        // would give an error
	        if (points[0] === true) {
	            return "";
	        }
	        return $.map(points, function(point, i) {
	            if (point === true) {
	                return "z";
	            }
	            return (i === 0 ? "M" : "L") + point[0] + " " + point[1];
	        }).join("");
	    },

	    getDistance: function(point1, point2) {
	        return kpoint.distanceToPoint(point1, point2);
	    },

	    /**
	    * Return the difference between two sets of coordinates
	    */
	    coordDiff: function(startCoord, endCoord) {
	        return _.map(endCoord, function(val, i) {
	            return endCoord[i] - startCoord[i];
	        });
	    },

	    /**
	    * Round the given coordinates to a given snap value
	    * (e.g., nearest 0.2 increment)
	    */
	    snapCoord: function(coord, snap) {
	        return _.map(coord, function(val, i) {
	            return KhanUtil.roundToNearest(snap[i], val);
	        });
	    },

	    // Find the angle in degrees between two or three points
	    findAngle: function(point1, point2, vertex) {
	        if (vertex === undefined) {
	            var x = point1[0] - point2[0];
	            var y = point1[1] - point2[1];
	            if (!x && !y) {
	                return 0;
	            }
	            return (180 + Math.atan2(-y, -x) * 180 / Math.PI + 360) % 360;
	        } else {
	            return KhanUtil.findAngle(point1, vertex) - KhanUtil.findAngle(point2, vertex);
	        }
	    },

	    graphs: {}
	});


	_.extend(Graphie.prototype, {
	    cartToPolar: cartToPolar,
	    polar: polar
	});

	var labelDirections = {
	    "center": [-0.5, -0.5],
	    "above": [-0.5, -1.0],
	    "above right": [0.0, -1.0],
	    "right": [0.0, -0.5],
	    "below right": [0.0, 0.0],
	    "below": [-0.5, 0.0],
	    "below left": [-1.0, 0.0],
	    "left": [-1.0, -0.5],
	    "above left": [-1.0, -1.0]
	};

	KhanUtil.createGraphie = function(el) {
	    var xScale = 40, yScale = 40, xRange, yRange;

	    $(el).css("position", "relative");
	    var raphael = Raphael(el);

	    // For a sometimes-reproducible IE8 bug; doesn't affect SVG browsers at all
	    $(el).children("div").css("position", "absolute");

	    // Set up some reasonable defaults
	    var currentStyle = {
	        "stroke-width": 2,
	        "fill": "none"
	    };

	    var scaleVector = function(point) {
	        if (typeof point === "number") {
	            return scaleVector([point, point]);
	        }

	        var x = point[0], y = point[1];
	        return [x * xScale, y * yScale];
	    };

	    var scalePoint = function scalePoint(point) {
	        if (typeof point === "number") {
	            return scalePoint([point, point]);
	        }

	        var x = point[0], y = point[1];
	        return [(x - xRange[0]) * xScale, (yRange[1] - y) * yScale];
	    };

	    var unscalePoint = function(point) {
	        if (typeof point === "number") {
	            return unscalePoint([point, point]);
	        }

	        var x = point[0], y = point[1];
	        return [x / xScale + xRange[0], yRange[1] - y / yScale];
	    };

	    var unscaleVector = function(point) {
	        if (typeof point === "number") {
	            return unscaleVector([point, point]);
	        }

	        return [point[0] / xScale, point[1] / yScale];
	    };

	    var setLabelMargins = function(span, size) {
	        var $span = $(span);
	        var direction = $span.data("labelDirection");
	        $span.css("visibility", "");

	        if (typeof direction === "number") {
	            var x = Math.cos(direction);
	            var y = Math.sin(direction);

	            var scale = Math.min(
	                size[0] / 2 / Math.abs(x),
	                size[1] / 2 / Math.abs(y));

	            $span.css({
	                marginLeft: (-size[0] / 2) + x * scale,
	                marginTop: (-size[1] / 2) - y * scale
	            });
	        } else {
	            var multipliers = labelDirections[direction || "center"];
	            $span.css({
	                marginLeft: Math.round(size[0] * multipliers[0]),
	                marginTop: Math.round(size[1] * multipliers[1])
	            });
	        }
	    };

	    var svgPath = function(points, alreadyScaled) {
	        // Bound a number by 1e-6 and 1e20 to avoid exponents after toString
	        function boundNumber(num) {
	            if (num === 0) {
	                return num;
	            } else if (num < 0) {
	                return -boundNumber(-num);
	            } else {
	                return Math.max(1e-6, Math.min(num, 1e20));
	            }
	        }

	        return $.map(points, function(point, i) {
	            if (point === true) {
	                return "z";
	            } else {
	                var scaled = alreadyScaled ? point : scalePoint(point);
	                return (i === 0 ? "M" : "L") + boundNumber(scaled[0]) + " " + boundNumber(scaled[1]);
	            }
	        }).join("");
	    };

	    $.extend(KhanUtil, {svgPath: svgPath});

	    var processAttributes = function(attrs) {
	        var transformers = {
	            scale: function(scale) {
	                if (typeof scale === "number") {
	                    scale = [scale, scale];
	                }

	                xScale = scale[0];
	                yScale = scale[1];

	                // Update the canvas size
	                raphael.setSize((xRange[1] - xRange[0]) * xScale, (yRange[1] - yRange[0]) * yScale);
	            },

	            clipRect: function(pair) {
	                var point = pair[0], size = pair[1];
	                point[1] += size[1]; // because our coordinates are flipped

	                return { "clip-rect": scalePoint(point).concat(scaleVector(size)).join(" ") };
	            },

	            strokeWidth: function(val) {
	                return { "stroke-width": parseFloat(val) };
	            },

	            rx: function(val) {
	                return { rx: scaleVector([val, 0])[0] };
	            },

	            ry: function(val) {
	                return { ry: scaleVector([0, val])[1] };
	            },

	            r: function(val) {
	                var scaled = scaleVector([val, val]);
	                return { rx: scaled[0], ry: scaled[1] };
	            }
	        };

	        var processed = {};
	        $.each(attrs || {}, function(key, value) {
	            var transformer = transformers[key];

	            if (typeof transformer === "function") {
	                $.extend(processed, transformer(value));
	            } else {
	                var dasherized = key.replace(/([A-Z]+)([A-Z][a-z])/g, "$1-$2")
	                    .replace(/([a-z\d])([A-Z])/g, "$1-$2")
	                    .toLowerCase();
	                processed[dasherized] = value;
	            }
	        });

	        return processed;
	    };

	    var addArrowheads = function arrows(path) {
	        var type = path.constructor.prototype;

	        if (type === Raphael.el) {
	            if (path.type === "path" && typeof path.arrowheadsDrawn === "undefined") {
	                var w = path.attr("stroke-width"), s = 0.6 + 0.4 * w;
	                var l = path.getTotalLength();

	                if (l < 0.75 * s) {
	                    // You're weird because that's a *really* short path
	                    // Giving up now before I get more confused

	                } else {
	                    // This makes a lot more sense
	                    var set = raphael.set();
	                    var head = raphael.path("M-3 4 C-2.75 2.5 0 0.25 0.75 0C0 -0.25 -2.75 -2.5 -3 -4");
	                    var end = path.getPointAtLength(l - 0.4);
	                    var almostTheEnd = path.getPointAtLength(l - 0.75 * s);
	                    var angle = Math.atan2(end.y - almostTheEnd.y, end.x - almostTheEnd.x) * 180 / Math.PI;
	                    var attrs = path.attr();
	                    delete attrs.path;

	                    var subpath = path.getSubpath(0, l - 0.75 * s);
	                    subpath = raphael.path(subpath).attr(attrs);
	                    subpath.arrowheadsDrawn = true;
	                    path.remove();

	                    head.rotate(angle, 0.75, 0).scale(s, s, 0.75, 0)
	                        .translate(almostTheEnd.x, almostTheEnd.y).attr(attrs)
	                        .attr({ "stroke-linejoin": "round", "stroke-linecap": "round" });
	                    head.arrowheadsDrawn = true;
	                    set.push(subpath);
	                    set.push(head);
	                    return set;
	                }
	            }
	        } else if (type === Raphael.st) {
	            for (var i = 0, l = path.items.length; i < l; i++) {
	                arrows(path.items[i]);
	            }
	        }
	        return path;
	    };

	    var drawingTools = {
	        circle: function(center, radius) {
	            return raphael.ellipse.apply(raphael, scalePoint(center).concat(scaleVector([radius, radius])));
	        },

	        // (x, y) is coordinate of bottom left corner
	        rect: function(x, y, width, height) {
	            // Raphael needs (x, y) to be coordinate of upper left corner
	            var corner = scalePoint([x, y + height]);
	            var dims = scaleVector([width, height]);
	            return raphael.rect.apply(raphael, corner.concat(dims));
	        },

	        ellipse: function(center, radii) {
	            return raphael.ellipse.apply(raphael, scalePoint(center).concat(scaleVector(radii)));
	        },

	        arc: function(center, radius, startAngle, endAngle, sector) {
	            startAngle = (startAngle % 360 + 360) % 360;
	            endAngle = (endAngle % 360 + 360) % 360;

	            var cent = scalePoint(center);
	            var radii = scaleVector(radius);
	            var startVector = polar(radius, startAngle);
	            var endVector = polar(radius, endAngle);

	            var startPoint = scalePoint([center[0] + startVector[0], center[1] + startVector[1]]);
	            var endPoint = scalePoint([center[0] + endVector[0], center[1] + endVector[1]]);

	            var largeAngle = ((endAngle - startAngle) % 360 + 360) % 360 > 180;

	            return raphael.path(
	                "M" + startPoint.join(" ") +
	                "A" + radii.join(" ") +
	                " 0 " + // ellipse rotation
	                (largeAngle ? 1 : 0) +
	                " 0 " + // sweep flag
	                endPoint.join(" ") +
	                (sector ? "L" + cent.join(" ") + "z" : ""));
	        },

	        path: function(points) {
	            var p = raphael.path(svgPath(points));
	            p.graphiePath = points;
	            return p;
	        },

	        scaledPath: function(points) {
	            var p = raphael.path(svgPath(points, /* alreadyScaled */ true));
	            p.graphiePath = points;
	            return p;
	        },

	        line: function(start, end) {
	            return this.path([start, end]);
	        },

	        grid: function(xr, yr) {
	            var step = currentStyle.step || [1, 1];
	            var set = raphael.set();

	            var x = step[0] * Math.ceil(xr[0] / step[0]);
	            for (; x <= xr[1]; x += step[0]) {
	                set.push(this.line([x, yr[0]], [x, yr[1]]));
	            }

	            var y = step[1] * Math.ceil(yr[0] / step[1]);
	            for (; y <= yr[1]; y += step[1]) {
	                set.push(this.line([xr[0], y], [xr[1], y]));
	            }

	            return set;
	        },

	        label: function(point, text, direction, latex) {
	            latex = (typeof latex === "undefined") || latex;

	            var $span = $("<span>").addClass("graphie-label");

	            if (!latex) {
	                $span.html(text);
	            }

	            var pad = currentStyle["label-distance"];

	            // TODO(alpert): Isn't currentStyle applied afterwards
	            // automatically since this is a 'drawing tool'?
	            $span
	                .css($.extend({}, currentStyle, {
	                        position: "absolute",
	                        padding: (pad != null ? pad : 7) + "px"
	                    }))
	                .data("labelDirection", direction)
	                .appendTo(el);

	            $span.setPosition = function(point) {
	                var scaledPoint = scalePoint(point);
	                $span.css({
	                    left: scaledPoint[0],
	                    top: scaledPoint[1]
	                });
	            };

	            $span.setPosition(point);

	            var span = $span[0];

	            $span.processMath = function(math, force) {
	                KhanUtil.processMath(span, math, force, function() {
	                    var width = span.scrollWidth;
	                    var height = span.scrollHeight;
	                    setLabelMargins(span, [width, height]);
	                });
	            };

	            if (latex) {
	                $span.processMath(text, /* force */ false);
	            } else {
	                var width = span.scrollWidth;
	                var height = span.scrollHeight;
	                setLabelMargins(span, [width, height]);
	            }

	            return $span;
	        },

	        plotParametric: function(fn, range, shade, fn2) {
	            // Note: fn2 should only be set if 'shade' is true, as it denotes
	            // the function between which fn should have its area shaded.
	            // In general, plotParametric shouldn't be used to shade the area
	            // between two arbitrary parametrics functions over an interval,
	            // as the method assumes that fn and fn2 are both of the form
	            // fn(t) = (t, fn'(t)) for some initial fn'.
	            fn2 = fn2 || function(t) { return [t, 0]; };

	            currentStyle.strokeLinejoin || (currentStyle.strokeLinejoin = "round");
	            currentStyle.strokeLinecap || (currentStyle.strokeLinecap = "round");

	            var min = range[0], max = range[1];
	            var step = (max - min) / (currentStyle["plot-points"] || 800);
	            if (step === 0) {
	                step = 1;
	            }

	            var paths = raphael.set();
	            var points = [];
	            var lastDiff = KhanUtil.coordDiff(fn(min), fn2(min));

	            var lastFlip = min;
	            for (var t = min; t <= max; t += step) {
	                var top = fn(t);
	                var bottom = fn2(t);
	                var diff = KhanUtil.coordDiff(top, bottom);

	                // Find points where it flips
	                // Create path that sketches area between the two functions
	                if (
	                    // if there is an asymptote here, meaning that the graph switches signs and has a large difference
	                    ((diff[1] < 0) !== (lastDiff[1] < 0)) && Math.abs(diff[1] - lastDiff[1]) > 2 * yScale ||
	                    // or the function value gets really high (which breaks raphael)
	                    Math.abs(diff[1]) > 1e7 ||
	                    // or the function is undefined
	                    isNaN(diff[1])
	                   ) {
	                    // split the path at this point, and draw it
	                    if (shade) {
	                        points.push(top);

	                        // backtrack to draw paired function
	                        for (var u = t - step; u >= lastFlip; u -= step) {
	                            points.push(fn2(u));
	                        }
	                        lastFlip = t;
	                    }
	                    paths.push(this.path(points));
	                    // restart the path, excluding this point
	                    points = [];
	                    if (shade) {
	                        points.push(top);
	                    }
	                } else {
	                    // otherwise, just add the point to the path
	                    points.push(top);
	                }

	                lastDiff = diff;
	            }

	            if (shade) {
	                // backtrack to draw paired function
	                for (var u = max - step; u >= lastFlip; u -= step) {
	                    points.push(fn2(u));
	                }
	            }
	            paths.push(this.path(points));

	            return paths;
	        },

	        plotPolar: function(fn, range) {
	            var min = range[0], max = range[1];

	            // There is probably a better heuristic for this
	            currentStyle["plot-points"] || (currentStyle["plot-points"] = 2 * (max - min) * xScale);

	            return this.plotParametric(function(th) {
	                return polar(fn(th), th * 180 / Math.PI);
	            }, range);
	        },

	        plot: function(fn, range, swapAxes, shade, fn2) {
	            var min = range[0], max = range[1];
	            currentStyle["plot-points"] || (currentStyle["plot-points"] = 2 * (max - min) * xScale);

	            if (swapAxes) {
	                if (fn2) {
	                    // TODO(charlie): support swapped axis area shading
	                    throw new Error(
	                        "Can't shade area between functions with swapped axes."
	                    );
	                }
	                return this.plotParametric(function(y) {
	                    return [fn(y), y];
	                }, range, shade);
	            } else {
	                if (fn2) {
	                    if (shade) {
	                        return this.plotParametric(function(x) {
	                            return [x, fn(x)];
	                        }, range, shade, function(x) {
	                            return [x, fn2(x)];
	                        });
	                    } else {
	                        throw new Error(
	                            "fn2 should only be set when 'shade' is True."
	                        );
	                    }
	                }
	                return this.plotParametric(function(x) {
	                    return [x, fn(x)];
	                }, range, shade);
	            }
	        },

	        /**
	         * Given a piecewise function, return a Raphael set of paths that
	         * can be used to draw the function, e.g. using style().
	         * Calls plotParametric.
	         *
	         * @param  {[]} fnArray    array of functions which when called
	         *                         with a parameter i return the value of
	         *                         the function at i
	         * @param  {[]} rangeArray array of ranges over which the
	         *                         corresponding functions are defined
	         * @return {Raphael set}
	         */
	        plotPiecewise: function(fnArray, rangeArray) {
	            var paths = raphael.set();
	            var self = this;
	            _.times(fnArray.length, function(i) {
	                var fn = fnArray[i];
	                var range = rangeArray[i];
	                var fnPaths = self.plotParametric(function(x) {
	                    return [x, fn(x)];
	                }, range);
	                _.each(fnPaths, function(fnPath) {
	                    paths.push(fnPath);
	                });
	            });

	            return paths;
	        },

	        /**
	         * Given an array of coordinates of the form [x, y], create and
	         * return a Raphael set of Raphael circle objects at those
	         * coordinates
	         *
	         * @param  {Array of arrays} endpointArray
	         * @return {Raphael set}
	         */
	        plotEndpointCircles: function(endpointArray) {
	            var circles = raphael.set();
	            var self = this;

	            _.each(endpointArray, function(coord, i) {
	                circles.push(self.circle(coord, 0.15));
	            });

	            return circles;
	        },

	        plotAsymptotes: function(fn, range) {
	            var min = range[0], max = range[1];
	            var step = (max - min) / (currentStyle["plot-points"] || 800);

	            var asymptotes = raphael.set(), lastVal = fn(min);

	            for (var t = min; t <= max; t += step) {
	                var funcVal = fn(t);

	                if (((funcVal < 0) !== (lastVal < 0)) && Math.abs(funcVal - lastVal) > 2 * yScale) {
	                    asymptotes.push(
	                        this.line([t, yScale], [t, -yScale])
	                    );
	                }

	                lastVal = funcVal;
	            }

	            return asymptotes;
	        }
	    };

	    var graphie = new Graphie();
	    _.extend(graphie, {
	        raphael: raphael,

	        init: function(options) {
	            var scale = options.scale || [40, 40];
	            scale = (typeof scale === "number" ? [scale, scale] : scale);

	            xScale = scale[0];
	            yScale = scale[1];

	            if (options.range == null) {
	                return Khan.error("range should be specified in graph init");
	            }

	            xRange = options.range[0];
	            yRange = options.range[1];

	            var w = (xRange[1] - xRange[0]) * xScale, h = (yRange[1] - yRange[0]) * yScale;
	            raphael.setSize(w, h);

	            $(el).css({
	                "width": w,
	                "height": h
	            });

	            this.range = options.range;
	            this.scale = scale;
	            this.dimensions = [w, h];
	            this.xpixels = w;
	            this.ypixels = h;

	            return this;
	        },

	        // Wrap window.setInterval to keep track of all the intervalIDs.
	        setInterval: function() {
	            var intervalID = Function.prototype.apply.call(window.setInterval,
	                                                           window,
	                                                           arguments);
	            intervalIDs.push(intervalID);
	            return intervalID;
	        },

	        style: function(attrs, fn) {
	            var processed = processAttributes(attrs);

	            if (typeof fn === "function") {
	                var oldStyle = currentStyle;
	                currentStyle = $.extend({}, currentStyle, processed);
	                var result = fn.call(graphie);
	                currentStyle = oldStyle;
	                return result;
	            } else {
	                $.extend(currentStyle, processed);
	            }
	        },

	        scalePoint: scalePoint,
	        scaleVector: scaleVector,

	        unscalePoint: unscalePoint,
	        unscaleVector: unscaleVector
	    });

	    $.each(drawingTools, function(name) {
	        graphie[name] = function() {
	            var last = arguments[arguments.length - 1];
	            var oldStyle = currentStyle;
	            var result;

	            // The last argument is probably trying to change the style
	            if (typeof last === "object" && !_.isArray(last)) {
	                currentStyle = $.extend({}, currentStyle, processAttributes(last));

	                var rest = [].slice.call(arguments, 0, arguments.length - 1);
	                result = drawingTools[name].apply(drawingTools, rest);
	            } else {
	                currentStyle = $.extend({}, currentStyle);

	                result = drawingTools[name].apply(drawingTools, arguments);
	            }

	            // Bad heuristic for recognizing Raphael elements and sets
	            var type = result.constructor.prototype;
	            if (type === Raphael.el || type === Raphael.st) {
	                result.attr(currentStyle);

	                if (currentStyle.arrows) {
	                    result = addArrowheads(result);
	                }
	            } else if (result instanceof $) {
	                result.css(currentStyle);
	            }

	            currentStyle = oldStyle;
	            return result;
	        };
	    });


	    // Initializes graphie settings for a graph and draws the basic graph
	    // features (axes, grid, tick marks, and axis labels)
	    // Options expected are:
	    // - range: [[a, b], [c, d]] or [a, b]
	    // - scale: [a, b] or number
	    // - gridOpacity: number (0 - 1)
	    // - gridStep: [a, b] or number (relative to units)
	    // - tickStep: [a, b] or number (relative to grid steps)
	    // - tickLen: [a, b] or number (in pixels)
	    // - labelStep: [a, b] or number (relative to tick steps)
	    // - yLabelFormat: fn to format label string for y-axis
	    // - xLabelFormat: fn to format label string for x-axis
	    // - smartLabelPositioning: true or false to ignore minus sign
	    graphie.graphInit = function(options) {

	        options = options || {};

	        $.each(options, function(prop, val) {

	            // allow options to be specified by a single number for shorthand if
	            // the horizontal and vertical components are the same
	            if (!prop.match(/.*Opacity$/) && prop !== "range" &&
	                typeof val === "number") {
	                options[prop] = [val, val];
	            }

	            // allow symmetric ranges to be specified by the absolute values
	            if (prop === "range" || prop === "gridRange") {
	                if (val.constructor === Array) {
	                    if (val[0].constructor !== Array) {  // but don't mandate symmetric ranges
	                        options[prop] = [[-val[0], val[0]], [-val[1], val[1]]];
	                    }
	                } else if (typeof val === "number") {
	                    options[prop] = [[-val, val], [-val, val]];
	                }
	            }

	        });

	        var range = options.range || [[-10, 10], [-10, 10]],
	            gridRange = options.gridRange || options.range,
	            scale = options.scale || [20, 20],
	            grid = options.grid != null ? options.grid : true,
	            gridOpacity = options.gridOpacity || 0.1,
	            gridStep = options.gridStep || [1, 1],
	            axes = options.axes != null ? options.axes : true,
	            axisArrows = options.axisArrows || "",
	            axisOpacity = options.axisOpacity || 1.0,
	            axisCenter = options.axisCenter || [
	                Math.min(Math.max(range[0][0], 0), range[0][1]),
	                Math.min(Math.max(range[1][0], 0), range[1][1])
	            ],
	            ticks = options.ticks != null ? options.ticks : true,
	            tickStep = options.tickStep || [2, 2],
	            tickLen = options.tickLen || [5, 5],
	            tickOpacity = options.tickOpacity || 1.0,
	            labels = options.labels || options.labelStep || false,
	            labelStep = options.labelStep || [1, 1],
	            labelOpacity = options.labelOpacity || 1.0,
	            unityLabels = options.unityLabels || false,
	            labelFormat = options.labelFormat || function(a) { return a; },
	            xLabelFormat = options.xLabelFormat || labelFormat,
	            yLabelFormat = options.yLabelFormat || labelFormat,
	            smartLabelPositioning = options.smartLabelPositioning != null ?
	                options.smartLabelPositioning : true,
	            realRange = [
	                [range[0][0] - (range[0][0] > 0 ? 1 : 0),
	                 range[0][1] + (range[0][1] < 0 ? 1 : 0)],
	                [range[1][0] - (range[1][0] > 0 ? 1 : 0),
	                 range[1][1] + (range[1][1] < 0 ? 1 : 0)]
	            ];

	        if (!_.isArray(unityLabels)) {
	            unityLabels = [unityLabels, unityLabels];
	        }

	        if (smartLabelPositioning) {
	            var minusIgnorer = function(lf) { return function(a) {
	                return (lf(a) + "").replace(/-(\d)/g, "\\llap{-}$1");
	            }; };

	            xLabelFormat = minusIgnorer(xLabelFormat);
	            yLabelFormat = minusIgnorer(yLabelFormat);
	        }

	        this.init({
	            range: realRange,
	            scale: scale
	        });

	        // draw grid
	        if (grid) {
	            this.grid(gridRange[0], gridRange[1], {
	                stroke: "#000000",
	                opacity: gridOpacity,
	                step: gridStep
	            });
	        }

	        // draw axes
	        if (axes) {

	            // this is a slight hack until <-> arrowheads work
	            if (axisArrows === "<->" || true) {
	                this.style({
	                    stroke: "#000000",
	                    opacity: axisOpacity,
	                    strokeWidth: 2,
	                    arrows: "->"
	                }, function() {
	                    if (range[1][0] < 0 && range[1][1] > 0) {
	                        this.path([axisCenter, [gridRange[0][0], axisCenter[1]]]);
	                        this.path([axisCenter, [gridRange[0][1], axisCenter[1]]]);
	                    }
	                    if (range[0][0] < 0 && range[0][1] > 0) {
	                        this.path([axisCenter, [axisCenter[0], gridRange[1][0]]]);
	                        this.path([axisCenter, [axisCenter[0], gridRange[1][1]]]);
	                    }
	                });

	            // also, we don't support "<-" arrows yet, but why you
	            // would want that on your graph is beyond me.
	            } else if (axisArrows === "->" || axisArrows === "") {
	                this.style({
	                    stroke: "#000000",
	                    opacity: axisOpacity,
	                    strokeWidth: 2,
	                    arrows: axisArrows
	                }, function() {
	                    this.path([[gridRange[0][0], axisCenter[1]], [gridRange[0][1], axisCenter[1]]]);
	                    this.path([[axisCenter[0], gridRange[1][0]], [axisCenter[0], gridRange[1][1]]]);
	                });

	            }

	        }

	        // draw tick marks
	        if (ticks) {
	            this.style({
	                stroke: "#000000",
	                opacity: tickOpacity,
	                strokeWidth: 1
	            }, function() {

	                // horizontal axis
	                var step = gridStep[0] * tickStep[0],
	                    len = tickLen[0] / scale[1],
	                    start = gridRange[0][0],
	                    stop = gridRange[0][1];

	                if (range[1][0] < 0 && range[1][1] > 0) {
	                    for (var x = step + axisCenter[0]; x <= stop; x += step) {
	                        if (x < stop || !axisArrows) {
	                            this.line([x, -len + axisCenter[1]], [x, len + axisCenter[1]]);
	                        }
	                    }

	                    for (var x = -step + axisCenter[0]; x >= start; x -= step) {
	                        if (x > start || !axisArrows) {
	                            this.line([x, -len + axisCenter[1]], [x, len + axisCenter[1]]);
	                        }
	                    }
	                }

	                // vertical axis
	                step = gridStep[1] * tickStep[1];
	                len = tickLen[1] / scale[0];
	                start = gridRange[1][0];
	                stop = gridRange[1][1];

	                if (range[0][0] < 0 && range[0][1] > 0) {
	                    for (var y = step + axisCenter[1]; y <= stop; y += step) {
	                        if (y < stop || !axisArrows) {
	                            this.line([-len + axisCenter[0], y], [len + axisCenter[0], y]);
	                        }
	                    }

	                    for (var y = -step + axisCenter[1]; y >= start; y -= step) {
	                        if (y > start || !axisArrows) {
	                            this.line([-len + axisCenter[0], y], [len + axisCenter[0], y]);
	                        }
	                    }
	                }

	            });
	        }

	        // draw axis labels
	        if (labels) {
	            this.style({
	                stroke: "#000000",
	                opacity: labelOpacity
	            }, function() {

	                // horizontal axis
	                var step = gridStep[0] * tickStep[0] * labelStep[0],
	                    start = gridRange[0][0],
	                    stop = gridRange[0][1],
	                    xAxisPosition = (axisCenter[0] < 0) ? "above" : "below",
	                    yAxisPosition = (axisCenter[0] < 0) ? "right" : "left",
	                    xShowZero = axisCenter[0] === 0 && axisCenter[1] !== 0,
	                    yShowZero = axisCenter[0] !== 0 && axisCenter[1] === 0,
	                    axisOffCenter = axisCenter[0] !== 0 || axisCenter[1] !== 0,
	                    showUnityX = unityLabels[0] || axisOffCenter,
	                    showUnityY = unityLabels[1] || axisOffCenter;

	                // positive x-axis
	                for (var x = (xShowZero ? 0 : step) + axisCenter[0]; x <= stop; x += step) {
	                    if (x < stop || !axisArrows) {
	                        this.label([x, axisCenter[1]], xLabelFormat(x), xAxisPosition);
	                    }
	                }

	                // negative x-axis
	                for (var x = -step * (showUnityX ? 1 : 2) + axisCenter[0]; x >= start; x -= step) {
	                    if (x > start || !axisArrows) {
	                        this.label([x, axisCenter[1]], xLabelFormat(x), xAxisPosition);
	                    }
	                }

	                step = gridStep[1] * tickStep[1] * labelStep[1];
	                start = gridRange[1][0];
	                stop = gridRange[1][1];

	                // positive y-axis
	                for (var y = (yShowZero ? 0 : step) + axisCenter[1]; y <= stop; y += step) {
	                    if (y < stop || !axisArrows) {
	                        this.label([axisCenter[0], y], yLabelFormat(y), yAxisPosition);
	                    }
	                }

	                // negative y-axis
	                for (var y = -step * (showUnityY ? 1 : 2) + axisCenter[1]; y >= start; y -= step) {
	                    if (y > start || !axisArrows) {
	                        this.label([axisCenter[0], y], yLabelFormat(y), yAxisPosition);
	                    }
	                }
	            });
	        }

	    };

	    return graphie;
	};

	$.fn.graphie = function(problem) {
	    if (Khan.query.nographie != null) {
	        return;
	    }
	    return this.find(".graphie, script[type='text/graphie']").addBack().filter(".graphie, script[type='text/graphie']").each(function() {
	        // Grab code for later execution
	        var code = $(this).text(), graphie;

	        // Ignore graphie elements that have already been processed
	        if ($(this).data("graphie") != null) {
	            return;
	        }

	        // Remove any of the code that's in there
	        $(this).empty();

	        // Initialize the graph
	        if ($(this).data("update")) {
	            var id = $(this).data("update");
	            $(this).remove();

	            // Graph could be in either of these
	            var area = $("#problemarea").add(problem);
	            graphie = area.find("#" + id + ".graphie").data("graphie");
	        } else {
	            var el = this;
	            if ($(this).filter("script")[0] != null) {
	                el = $("<div>").addClass("graphie")
	                    .attr("id", $(this).attr("id")).insertAfter(this)[0];
	                $(this).remove();
	            }
	            graphie = KhanUtil.createGraphie(el);
	            $(el).data("graphie", graphie);

	            var id = $(el).attr("id");
	            if (id) {
	                KhanUtil.graphs[id] = graphie;
	            }
	        }

	        // So we can write graph.bwahahaha = 17 to save stuff between updates
	        if (typeof graphie.graph === "undefined") {
	            graphie.graph = {};
	        }

	        // Add newline in case code ends with a // comment
	        code = "(function() {" + code + "\n})()";

	        // Execute the graph-specific code
	        KhanUtil.currentGraph = graphie;
	        $.tmpl.getVAR(code, graphie);
	        // delete KhanUtil.currentGraph;
	    }).end();
	};

	$.fn.graphieCleanup = function(problem) {
	    cleanupIntervals();
	};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(16);

	__webpack_require__(3);
	var knumber = __webpack_require__(6);
	var kvector = __webpack_require__(9);
	var kpoint = __webpack_require__(7);
	var kline = __webpack_require__(5);

	function sum(array) {
	    return _.reduce(array, function(memo, arg) { return memo + arg; }, 0);
	}

	function clockwise(points) {
	    var segments = _.zip(points, points.slice(1).concat(points.slice(0, 1)));
	    var areas = _.map(segments, function(segment) {
	        var p1 = segment[0], p2 = segment[1];
	        return (p2[0] - p1[0]) * (p2[1] + p1[1]);
	    });
	    return sum(areas) > 0;
	}

	/* vector-add multiple [x, y] coords/vectors */
	function addPoints() {
	    var points = _.toArray(arguments);
	    var zipped = _.zip.apply(_, points);
	    return _.map(zipped, sum);
	}

	function reverseVector(vector) {
	    return _.map(vector, function(coord) {
	        return coord * -1;
	    });
	}

	function scaledDistanceFromAngle(angle) {
	    // constants based on the magic numbers from graphie.addTriangle()
	    var a = 3.51470560176242 * 20;
	    var b = 0.5687298702748785 * 20;
	    var c = -0.037587715462826674;
	    return (a - b) * Math.exp(c * angle) + b;
	}

	function scaledPolarRad(radius, radians) {
	    return [
	        radius * Math.cos(radians),
	        radius * Math.sin(radians) * -1 // SVG flips y axis
	    ];
	}

	function scaledPolarDeg(radius, degrees) {
	    var radians = degrees * Math.PI / 180;
	    return scaledPolarRad(radius, radians);
	}


	$.extend(KhanUtil, {
	    // Fill opacity for inequality shading
	    FILL_OPACITY: 0.3,

	    // TODO(alpert): Should this be a global?
	    dragging: false,

	    createSorter: function() {
	        var sorter = {};
	        var list;

	        sorter.hasAttempted = false;

	        sorter.init = function(element) {
	            list = $("[id=" + element + "]").last();
	            var container = list.wrap("<div>").parent();
	            var placeholder = $("<li>");
	            placeholder.addClass("placeholder");
	            container.addClass("sortable ui-helper-clearfix");

	            list.find("li").each(function(tileNum, tile) {
	                $(tile).bind("vmousedown", function(event) {
	                    if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
	                        event.preventDefault();
	                        $(tile).addClass("dragging");
	                        var tileIndex = $(this).index();
	                        placeholder.insertAfter(tile);
	                        placeholder.width($(tile).width());
	                        $(this).css("z-index", 100);
	                        var offset = $(this).offset();
	                        var click = {
	                            left: event.pageX - offset.left - 3,
	                            top: event.pageY - offset.top - 3
	                        };
	                        $(tile).css({ position: "absolute" });
	                        $(tile).offset({
	                            left: offset.left,
	                            top: offset.top
	                        });

	                        $(document).bind("vmousemove.tile vmouseup.tile", function(event) {
	                            event.preventDefault();
	                            if (event.type === "vmousemove") {
	                                sorter.hasAttempted = true;
	                                $(tile).offset({
	                                    left: event.pageX - click.left,
	                                    top: event.pageY - click.top
	                                });
	                                var leftEdge = list.offset().left;
	                                var midWidth = $(tile).offset().left - leftEdge;
	                                var index = 0;
	                                var sumWidth = 0;
	                                list.find("li").each(function() {
	                                    if (this === placeholder[0] || this === tile) {
	                                        return;
	                                    }
	                                    if (midWidth > sumWidth + $(this).outerWidth(true) / 2) {
	                                        index += 1;
	                                    }
	                                    sumWidth += $(this).outerWidth(true);
	                                });
	                                if (index !== tileIndex) {
	                                    tileIndex = index;
	                                    if (index === 0) {
	                                        placeholder.prependTo(list);
	                                        $(tile).prependTo(list);
	                                    } else {
	                                        placeholder.detach();
	                                        $(tile).detach();
	                                        var preceeding = list.find("li")[index - 1];
	                                        placeholder.insertAfter(preceeding);
	                                        $(tile).insertAfter(preceeding);
	                                    }
	                                }
	                            } else if (event.type === "vmouseup") {
	                                $(document).unbind(".tile");
	                                var position = $(tile).offset();
	                                $(position).animate(placeholder.offset(), {
	                                    duration: 150,
	                                    step: function(now, fx) {
	                                        position[fx.prop] = now;
	                                        $(tile).offset(position);
	                                    },
	                                    complete: function() {
	                                        $(tile).css("z-index", 0);
	                                        placeholder.detach();
	                                        $(tile).css({ position: "static" });
	                                        $(tile).removeClass("dragging");
	                                    }
	                                });
	                            }
	                        });
	                    }
	                });
	            });
	        };

	        sorter.getContent = function() {
	            var content = [];
	            list.find("li").each(function(tileNum, tile) {
	                content.push($.trim($(tile).find(".sort-key").text()));
	            });
	            return content;
	        };

	        sorter.setContent = function(content) {
	            var tiles = [];
	            $.each(content, function(n, sortKey) {
	                var tile = list.find("li .sort-key").filter(function() {
	                    // sort-key must match exactly
	                    return $(this).text() === sortKey;
	                }).closest("li").get(0);
	                $(tile).detach();  // remove matched tile so you can have duplicates
	                tiles.push(tile);
	            });
	            list.append(tiles);
	        };


	        return sorter;
	    },

	    // Useful for shapes that are only sometimes drawn. If a shape isn't
	    // needed, it can be replaced with bogusShape which just has stub methods
	    // that successfully do nothing.
	    // The alternative would be 'if..typeof' checks all over the place.
	    bogusShape: {
	        animate: function() {},
	        attr: function() {},
	        remove: function() {}
	    }
	});

	$.extend(KhanUtil.Graphie.prototype, {
	    // Wrap graphInit to create a fixed-size graph automatically scaled to the given range
	    initAutoscaledGraph: function(range, options) {
	        var graph = this;
	        options = $.extend({
	            xpixels: 500,
	            ypixels: 500,
	            xdivisions: 20,
	            ydivisions: 20,
	            labels: true,
	            unityLabels: true,
	            range: (range === undefined ? [[-10, 10], [-10, 10]] : range)
	        }, options);

	        options.scale = [
	            options.xpixels / (options.range[0][1] - options.range[0][0]),
	            options.ypixels / (options.range[1][1] - options.range[1][0])
	        ];
	        options.gridStep = [
	            (options.range[0][1] - options.range[0][0]) / options.xdivisions,
	            (options.range[1][1] - options.range[1][0]) / options.ydivisions
	        ];

	        // Attach the resulting metrics to the graph for later reference
	        graph.xpixels = options.xpixels;
	        graph.ypixels = options.ypixels;
	        graph.range = options.range;
	        graph.scale = options.scale;

	        graph.graphInit(options);
	    },

	    // graphie puts text spans on top of the SVG, which looks good, but gets
	    // in the way of mouse events. This adds another SVG element on top
	    // of everything else where we can add invisible shapes with mouse
	    // handlers wherever we want.
	    addMouseLayer: function(options) {
	        var graph = this;
	        options = _.extend({
	            allowScratchpad: false
	        }, options);

	        graph.mouselayer = Raphael(graph.raphael.canvas.parentNode, graph.xpixels, graph.ypixels);
	        $(graph.mouselayer.canvas).css("z-index", 2);
	        if (options.onClick || options.onMouseDown || options.onMouseMove ||
	                options.onMouseOver || options.onMouseOut) {
	            var canvasClickTarget = graph.mouselayer.rect(
	                    0, 0, graph.xpixels, graph.ypixels).attr({
	                fill: "#000",
	                opacity: 0
	            });
	            var isClickingCanvas = false;

	            $(graph.mouselayer.canvas).on("vmousedown", function(e) {
	                if (e.target === canvasClickTarget[0]) {
	                    if (options.onMouseDown) {
	                        options.onMouseDown(graph.getMouseCoord(e));
	                    }
	                    isClickingCanvas = true;

	                    if (options.onMouseMove) {
	                        $(document).bind("vmousemove.mouseLayer", function(e) {
	                            if (isClickingCanvas) {
	                                e.preventDefault();
	                                options.onMouseMove(graph.getMouseCoord(e));
	                            }
	                        });
	                    }

	                    $(document).bind("vmouseup.mouseLayer", function(e) {
	                        $(document).unbind(".mouseLayer");

	                        // Only register clicks that started on the canvas, and not
	                        // on another mouseLayer target
	                        if (isClickingCanvas && options.onClick) {
	                            options.onClick(graph.getMouseCoord(e));
	                        }
	                        isClickingCanvas = false;
	                    });
	                }
	            });
	            if (options.onMouseOver) {
	                $(graph.mouselayer.canvas).on("vmouseover", function(e) {
	                    options.onMouseOver(graph.getMouseCoord(e));
	                });
	            }
	            if (options.onMouseOut) {
	                $(graph.mouselayer.canvas).on("vmouseout", function(e) {
	                    options.onMouseOut(graph.getMouseCoord(e));
	                });
	            }
	        }
	        if (!options.allowScratchpad) {
	            Khan.scratchpad.disable();
	        }
	    },

	    /**
	     * Get mouse coordinates in pixels
	     */
	    getMousePx: function(event) {
	        var graphie = this;

	        // mouse{X|Y} is in pixels relative to the SVG
	        var mouseX = event.pageX - $(graphie.raphael.
	            canvas.parentNode).offset().left;
	        var mouseY = event.pageY - $(graphie.raphael.
	            canvas.parentNode).offset().top;

	        return [mouseX, mouseY];
	    },

	    /**
	     * Get mouse coordinates in graph coordinates
	     */
	    getMouseCoord: function(event) {
	        return this.unscalePoint(this.getMousePx(event));
	    },

	    // Draw angle arcs
	    drawArcs: function(point1, vertex, point3, numArcs) {
	        var startAngle = KhanUtil.findAngle(point1, vertex);
	        var endAngle = KhanUtil.findAngle(point3, vertex);
	        if (((endAngle - startAngle) % 360 + 360) % 360 > 180) {
	            var temp = startAngle;
	            startAngle = endAngle;
	            endAngle = temp;
	        }

	        var radius = 0.3;
	        // smaller angles need a bigger radius
	        if ((((endAngle - startAngle) % 360 + 360) % 360) < 75) {
	            radius = (-0.6 / 90) * (((endAngle - startAngle) % 360 + 360) % 360) + 0.8;
	        }

	        var arcset = [];
	        for (var arc = 0; arc < numArcs; ++arc) {
	            arcset.push(this.arc(vertex, radius + (0.15 * arc), startAngle, endAngle));
	        }
	        return arcset;
	    },

	    /**
	     * Unlike all other Graphie-related code, the following three functions use
	     * a lot of scaled coordinates (so that labels appear the same size
	     * regardless of current shape/figure scale). These are prefixed with 's'.
	     */
	    labelAngle: function(options) {
	        var graphie = this;

	        _.defaults(options, {
	            point1: [0, 0],
	            vertex: [0, 0],
	            point3: [0, 0],
	            label: null,
	            numArcs: 1,
	            showRightAngleMarker: true,
	            pushOut: 0,
	            clockwise: false,
	            style: {}
	        });

	        // Allow null text to hide the 90 degree angle marker
	        var text = (options.text === undefined) ? "" : options.text;

	        var vertex = options.vertex;
	        var sVertex = graphie.scalePoint(vertex);

	        var p1, p3;
	        if (options.clockwise) {
	            p1 = options.point1;
	            p3 = options.point3;
	        } else {
	            p1 = options.point3;
	            p3 = options.point1;
	        }

	        // TODO(alex): more spacing if >= 100 degrees (due to +1 character)
	        // also take into account angle vs. text orientation, if possible

	        // Calculate angles
	        var startAngle = KhanUtil.findAngle(p1, vertex);
	        var endAngle = KhanUtil.findAngle(p3, vertex);
	        var angle = (endAngle + 360 - startAngle) % 360;
	        var halfAngle = (startAngle + angle / 2) % 360;

	        // Calculate distance from angle
	        var sPadding = 5 * options.pushOut;
	        var sRadius = sPadding + scaledDistanceFromAngle(angle);

	        var temp = [];

	        if (Math.abs(angle - 90) < 1e-9 && options.showRightAngleMarker) {
	            // Draw right angle box
	            var v1 = addPoints(sVertex, scaledPolarDeg(sRadius, startAngle));
	            var v2 = addPoints(sVertex, scaledPolarDeg(sRadius, endAngle));

	            sRadius *= Math.SQRT2;
	            var v3 = addPoints(sVertex, scaledPolarDeg(sRadius, halfAngle));

	            _.each([v1, v2], function(v) {
	                temp.push(graphie.scaledPath([v, v3], options.style));
	            });
	        } else {
	            // Draw arcs
	            _.times(options.numArcs, function(i) {
	                temp.push(graphie.arc(
	                    vertex,
	                    graphie.unscaleVector(sRadius),
	                    startAngle,
	                    endAngle,
	                    options.style
	                ));
	                sRadius += 3;
	            });
	        }

	        if (text) {
	            // Update label text

	            // Substitute actual angle measure for "$deg"
	            var match = text.match(/\$deg(\d)?/);
	            if (match) {
	                var precision = match[1] || 1;
	                text = text.replace(
	                    match[0],
	                    KhanUtil.toFixedApprox(angle, precision) + "^{\\circ}"
	                );
	            }

	            // Calculate label position
	            var sOffset = scaledPolarDeg(sRadius + 15, halfAngle);
	            var sPosition = addPoints(sVertex, sOffset);
	            var position = graphie.unscalePoint(sPosition);

	            // Reuse label if possible
	            if (options.label) {
	                options.label.setPosition(position);
	                options.label.processMath(text, /* force */ true);
	            } else {
	                graphie.label(position, text, "center", options.style);
	            }
	        }

	        return temp;
	    },

	    labelSide: function(options) {
	        var graphie = this;

	        _.defaults(options, {
	            point1: [0, 0],
	            point2: [0, 0],
	            label: null,
	            text: "",
	            numTicks: 0,
	            numArrows: 0,
	            clockwise: false,
	            style: {}
	        });

	        var p1, p2;
	        if (options.clockwise) {
	            p1 = options.point1;
	            p2 = options.point2;
	        } else {
	            p1 = options.point2;
	            p2 = options.point1;
	        }

	        var midpoint = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
	        var sMidpoint = graphie.scalePoint(midpoint);

	        var parallelAngle = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]);
	        var perpendicularAngle = parallelAngle + Math.PI / 2;

	        var temp = [];
	        var sCumulativeOffset = 0;

	        if (options.numTicks) {
	            // Draw ticks
	            var n = options.numTicks;

	            var sSpacing = 5;
	            var sHeight = 5;

	            var style = _.extend({}, options.style, {
	                strokeWidth: 2
	            });

	            _.times(n, function(i) {
	                var sOffset = sSpacing * (i - (n - 1) / 2);

	                var sOffsetVector = scaledPolarRad(sOffset, parallelAngle);
	                var sHeightVector = scaledPolarRad(sHeight, perpendicularAngle);

	                var sPath = [
	                    addPoints(sMidpoint, sOffsetVector, sHeightVector),
	                    addPoints(sMidpoint, sOffsetVector,
	                              reverseVector(sHeightVector))
	                ];

	                temp.push(graphie.scaledPath(sPath, style));
	            });

	            sCumulativeOffset += sSpacing * (n - 1) + 15;
	        }

	        if (options.numArrows) {
	            // Draw arrows
	            var n = options.numArrows;

	            // Arrows always point up, unless horizontal (if so, point right)
	            var start = [p1, p2].sort(function(a, b) {
	                if (a[1] === b[1]) {
	                    return a[0] - b[0];
	                } else {
	                    return a[1] - b[1];
	                }
	            })[0];
	            var sStart = graphie.scalePoint(start);

	            var style = _.extend({}, options.style, {
	                arrows: "->",
	                strokeWidth: 2
	            });

	            var sSpacing = 5;

	            _.times(n, function(i) {
	                var sOffset = sCumulativeOffset + sSpacing * i;
	                var sOffsetVector = scaledPolarRad(sOffset, parallelAngle);

	                if (start !== p1) {
	                    sOffsetVector = reverseVector(sOffsetVector);
	                }

	                var sEnd = addPoints(sMidpoint, sOffsetVector);

	                temp.push(graphie.scaledPath([sStart, sEnd], style));
	            });
	        }

	        var text = options.text;
	        if (text) {
	            // Update label text

	            // Substitute actual side length for "$len"
	            var match = text.match(/\$len(\d)?/);
	            if (match) {
	                var distance = KhanUtil.getDistance(p1, p2);
	                var precision = match[1] || 1;
	                text = text.replace(
	                    match[0],
	                    KhanUtil.toFixedApprox(distance, precision)
	                );
	            }

	            // Calculate label position

	            // distance needs to take into account length of label
	            // and perhaps orientation, to be smart about it
	            var sOffset = 20;
	            var sOffsetVector = scaledPolarRad(sOffset, perpendicularAngle);
	            var sPosition = addPoints(sMidpoint, sOffsetVector);
	            var position = graphie.unscalePoint(sPosition);

	            // Reuse label if possible
	            if (options.label) {
	                options.label.setPosition(position);
	                options.label.processMath(text, /* force */ true);
	            } else {
	                graphie.label(position, text, "center", options.style);
	            }
	        }

	        return temp;
	    },

	    /* Can also be used to label points that aren't vertices */
	    labelVertex: function(options) {
	        var graphie = this;

	        _.defaults(options, {
	            point1: null,
	            vertex: [0, 0],
	            point3: null,
	            label: null,
	            text: "",
	            clockwise: false,
	            style: {}
	        });

	        if (!options.text) {
	            return;
	        }

	        var vertex = options.vertex;
	        var sVertex = graphie.scalePoint(vertex);

	        var p1, p3;
	        if (options.clockwise) {
	            p1 = options.point1;
	            p3 = options.point3;
	        } else {
	            p1 = options.point3;
	            p3 = options.point1;
	        }

	        // Calculate label angle relative to vertex
	        var angle = 135;
	        var halfAngle;
	        if (p1 && p3) {
	            // Point within a polygon
	            var startAngle = KhanUtil.findAngle(p1, vertex);
	            var endAngle = KhanUtil.findAngle(p3, vertex);
	            angle = (endAngle + 360 - startAngle) % 360;
	            halfAngle = (startAngle + angle / 2 + 180) % 360;
	        } else if (p1) {
	            // Point on a line/segment
	            var parallelAngle = KhanUtil.findAngle(vertex, p1);
	            halfAngle = parallelAngle + 90;
	        } else if (p3) {
	            var parallelAngle = KhanUtil.findAngle(p3, vertex);
	            halfAngle = parallelAngle + 90;
	        } else {
	            // Standalone point
	            halfAngle = 135;
	        }

	        // Calculate label position
	        var sRadius = 10 + scaledDistanceFromAngle(360 - angle);
	        var sOffsetVector = scaledPolarDeg(sRadius, halfAngle);
	        var sPosition = addPoints(sVertex, sOffsetVector);
	        var position = graphie.unscalePoint(sPosition);

	        // Reuse label if possible
	        if (options.label) {
	            options.label.setPosition(position);
	            options.label.processMath(options.text, /* force */ true);
	        } else {
	            graphie.label(position, options.text, "center", options.style);
	        }
	    },


	    // Add a point to the graph that can be dragged around.
	    // It allows automatic constraints on its movement as well as automatically
	    // managing line segments that terminate at the point.
	    //
	    // Options can be set to control how the point behaves:
	    //   coord[]:
	    //     The initial position of the point
	    //   snapX, snapY:
	    //     The minimum increment the point can be moved
	    //
	    // The return value is an object that can be used to manipulate the point:
	    //   The coordX and coordY properties tell you the current position
	    //
	    //   By adding an onMove() method to the returned object, you can install an
	    //   event handler that gets called every time the user moves the point.
	    //
	    //   The returned object also provides a moveTo(x,y) method that will move
	    //   the point to a specific coordinate
	    //
	    // Constraints can be set on the on the returned object:
	    //
	    //  - Set point to be immovable:
	    //        movablePoint.constraints.fixed = true
	    //
	    //  - Constrain point to a fixed distance from another point. The resulting
	    //    point will move in a circle:
	    //        movablePoint.fixedDistance = {
	    //           dist: 2,
	    //           point: point1
	    //        }
	    //
	    //  - Constrain point to a line defined by a fixed angle between it and
	    //    two other points:
	    //        movablePoint.fixedAngle = {
	    //           angle: 45,
	    //           vertex: point1,
	    //           ref: point2
	    //        }
	    //
	    //  - Confined the point to traveling in a vertical or horizontal line,
	    //    respectively
	    //        movablePoint.constrainX = true;
	    //        movablePoint.constrainY = true;
	    //
	    //  - Connect a movableLineSegment to a movablePoint. The point is attached
	    //    to a specific end of the line segment by adding the segment either to
	    //    the list of lines that start at the point or the list of lines that
	    //    end at the point (movableLineSegment can do this for you):
	    //        movablePoint.lineStarts.push(movableLineSegment);
	    //          - or -
	    //        movablePoint.lineEnds.push(movableLineSegment);
	    //
	    //  - Connect a movablePolygon to a movablePoint in exacty the same way:
	    //        movablePoint.polygonVertices.push(movablePolygon);
	    //
	    addMovablePoint: function(options) {
	        // The state object that gets returned
	        var movablePoint = $.extend(true, {
	            graph: this,
	            coord: [0, 0],
	            snapX: 0,
	            snapY: 0,
	            pointSize: 4,
	            highlight: false,
	            dragging: false,
	            visible: true,
	            bounded: true,
	            constraints: {
	                fixed: false,
	                constrainX: false,
	                constrainY: false,
	                fixedAngle: {},
	                fixedDistance: {}
	            },
	            lineStarts: [],
	            lineEnds: [],
	            polygonVertices: [],
	            normalStyle: {},
	            highlightStyle: {
	                fill: KhanUtil.INTERACTING,
	                stroke: KhanUtil.INTERACTING
	            },
	            labelStyle: {
	                color: KhanUtil.INTERACTIVE
	            },
	            vertexLabel: "",
	            mouseTarget: null
	        }, options);

	        var normalColor = (movablePoint.constraints.fixed) ?
	                                  KhanUtil.DYNAMIC
	                                : KhanUtil.INTERACTIVE;
	        movablePoint.normalStyle = _.extend({}, {
	            "fill": normalColor,
	            "stroke": normalColor
	        }, options.normalStyle);

	        // deprecated: don't use coordX/coordY; use coord[]
	        if (options.coordX !== undefined) {
	            movablePoint.coord[0] = options.coordX;
	        }
	        if (options.coordY !== undefined) {
	            movablePoint.coord[1] = options.coordY;
	        }

	        var graph = movablePoint.graph;

	        var applySnapAndConstraints = function(coord) {
	            // coord should be the scaled coordinate

	            // move point away from edge of graph unless it's invisible or fixed
	            if (movablePoint.visible &&
	                    movablePoint.bounded &&
	                    !movablePoint.constraints.fixed) {
	                // can't go beyond 10 pixels from the edge
	                coord = graph.constrainToBounds(coord, 10);
	            }

	            var coordX = coord[0];
	            var coordY = coord[1];

	            // snap coordinates to grid
	            if (movablePoint.snapX !== 0) {
	                coordX = Math.round(coordX / movablePoint.snapX) * movablePoint.snapX;
	            }
	            if (movablePoint.snapY !== 0) {
	                coordY = Math.round(coordY / movablePoint.snapY) * movablePoint.snapY;
	            }

	            // snap to points around circle
	            if (movablePoint.constraints.fixedDistance.snapPoints) {
	                var mouse = graph.scalePoint(coord);
	                var mouseX = mouse[0];
	                var mouseY = mouse[1];

	                var snapRadians = 2 * Math.PI / movablePoint.constraints.fixedDistance.snapPoints;
	                var radius = movablePoint.constraints.fixedDistance.dist;

	                // get coordinates relative to the fixedDistance center
	                var centerCoord = movablePoint.constraints.fixedDistance.point;
	                var centerX = (centerCoord[0] - graph.range[0][0]) * graph.scale[0];
	                var centerY = (-centerCoord[1] + graph.range[1][1]) * graph.scale[1];

	                var mouseXrel = mouseX - centerX;
	                var mouseYrel = -mouseY + centerY;
	                var radians = Math.atan(mouseYrel / mouseXrel);
	                var outsideArcTanRange = mouseXrel < 0;

	                // adjust so that angles increase from 0 to 2 pi as you go around the circle
	                if (outsideArcTanRange) {
	                    radians += Math.PI;
	                }

	                // perform the snap
	                radians = Math.round(radians / snapRadians) * snapRadians;

	                // convert from radians back to pixels
	                mouseXrel = radius * Math.cos(radians);
	                mouseYrel = radius * Math.sin(radians);
	                // convert back to coordinates relative to graphie canvas
	                mouseX = mouseXrel + centerX;
	                mouseY = - mouseYrel + centerY;
	                coordX = KhanUtil.roundTo(5, mouseX / graph.scale[0] + graph.range[0][0]);
	                coordY = KhanUtil.roundTo(5, graph.range[1][1] - mouseY / graph.scale[1]);
	            }

	            // apply any constraints on movement
	            var result = movablePoint.applyConstraint([coordX, coordY]);
	            return result;
	        };

	        // Using the passed coordinates, apply any constraints and return the closest coordinates
	        // that match the constraints.
	        movablePoint.applyConstraint = function(coord, extraConstraints, override) {
	            var newCoord = coord.slice();
	            // use the configured constraints for the point plus any passed-in constraints; use only passed-in constraints if override is set
	            var constraints = {};
	            if (override) {
	                $.extend(constraints, {
	                    fixed: false,
	                    constrainX: false,
	                    constrainY: false,
	                    fixedAngle: {},
	                    fixedDistance: {}
	                }, extraConstraints);
	            } else {
	                $.extend(constraints, this.constraints, extraConstraints);
	            }

	            // constrain to vertical movement
	            if (constraints.constrainX) {
	                newCoord = [this.coord[0], coord[1]];

	            // constrain to horizontal movement
	            } else if (constraints.constrainY) {
	                newCoord = [coord[0], this.coord[1]];

	            // both distance and angle are constrained
	            } else if (typeof constraints.fixedAngle.angle === "number" && typeof constraints.fixedDistance.dist === "number") {
	                var vertex = constraints.fixedAngle.vertex.coord || constraints.fixedAngle.vertex;
	                var ref = constraints.fixedAngle.ref.coord || constraints.fixedAngle.ref;
	                var distPoint = constraints.fixedDistance.point.coord || constraints.fixedDistance.point;

	                var constrainedAngle = (constraints.fixedAngle.angle + KhanUtil.findAngle(ref, vertex)) * Math.PI / 180;
	                var length = constraints.fixedDistance.dist;
	                newCoord[0] = length * Math.cos(constrainedAngle) + distPoint[0];
	                newCoord[1] = length * Math.sin(constrainedAngle) + distPoint[1];

	            // angle is constrained
	            } else if (typeof constraints.fixedAngle.angle === "number") {
	                var vertex = constraints.fixedAngle.vertex.coord || constraints.fixedAngle.vertex;
	                var ref = constraints.fixedAngle.ref.coord || constraints.fixedAngle.ref;

	                // constrainedAngle is the angle from vertex to the point with reference to the screen
	                var constrainedAngle = (constraints.fixedAngle.angle + KhanUtil.findAngle(ref, vertex)) * Math.PI / 180;
	                // angle is the angle from vertex to the mouse with reference to the screen
	                var angle = KhanUtil.findAngle(coord, vertex) * Math.PI / 180;
	                var distance = KhanUtil.getDistance(coord, vertex);
	                var length = distance * Math.cos(constrainedAngle - angle);
	                length = length < 1.0 ? 1.0 : length;
	                newCoord[0] = length * Math.cos(constrainedAngle) + vertex[0];
	                newCoord[1] = length * Math.sin(constrainedAngle) + vertex[1];

	            // distance is constrained
	            } else if (typeof constraints.fixedDistance.dist === "number") {
	                var distPoint = constraints.fixedDistance.point.coord || constraints.fixedDistance.point;

	                var angle = KhanUtil.findAngle(coord, distPoint);
	                var length = constraints.fixedDistance.dist;
	                angle = angle * Math.PI / 180;
	                newCoord[0] = length * Math.cos(angle) + distPoint[0];
	                newCoord[1] = length * Math.sin(angle) + distPoint[1];

	            // point is fixed
	            } else if (constraints.fixed) {
	                newCoord = movablePoint.coord;
	            }
	            return newCoord;
	        };

	        movablePoint.coord = applySnapAndConstraints(movablePoint.coord);

	        if (movablePoint.visible) {
	            graph.style(movablePoint.normalStyle, function() {
	                movablePoint.visibleShape = graph.ellipse(movablePoint.coord, [movablePoint.pointSize / graph.scale[0], movablePoint.pointSize / graph.scale[1]]);
	            });
	        }
	        movablePoint.normalStyle.scale = 1;
	        movablePoint.highlightStyle.scale = 2;

	        if (movablePoint.vertexLabel) {
	            movablePoint.labeledVertex = this.label([0, 0], "", "center", movablePoint.labelStyle);
	        }

	        movablePoint.drawLabel = function() {
	            if (movablePoint.vertexLabel) {
	                movablePoint.graph.labelVertex({
	                    vertex: movablePoint.coord,
	                    label: movablePoint.labeledVertex,
	                    text: movablePoint.vertexLabel,
	                    style: movablePoint.labelStyle
	                });
	            }
	        };

	        movablePoint.drawLabel();

	        movablePoint.grab = function() {
	            $(document).bind("vmousemove.point vmouseup.point", function(event) {
	                event.preventDefault();
	                movablePoint.dragging = true;
	                KhanUtil.dragging = true;

	                var coord = graph.getMouseCoord(event);

	                coord = applySnapAndConstraints(coord);
	                var coordX = coord[0];
	                var coordY = coord[1];
	                var mouseX;
	                var mouseY;

	                if (event.type === "vmousemove") {
	                    var doMove = true;
	                    // The caller has the option of adding an onMove() method to the
	                    // movablePoint object we return as a sort of event handler
	                    // By returning false from onMove(), the move can be vetoed,
	                    // providing custom constraints on where the point can be moved.
	                    // By returning array [x, y], the move can be overridden
	                    if (_.isFunction(movablePoint.onMove)) {
	                        var result = movablePoint.onMove(coordX, coordY);
	                        if (result === false) {
	                            doMove = false;
	                        }
	                        if (_.isArray(result)) {
	                            coordX = result[0];
	                            coordY = result[1];
	                        }
	                    }
	                    // coord{X|Y} may have been modified by constraints or onMove handler; adjust mouse{X|Y} to match
	                    mouseX = (coordX - graph.range[0][0]) * graph.scale[0];
	                    mouseY = (-coordY + graph.range[1][1]) * graph.scale[1];

	                    if (doMove) {
	                        movablePoint.visibleShape.attr("cx", mouseX);
	                        movablePoint.mouseTarget.attr("cx", mouseX);
	                        movablePoint.visibleShape.attr("cy", mouseY);
	                        movablePoint.mouseTarget.attr("cy", mouseY);
	                        movablePoint.coord = [coordX, coordY];
	                        movablePoint.updateLineEnds();
	                        $(movablePoint).trigger("move");
	                    }

	                    movablePoint.drawLabel();

	                } else if (event.type === "vmouseup") {
	                    $(document).unbind(".point");
	                    movablePoint.dragging = false;
	                    KhanUtil.dragging = false;
	                    if (_.isFunction(movablePoint.onMoveEnd)) {
	                        var result = movablePoint.onMoveEnd(coordX, coordY);
	                        if (_.isArray(result)) {
	                            coordX = result[0];
	                            coordY = result[1];
	                            mouseX = (coordX - graph.range[0][0]) * graph.scale[0];
	                            mouseY = (-coordY + graph.range[1][1]) * graph.scale[1];
	                            movablePoint.visibleShape.attr("cx", mouseX);
	                            movablePoint.mouseTarget.attr("cx", mouseX);
	                            movablePoint.visibleShape.attr("cy", mouseY);
	                            movablePoint.mouseTarget.attr("cy", mouseY);
	                            movablePoint.coord = [coordX, coordY];
	                        }
	                    }
	                    if (!movablePoint.highlight) {
	                        movablePoint.visibleShape.animate(movablePoint.normalStyle, 50);
	                        if (movablePoint.onUnhighlight) {
	                            movablePoint.onUnhighlight();
	                        }
	                    }
	                }
	            });
	        };

	        if (movablePoint.visible && !movablePoint.constraints.fixed) {
	            // the invisible shape in front of the point that gets mouse events
	            if (!movablePoint.mouseTarget) {
	                movablePoint.mouseTarget = graph.mouselayer.circle(
	                    graph.scalePoint(movablePoint.coord)[0],
	                    graph.scalePoint(movablePoint.coord)[1],
	                    15
	                );
	                movablePoint.mouseTarget.attr({fill: "#000", "opacity": 0.0});
	            }

	            $(movablePoint.mouseTarget[0]).css("cursor", "move");
	            $(movablePoint.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function(event) {
	                if (event.type === "vmouseover") {
	                    movablePoint.highlight = true;
	                    if (!KhanUtil.dragging) {
	                        movablePoint.visibleShape.animate(movablePoint.highlightStyle, 50);
	                        if (movablePoint.onHighlight) {
	                            movablePoint.onHighlight();
	                        }
	                    }

	                } else if (event.type === "vmouseout") {
	                    movablePoint.highlight = false;
	                    if (!movablePoint.dragging && !KhanUtil.dragging) {
	                        movablePoint.visibleShape.animate(movablePoint.normalStyle, 50);
	                        if (movablePoint.onUnhighlight) {
	                            movablePoint.onUnhighlight();
	                        }
	                    }

	                } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
	                    event.preventDefault();

	                    movablePoint.grab();
	                }
	            });
	        }

	        // Method to let the caller animate the point to a new position. Useful
	        // as part of a hint to show the user the correct place to put the point.
	        movablePoint.moveTo = function(coordX, coordY, updateLines) {
	            // find distance in pixels to move
	            var distance = KhanUtil.getDistance(this.graph.scalePoint([coordX, coordY]), this.graph.scalePoint(this.coord));

	            // 5ms per pixel seems good
	            var time = distance * 5;

	            var scaled = graph.scalePoint([coordX, coordY]);
	            var end = { cx: scaled[0], cy: scaled[1] };
	            if (updateLines) {
	                var start = {
	                    cx: this.visibleShape.attr("cx"),
	                    cy: this.visibleShape.attr("cy")
	                };
	                $(start).animate(end, {
	                    duration: time,
	                    easing: "linear",
	                    step: function(now, fx) {
	                        movablePoint.visibleShape.attr(fx.prop, now);
	                        movablePoint.mouseTarget.attr(fx.prop, now);
	                        if (fx.prop === "cx") {
	                            movablePoint.coord[0] = now / graph.scale[0] + graph.range[0][0];
	                        } else {
	                            movablePoint.coord[1] = graph.range[1][1] - now / graph.scale[1];
	                        }
	                        movablePoint.updateLineEnds();
	                    }
	                });

	            } else {
	                this.visibleShape.animate(end, time);
	                this.mouseTarget.animate(end, time);
	            }
	            this.coord = [coordX, coordY];
	            if (_.isFunction(this.onMove)) {
	                this.onMove(coordX, coordY);
	            }
	        };


	        // After moving the point, call this to update all line segments terminating at the point
	        movablePoint.updateLineEnds = function() {
	            $(this.lineStarts).each(function() {
	                this.coordA = movablePoint.coord;
	                this.transform();
	            });
	            $(this.lineEnds).each(function() {
	                this.coordZ = movablePoint.coord;
	                this.transform();
	            });
	            $(this.polygonVertices).each(function() {
	                this.transform();
	            });
	        };

	        // Put the point at a new position without any checks, animation, or callbacks
	        movablePoint.setCoord = function(coord) {
	            if (this.visible) {
	                var scaledPoint = graph.scalePoint(coord);
	                this.visibleShape.attr({ cx: scaledPoint[0] });
	                this.visibleShape.attr({ cy: scaledPoint[1] });
	                if (this.mouseTarget != null) {
	                    this.mouseTarget.attr({ cx: scaledPoint[0] });
	                    this.mouseTarget.attr({ cy: scaledPoint[1] });
	                }
	            }
	            this.coord = coord.slice();
	        };

	        // Put the point at the new position, checking that it is within the graph's bounds
	        movablePoint.setCoordConstrained = function(coord) {
	            this.setCoord(applySnapAndConstraints(coord));
	        };

	        // Change z-order to back
	        movablePoint.toBack = function() {
	            if (this.visible) {
	                if (this.mouseTarget != null) {
	                    this.mouseTarget.toBack();
	                }
	                this.visibleShape.toBack();
	            }
	        };

	        // Change z-order to front
	        movablePoint.toFront = function() {
	            if (this.visible) {
	                if (this.mouseTarget != null) {
	                    this.mouseTarget.toFront();
	                }
	                this.visibleShape.toFront();
	            }
	        };

	        movablePoint.remove = function() {
	            if (this.visibleShape) {
	                this.visibleShape.remove();
	            }
	            if (this.mouseTarget) {
	                this.mouseTarget.remove();
	            }
	            if (this.labeledVertex) {
	                this.labeledVertex.remove();
	            }
	        };

	        return movablePoint;
	    },

	    // Plot a function that allows the user to mouse over points on the function.
	    // * currently, the function must be continuous
	    //
	    // The return value is an object:
	    //   By adding an onMove() method to the returned object, you can install an
	    //   event handler that gets called every time the user moves the mouse over
	    //   the function.
	    //
	    //   By adding an onLeave() method to the returned object, you can install an
	    //   event handler that gets called when the mouse moves away from the function.
	    //
	    addInteractiveFn: function(fn, options) {
	        var graph = this;
	        options = $.extend({
	            graph: graph,
	            snap: 0,
	            range: [graph.range[0][0], graph.range[0][1]]
	        }, options);
	        var interactiveFn = {
	            highlight: false
	        };

	        // Plot the function
	        graph.style({
	            stroke: KhanUtil.INTERACTIVE
	        }, function() {
	            interactiveFn.visibleShape = graph.plot(fn, options.range, options.swapAxes);
	        });

	        // Draw a circle that will be used to highlight the point on the function the mouse is closest to
	        graph.style({
	            fill: KhanUtil.INTERACTIVE,
	            stroke: KhanUtil.INTERACTIVE
	        }, function() {
	            interactiveFn.cursorPoint = graph.ellipse([0, fn(0)], [4 / graph.scale[0], 4 / graph.scale[1]]);
	        });
	        // Hide the point for now
	        interactiveFn.cursorPoint.attr("opacity", 0.0);

	        // We want the mouse target to be much wider than the line itself, so you don't
	        // have to hit a 2px target. Ideally, this would be done with an invisible
	        // line following the same path, but with a really big strokeWidth. That
	        // mostly works, but unfortunately there seem to be some bugs in Firefox
	        // where it gets a bit confused about whether the mouse is or isn't over
	        // a really thick curved line :(
	        //
	        // So instead, we have to use a polygon.
	        var mouseAreaWidth = 30;
	        var points = [];
	        var step = (options.range[1] - options.range[0]) / 100;

	        var addScaledPoint = function(x, y) {
	            if (options.swapAxes) {
	                points.push([(y - graph.range[0][0]) * graph.scale[0], (graph.range[1][1] - x) * graph.scale[1]]);
	            } else {
	                points.push([(x - graph.range[0][0]) * graph.scale[0], (graph.range[1][1] - y) * graph.scale[1]]);
	            }
	        };

	        // Draw a curve parallel to, but (mouseAreaWidth/2 pixels) above the function
	        for (var x = options.range[0]; x <= options.range[1]; x += step) {
	            var ddx = (fn(x - 0.001) - fn(x + 0.001)) / 0.002;
	            var x1 = x;
	            var y1 = fn(x) + (mouseAreaWidth / (2 * graph.scale[1]));

	            if (ddx !== 0) {
	                var normalslope = (-1 / (ddx * (graph.scale[1] / graph.scale[0]))) / (graph.scale[1] / graph.scale[0]);
	                if (ddx < 0) {
	                    x1 = x - Math.cos(-Math.atan(normalslope * (graph.scale[1] / graph.scale[0]))) * mouseAreaWidth / (2 * graph.scale[0]);
	                    y1 = normalslope * (x - x1) + fn(x);
	                } else if (ddx > 0) {
	                    x1 = x + Math.cos(-Math.atan(normalslope * (graph.scale[1] / graph.scale[0]))) * mouseAreaWidth / (2 * graph.scale[0]);
	                    y1 = normalslope * (x - x1) + fn(x);
	                }
	            }
	            addScaledPoint(x1, y1);
	        }
	        // Draw a curve parallel to, but (mouseAreaWidth/2 pixels) below the function
	        for (var x = options.range[1]; x >= options.range[0]; x -= step) {
	            var ddx = (fn(x - 0.001) - fn(x + 0.001)) / 0.002;
	            var x1 = x;
	            var y1 = fn(x) - (mouseAreaWidth / (2 * graph.scale[1]));

	            if (ddx !== 0) {
	                var normalslope = (-1 / (ddx * (graph.scale[1] / graph.scale[0]))) / (graph.scale[1] / graph.scale[0]);
	                if (ddx < 0) {
	                    x1 = x + Math.cos(-Math.atan(normalslope * (graph.scale[1] / graph.scale[0]))) * mouseAreaWidth / (2 * graph.scale[0]);
	                    y1 = normalslope * (x - x1) + fn(x);
	                } else if (ddx > 0) {
	                    x1 = x - Math.cos(-Math.atan(normalslope * (graph.scale[1] / graph.scale[0]))) * mouseAreaWidth / (2 * graph.scale[0]);
	                    y1 = normalslope * (x - x1) + fn(x);
	                }
	            }
	            addScaledPoint(x1, y1);
	        }

	        // plot the polygon and make it invisible
	        interactiveFn.mouseTarget = graph.mouselayer.path(KhanUtil.unscaledSvgPath(points));
	        interactiveFn.mouseTarget.attr({ fill: "#000", "opacity": 0.0 });

	        // Add mouse handlers to the polygon
	        $(interactiveFn.mouseTarget[0]).bind("vmouseover vmouseout vmousemove", function(event) {
	            event.preventDefault();
	            var mouseX = event.pageX - $(graph.raphael.canvas.parentNode).offset().left;
	            var mouseY = event.pageY - $(graph.raphael.canvas.parentNode).offset().top;
	            // can't go beyond 10 pixels from the edge
	            mouseX = Math.max(10, Math.min(graph.xpixels - 10, mouseX));
	            mouseY = Math.max(10, Math.min(graph.ypixels - 10, mouseY));
	            // snap to grid
	            if (options.snap) {
	                mouseX = Math.round(mouseX / (graph.scale[0] * options.snap)) * (graph.scale[0] * options.snap);
	            }
	            // coord{X|Y} are the scaled coordinate values
	            var coordX = mouseX / graph.scale[0] + graph.range[0][0];
	            var coordY = graph.range[1][1] - mouseY / graph.scale[1];

	            // Find the closest point on the curve to the mouse (by brute force)
	            var findDistance = function(coordX, coordY) {
	                var closestX = 0;
	                var minDist = Math.sqrt((coordX) * (coordX) + (coordY) * (coordY));
	                for (var x = options.range[0]; x < options.range[1]; x += ((options.range[1] - options.range[0]) / graph.xpixels)) {
	                    if (Math.sqrt((x - coordX) * (x - coordX) + (fn(x) - coordY) * (fn(x) - coordY)) < minDist) {
	                        closestX = x;
	                        minDist = Math.sqrt((x - coordX) * (x - coordX) + (fn(x) - coordY) * (fn(x) - coordY));
	                    }
	                }
	                return closestX;
	            };

	            if (options.swapAxes) {
	                var closestX = findDistance(coordY, coordX);
	                coordX = fn(closestX);
	                coordY = closestX;
	            } else {
	                var closestX = findDistance(coordX, coordY);
	                coordX = closestX;
	                coordY = fn(closestX);
	            }

	            interactiveFn.cursorPoint.attr("cx", (graph.range[0][1] + coordX) * graph.scale[0]);
	            interactiveFn.cursorPoint.attr("cy", (graph.range[1][1] - coordY) * graph.scale[1]);

	            // If the caller wants to be notified when the user points to the function
	            if (_.isFunction(interactiveFn.onMove)) {
	                interactiveFn.onMove(coordX, coordY);
	            }

	            if (event.type === "vmouseover") {
	                interactiveFn.cursorPoint.animate({ opacity: 1.0 }, 50);
	                interactiveFn.highlight = true;

	            } else if (event.type === "vmouseout") {
	                interactiveFn.highlight = false;
	                interactiveFn.cursorPoint.animate({ opacity: 0.0 }, 50);
	                // If the caller wants to be notified when the user stops pointing to the function
	                if (_.isFunction(interactiveFn.onLeave)) {
	                    interactiveFn.onLeave(coordX, coordY);
	                }
	            }
	        });

	        interactiveFn.mouseTarget.toBack();
	        return interactiveFn;
	    },


	    // MovableLineSegment is a line segment that can be dragged around the
	    // screen. By attaching a smartPoint to each (or one) end, the ends can be
	    // manipulated individually.
	    //
	    // To use with smartPoints, add the smartPoints first, then:
	    //   addMovableLineSegment({ pointA: smartPoint1, pointZ: smartPoint2 });
	    // Or just one end:
	    //   addMovableLineSegment({ pointA: smartPoint, coordZ: [0, 0] });
	    //
	    // Include "fixed: true" in the options if you don't want the entire line
	    // to be draggable (you can still use points to make the endpoints
	    // draggable)
	    //
	    // The returned object includes the following properties/methods:
	    //
	    //   - lineSegment.coordA / lineSegment.coordZ
	    //         The coordinates of each end of the line segment
	    //
	    //   - lineSegment.transform(syncToPoints)
	    //         Repositions the line segment. Call after changing coordA and/or
	    //         coordZ, or pass syncToPoints = true to use the current position
	    //         of the corresponding smartPoints, if the segment was defined using
	    //         smartPoints
	    //
	    addMovableLineSegment: function(options) {
	        var lineSegment = $.extend({
	            graph: this,
	            coordA: [0, 0],
	            coordZ: [1, 1],
	            snapX: 0,
	            snapY: 0,
	            fixed: false,
	            ticks: 0,
	            normalStyle: {},
	            highlightStyle: {
	                "stroke": KhanUtil.INTERACTING,
	                "stroke-width": 6
	            },
	            labelStyle: {
	                "stroke": KhanUtil.INTERACTIVE,
	                "color": KhanUtil.INTERACTIVE
	            },
	            highlight: false,
	            dragging: false,
	            tick: [],
	            extendLine: false,
	            extendRay: false,
	            constraints: {
	                fixed: false,
	                constrainX: false,
	                constrainY: false
	            },
	            sideLabel: "",
	            vertexLabels: [],
	            numArrows: 0,
	            numTicks: 0,
	            movePointsWithLine: false
	        }, options);

	        var normalColor = (lineSegment.fixed) ? KhanUtil.DYNAMIC
	                                              : KhanUtil.INTERACTIVE;
	        lineSegment.normalStyle = _.extend({}, {
	            "stroke-width": 2,
	            "stroke": normalColor
	        }, options.normalStyle);
	        // arrowStyle should be kept in sync with styling of the line
	        lineSegment.arrowStyle = _.extend({}, lineSegment.normalStyle, {
	            "color": lineSegment.normalStyle.stroke
	        });

	        // If the line segment is defined by movablePoints, coordA/coordZ are
	        // owned by the points, otherwise they're owned by us
	        if (options.pointA !== undefined) {
	            lineSegment.coordA = options.pointA.coord;
	            lineSegment.pointA.lineStarts.push(lineSegment);
	        } else if (options.coordA !== undefined) {
	            lineSegment.coordA = options.coordA.slice();
	        }

	        if (options.pointZ !== undefined) {
	            lineSegment.coordZ = options.pointZ.coord;
	            lineSegment.pointZ.lineEnds.push(lineSegment);
	        } else if (options.coordA !== undefined) {
	            lineSegment.coordA = lineSegment.coordA.slice();
	        }

	        var graph = lineSegment.graph;

	        graph.style(lineSegment.normalStyle);
	        for (var i = 0; i < lineSegment.ticks; ++i) {
	            lineSegment.tick[i] = KhanUtil.bogusShape;
	        }
	        var path = KhanUtil.unscaledSvgPath([[0, 0], [1, 0]]);
	        for (var i = 0; i < lineSegment.ticks; ++i) {
	            var tickoffset = 0.5 - ((lineSegment.ticks - 1) + (i * 2)) / graph.scale[0];
	            path += KhanUtil.unscaledSvgPath([[tickoffset, -7], [tickoffset, 7]]);
	        }
	        lineSegment.visibleLine = graph.raphael.path(path);
	        lineSegment.visibleLine.attr(lineSegment.normalStyle);
	        // Clip the line 5px from the edge of the graphie to allow for
	        // arrowheads
	        if (lineSegment.extendLine || lineSegment.extendRay) {
	            lineSegment.visibleLine.attr({
	                "clip-rect": "5 5 " + (graph.dimensions[0] - 10) + " " +
	                    (graph.dimensions[1] - 10)
	            });
	        }
	        if (!lineSegment.fixed) {
	            lineSegment.mouseTarget = graph.mouselayer.rect(0, -15, 1, 30);
	            lineSegment.mouseTarget.attr({fill: "#000", "opacity": 0.0});
	        }

	        // Reposition the line segment. Call after changing coordA and/or
	        // coordZ, or pass syncToPoints = true to use the current position of
	        // the corresponding movablePoints, if the segment was defined using
	        // movablePoints
	        lineSegment.transform = function(syncToPoints) {
	            if (syncToPoints) {
	                if (typeof this.pointA === "object") {
	                    this.coordA = this.pointA.coord;
	                }
	                if (typeof this.pointZ === "object") {
	                    this.coordZ = this.pointZ.coord;
	                }
	            }
	            var scaledA = graph.scalePoint(this.coordA);
	            var scaledZ = graph.scalePoint(this.coordZ);
	            var angle = KhanUtil.findAngle(scaledZ, scaledA);
	            var lineLength = KhanUtil.getDistance(scaledZ, scaledA);

	            var elements = [this.visibleLine];
	            if (!this.fixed) {
	                elements.push(this.mouseTarget);
	            }
	            _.each(elements, function(element) {
	                element.translate(scaledA[0] - element.attr("translation").x,
	                        scaledA[1] - element.attr("translation").y);
	                element.rotate(angle, scaledA[0], scaledA[1]);
	                if (this.extendLine) {
	                    element.translate(-0.5, 0);
	                    lineLength = graph.dimensions[0] + graph.dimensions[1];
	                    lineLength = 2 * lineLength;
	                } else if (this.extendRay) {
	                    lineLength = graph.dimensions[0] + graph.dimensions[1];
	                }
	                element.scale(lineLength, 1, scaledA[0], scaledA[1]);
	            }, this);

	            // Temporary objects: array of SVG nodes that get recreated on drag
	            _.invoke(this.temp, "remove");
	            this.temp = [];

	            // Given `coord` and `angle`, find the point where a line extended
	            // from `coord` in the direction of `angle` would be clipped by the
	            // edge of the graphie canvas. Then draw an arrowhead at that point
	            // pointing in the direction of `angle`.
	            var drawArrowAtClipPoint = function(coord, angle) {
	                var graph = lineSegment.graph;
	                // Actually put the arrowheads 4px from the edge so they have
	                // a bit of room
	                var xExtent = graph.range[0][1] - graph.range[0][0];
	                var yExtent = graph.range[1][1] - graph.range[1][0];

	                // shoot a point off into the distance ...
	                var distance = xExtent + yExtent;
	                // we need to scale the point according to the scale of the axes
	                var angleVec = graph.unscaleVector(
	                    kvector.cartFromPolarDeg([1, angle])
	                );
	                var distVec = kvector.scale(
	                    kvector.normalize(angleVec),
	                    distance
	                );
	                var farCoord = kvector.add(coord, distVec);
	                var scaledAngle = kvector.polarDegFromCart(angleVec)[1];
	                // ... and then bring it back
	                var clipPoint = graph.constrainToBoundsOnAngle(farCoord, 4,
	                                              scaledAngle * Math.PI / 180);
	                clipPoint = graph.scalePoint(clipPoint);

	                var arrowHead = graph.raphael.path("M-3 4 C-2.75 2.5 0 0.25 0.75 0C0 -0.25 -2.75 -2.5 -3 -4");
	                arrowHead.rotate(360 - angle, 0.75, 0)
	                    .scale(1.4, 1.4, 0.75, 0)
	                    .translate(clipPoint[0], clipPoint[1])
	                    .attr(lineSegment.arrowStyle)
	                    .attr({ "stroke-linejoin": "round", "stroke-linecap": "round", "stroke-dasharray": "" });

	                return arrowHead;
	            };

	            if (this.extendLine) {
	                this.temp.push(drawArrowAtClipPoint(this.coordA, 360 - angle));
	                this.temp.push(drawArrowAtClipPoint(this.coordZ, (540 - angle) % 360));
	            } else if (this.extendRay) {
	                this.temp.push(drawArrowAtClipPoint(this.coordA, 360 - angle));
	            }

	            // Labels are always above line, unless vertical (if so, on right)
	            // probably want to add an option to flip this at will!
	            var isClockwise = (this.coordA[0] < this.coordZ[0]) ||
	                (this.coordA[0] === this.coordZ[0] &&
	                this.coordA[1] > this.coordZ[1]);

	            // Update side label
	            if (this.sideLabel) {
	                this.temp.push(this.graph.labelSide({
	                    point1: this.coordA,
	                    point2: this.coordZ,
	                    label: this.labeledSide,
	                    text: this.sideLabel,
	                    numArrows: this.numArrows,
	                    numTicks: this.numTicks,
	                    clockwise: isClockwise,
	                    style: this.labelStyle
	                }));
	            }

	            // Update vertex labels
	            if (this.vertexLabels.length) {
	                this.graph.labelVertex({
	                    vertex: this.coordA,
	                    point3: this.coordZ,
	                    label: this.labeledVertices[0],
	                    text: this.vertexLabels[0],
	                    clockwise: isClockwise,
	                    style: this.labelStyle
	                });

	                this.graph.labelVertex({
	                    point1: this.coordA,
	                    vertex: this.coordZ,
	                    label: this.labeledVertices[1],
	                    text: this.vertexLabels[1],
	                    clockwise: isClockwise,
	                    style: this.labelStyle
	                });
	            }

	            this.temp = _.flatten(this.temp);
	        };

	        // Change z-order to back;
	        lineSegment.toBack = function() {
	            if (!lineSegment.fixed) {
	                lineSegment.mouseTarget.toBack();
	            }
	            lineSegment.visibleLine.toBack();
	        };

	        // Change z-order to front
	        lineSegment.toFront = function() {
	            if (!lineSegment.fixed) {
	                lineSegment.mouseTarget.toFront();
	            }
	            lineSegment.visibleLine.toFront();
	        };

	        lineSegment.remove = function() {
	            if (!lineSegment.fixed) {
	                lineSegment.mouseTarget.remove();
	            }
	            lineSegment.visibleLine.remove();
	            if (lineSegment.labeledSide) {
	                lineSegment.labeledSide.remove();
	            }
	            if (lineSegment.labeledVertices) {
	                _.invoke(lineSegment.labeledVertices, "remove");
	            }
	            if (lineSegment.temp.length) {
	                _.invoke(lineSegment.temp, "remove");
	            }
	        };

	        lineSegment.hide = function() {
	            lineSegment.visibleLine.hide();
	            if (lineSegment.temp.length) {
	                _.invoke(lineSegment.temp, "hide");
	            }
	        };

	        lineSegment.show = function() {
	            lineSegment.visibleLine.show();
	            if (lineSegment.temp.length) {
	                _.invoke(lineSegment.temp, "show");
	            }
	        };

	        if (lineSegment.sideLabel) {
	            lineSegment.labeledSide = this.label([0, 0], "", "center", lineSegment.labelStyle);
	        }

	        if (lineSegment.vertexLabels.length) {
	            lineSegment.labeledVertices = _.map(lineSegment.vertexLabels, function(label) {
	                return this.label([0, 0], "", "center", lineSegment.labelStyle);
	            }, this);
	        }

	        if (!lineSegment.fixed && !lineSegment.constraints.fixed) {
	            $(lineSegment.mouseTarget[0]).css("cursor", "move");
	            $(lineSegment.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function(event) {
	                if (event.type === "vmouseover") {
	                    if (!KhanUtil.dragging) {
	                        lineSegment.highlight = true;
	                        lineSegment.visibleLine.animate(lineSegment.highlightStyle, 50);
	                        lineSegment.arrowStyle = _.extend({}, lineSegment.arrowStyle, {
	                            "color": lineSegment.highlightStyle.stroke,
	                            "stroke": lineSegment.highlightStyle.stroke
	                        });
	                        lineSegment.transform();
	                    }

	                } else if (event.type === "vmouseout") {
	                    lineSegment.highlight = false;
	                    if (!lineSegment.dragging) {
	                        lineSegment.visibleLine.animate(lineSegment.normalStyle, 50);
	                        lineSegment.arrowStyle = _.extend({}, lineSegment.arrowStyle, {
	                            "color": lineSegment.normalStyle.stroke,
	                            "stroke": lineSegment.normalStyle.stroke
	                        });
	                        lineSegment.transform();
	                    }

	                } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
	                    event.preventDefault();
	                    // coord{X|Y} are the scaled coordinate values of the mouse position
	                    var coordX = (event.pageX - $(graph.raphael.canvas.parentNode).offset().left) / graph.scale[0] + graph.range[0][0];
	                    var coordY = graph.range[1][1] - (event.pageY - $(graph.raphael.canvas.parentNode).offset().top) / graph.scale[1];
	                    if (lineSegment.snapX > 0) {
	                        coordX = Math.round(coordX / lineSegment.snapX) * lineSegment.snapX;
	                    }
	                    if (lineSegment.snapY > 0) {
	                        coordY = Math.round(coordY / lineSegment.snapY) * lineSegment.snapY;
	                    }
	                    // Offsets between the mouse and each end of the line segment
	                    var mouseOffsetA = [lineSegment.coordA[0] - coordX, lineSegment.coordA[1] - coordY];
	                    var mouseOffsetZ = [lineSegment.coordZ[0] - coordX, lineSegment.coordZ[1] - coordY];

	                    // Figure out how many pixels of the bounding box of the line segment lie to each direction of the mouse
	                    var offsetLeft = -Math.min(graph.scaleVector(mouseOffsetA)[0], graph.scaleVector(mouseOffsetZ)[0]);
	                    var offsetRight = Math.max(graph.scaleVector(mouseOffsetA)[0], graph.scaleVector(mouseOffsetZ)[0]);
	                    var offsetTop = Math.max(graph.scaleVector(mouseOffsetA)[1], graph.scaleVector(mouseOffsetZ)[1]);
	                    var offsetBottom = -Math.min(graph.scaleVector(mouseOffsetA)[1], graph.scaleVector(mouseOffsetZ)[1]);

	                    $(document).bind("vmousemove.lineSegment vmouseup.lineSegment", function(event) {
	                        event.preventDefault();
	                        lineSegment.dragging = true;
	                        KhanUtil.dragging = true;

	                        // mouse{X|Y} are in pixels relative to the SVG
	                        var mouseX = event.pageX - $(graph.raphael.canvas.parentNode).offset().left;
	                        var mouseY = event.pageY - $(graph.raphael.canvas.parentNode).offset().top;
	                        // no part of the line segment can go beyond 10 pixels from the edge
	                        mouseX = Math.max(offsetLeft + 10, Math.min(graph.xpixels - 10 - offsetRight, mouseX));
	                        mouseY = Math.max(offsetTop + 10, Math.min(graph.ypixels - 10 - offsetBottom, mouseY));

	                        // coord{X|Y} are the scaled coordinate values
	                        var coordX = mouseX / graph.scale[0] + graph.range[0][0];
	                        var coordY = graph.range[1][1] - mouseY / graph.scale[1];
	                        if (lineSegment.snapX > 0) {
	                            coordX = Math.round(coordX / lineSegment.snapX) * lineSegment.snapX;
	                        }
	                        if (lineSegment.snapY > 0) {
	                            coordY = Math.round(coordY / lineSegment.snapY) * lineSegment.snapY;
	                        }

	                        if (event.type === "vmousemove") {
	                            if (lineSegment.constraints.constrainX) {
	                                coordX = lineSegment.coordA[0] - mouseOffsetA[0];
	                            }
	                            if (lineSegment.constraints.constrainY) {
	                                coordY = lineSegment.coordA[1] - mouseOffsetA[1];
	                            }
	                            var dX = coordX + mouseOffsetA[0] - lineSegment.coordA[0];
	                            var dY = coordY + mouseOffsetA[1] - lineSegment.coordA[1];
	                            lineSegment.coordA = [coordX + mouseOffsetA[0], coordY + mouseOffsetA[1]];
	                            lineSegment.coordZ = [coordX + mouseOffsetZ[0], coordY + mouseOffsetZ[1]];
	                            lineSegment.transform();

	                            if (lineSegment.movePointsWithLine) {
	                                // If the points are movablePoints, adjust
	                                // their coordinates when the line itself is
	                                // dragged
	                                if (typeof lineSegment.pointA === "object") {
	                                    lineSegment.pointA.setCoord([
	                                            lineSegment.pointA.coord[0] + dX,
	                                            lineSegment.pointA.coord[1] + dY
	                                    ]);
	                                }
	                                if (typeof lineSegment.pointZ === "object") {
	                                    lineSegment.pointZ.setCoord([
	                                            lineSegment.pointZ.coord[0] + dX,
	                                            lineSegment.pointZ.coord[1] + dY
	                                    ]);
	                                }
	                            }

	                            if (_.isFunction(lineSegment.onMove)) {
	                                lineSegment.onMove(dX, dY);
	                            }

	                        } else if (event.type === "vmouseup") {
	                            $(document).unbind(".lineSegment");
	                            lineSegment.dragging = false;
	                            KhanUtil.dragging = false;
	                            if (!lineSegment.highlight) {
	                                lineSegment.visibleLine.animate(lineSegment.normalStyle, 50);
	                                lineSegment.arrowStyle = _.extend({}, lineSegment.arrowStyle, {
	                                    "color": lineSegment.normalStyle.stroke,
	                                    "stroke": lineSegment.normalStyle.stroke
	                                });
	                                lineSegment.transform();
	                            }
	                            if (_.isFunction(lineSegment.onMoveEnd)) {
	                                lineSegment.onMoveEnd();
	                            }

	                        }

	                        $(lineSegment).trigger("move");
	                    });
	                }
	            });
	        }


	        if (lineSegment.pointA !== undefined) {
	            lineSegment.pointA.toFront();
	        }
	        if (lineSegment.pointZ !== undefined) {
	            lineSegment.pointZ.toFront();
	        }
	        lineSegment.transform();
	        return lineSegment;
	    },

	    // MovablePolygon is a polygon that can be dragged around the screen.
	    // By attaching a smartPoint to each vertex, the points can be
	    // manipulated individually.
	    //
	    // To use with smartPoints, add the smartPoints first, then:
	    //   addMovablePolygon({points: [...]});
	    //
	    // Include "fixed: true" in the options if you don't want the entire
	    // polygon to be draggable (you can still use points to make the
	    // vertices draggable)
	    //
	    // The returned object includes the following properties/methods:
	    //
	    //   - polygon.points
	    //         The polygon's dynamic smartPoints and static coordinates, mixed.
	    //
	    //   - polygon.coords
	    //         The polygon's current coordinates (generated, don't edit).
	    //
	    //   - polygon.transform()
	    //         Repositions the polygon. Call after changing any points.
	    //
	    addMovablePolygon: function(options) {
	        var graphie = this;

	        var polygon = $.extend({
	            snapX: 0,
	            snapY: 0,
	            fixed: false,
	            constrainToGraph: true,
	            normalStyle: {},
	            highlightStyle: {
	                "stroke": KhanUtil.INTERACTING,
	                "stroke-width": 2,
	                "fill": KhanUtil.INTERACTING,
	                "fill-opacity": 0.05
	            },
	            pointHighlightStyle: {
	                "fill": KhanUtil.INTERACTING,
	                "stroke": KhanUtil.INTERACTING
	            },
	            labelStyle: {
	                "stroke": KhanUtil.DYNAMIC,
	                "stroke-width": 1,
	                "color": KhanUtil.DYNAMIC
	            },
	            angleLabels: [],
	            showRightAngleMarkers: [],
	            sideLabels: [],
	            vertexLabels: [],
	            numArcs: [],
	            numArrows: [],
	            numTicks: [],
	            updateOnPointMove: true,
	            closed: true
	        }, _.omit(options, "points"));

	        var normalColor = (polygon.fixed) ? KhanUtil.DYNAMIC
	                                          : KhanUtil.INTERACTIVE;
	        polygon.normalStyle = _.extend(polygon.normalStyle, {
	            "stroke-width": 2,
	            "fill-opacity": 0,
	            "fill": normalColor,
	            "stroke": normalColor
	        }, options.normalStyle);

	        // don't deep copy the points array with $.extend;
	        // we may want to append to it later for click-to-add-points
	        polygon.points = options.points;

	        var isPoint = function(coordOrPoint) {
	            return !_.isArray(coordOrPoint);
	        };

	        polygon.update = function() {
	            var n = polygon.points.length;

	            // Update coords
	            polygon.coords = _.map(polygon.points, function(coordOrPoint, i) {
	                if (isPoint(coordOrPoint)) {
	                    return coordOrPoint.coord;
	                } else {
	                    return coordOrPoint;
	                }
	            });

	            // Calculate bounding box
	            polygon.left = _.min(_.pluck(polygon.coords, 0));
	            polygon.right = _.max(_.pluck(polygon.coords, 0));
	            polygon.top = _.max(_.pluck(polygon.coords, 1));
	            polygon.bottom = _.min(_.pluck(polygon.coords, 1));

	            // Calculate scaled coords
	            var scaledCoords = _.map(polygon.coords, function(coord) {
	                return graphie.scalePoint(coord);
	            });

	            // Create path
	            if (polygon.closed) {
	                scaledCoords.push(true);
	            } else {
	                // For open polygons, concatenate a reverse of the path,
	                // to remove the inside area of the path, which would
	                // otherwise be clickable (even if the closing line segment
	                // wasn't drawn
	                scaledCoords = scaledCoords.concat(
	                    _.clone(scaledCoords).reverse()
	                );
	            }
	            polygon.path = KhanUtil.unscaledSvgPath(scaledCoords);

	            // Temporary objects
	            _.invoke(polygon.temp, "remove");
	            polygon.temp = [];

	            // Check which direction coordinates wind
	            var isClockwise = clockwise(polygon.coords);

	            // Update angle labels
	            if (polygon.angleLabels.length ||
	                    polygon.showRightAngleMarkers.length) {
	                _.each(polygon.labeledAngles, function(label, i) {
	                    polygon.temp.push(graphie.labelAngle({
	                        point1: polygon.coords[(i - 1 + n) % n],
	                        vertex: polygon.coords[i],
	                        point3: polygon.coords[(i + 1) % n],
	                        label: label,
	                        text: polygon.angleLabels[i],
	                        showRightAngleMarker: polygon.showRightAngleMarkers[i],
	                        numArcs: polygon.numArcs[i],
	                        clockwise: isClockwise,
	                        style: polygon.labelStyle
	                    }));
	                });
	            }

	            // Update side labels
	            if (polygon.sideLabels.length) {
	                _.each(polygon.labeledSides, function(label, i) {
	                    polygon.temp.push(graphie.labelSide({
	                        point1: polygon.coords[i],
	                        point2: polygon.coords[(i + 1) % n],
	                        label: label,
	                        text: polygon.sideLabels[i],
	                        numArrows: polygon.numArrows[i],
	                        numTicks: polygon.numTicks[i],
	                        clockwise: isClockwise,
	                        style: polygon.labelStyle
	                    }));
	                });
	            }

	            // Update vertex labels
	            if (polygon.vertexLabels.length) {
	                _.each(polygon.labeledVertices, function(label, i) {
	                    graphie.labelVertex({
	                        point1: polygon.coords[(i - 1 + n) % n],
	                        vertex: polygon.coords[i],
	                        point3: polygon.coords[(i + 1) % n],
	                        label: label,
	                        text: polygon.vertexLabels[i],
	                        clockwise: isClockwise,
	                        style: polygon.labelStyle
	                    });
	                });
	            }

	            polygon.temp = _.flatten(polygon.temp);
	        };

	        polygon.transform = function() {
	            polygon.update();

	            polygon.visibleShape.attr({path: polygon.path});

	            if (!polygon.fixed) {
	                polygon.mouseTarget.attr({path: polygon.path});
	            }
	        };

	        polygon.remove = function() {
	            polygon.visibleShape.remove();

	            if (!polygon.fixed) {
	                polygon.mouseTarget.remove();
	            }

	            if (polygon.labeledAngles) {
	                _.invoke(polygon.labeledAngles, "remove");
	            }

	            if (polygon.labeledSides) {
	                _.invoke(polygon.labeledSides, "remove");
	            }

	            if (polygon.labeledVertices) {
	                _.invoke(polygon.labeledVertices, "remove");
	            }

	            if (polygon.temp.length) {
	                _.invoke(polygon.temp, "remove");
	            }
	        };

	        polygon.toBack = function() {
	            if (!polygon.fixed) {
	                polygon.mouseTarget.toBack();
	            }

	            polygon.visibleShape.toBack();
	        };

	        polygon.toFront = function() {
	            if (!polygon.fixed) {
	                polygon.mouseTarget.toFront();
	            }

	            polygon.visibleShape.toFront();
	        };

	        // Setup

	        if (polygon.updateOnPointMove) {
	            _.each(_.filter(polygon.points, isPoint), function(coordOrPoint) {
	                coordOrPoint.polygonVertices.push(polygon);
	            });
	        }

	        polygon.coords = new Array(polygon.points.length);

	        if (polygon.angleLabels.length) {
	            polygon.labeledAngles = _.times(Math.max(
	                        polygon.angleLabels.length,
	                        polygon.showRightAngleMarkers.length
	                    ), function() {
	                return this.label([0, 0], "", "center", polygon.labelStyle);
	            }, this);
	        }

	        if (polygon.sideLabels.length) {
	            polygon.labeledSides = _.map(polygon.sideLabels, function(label) {
	                return this.label([0, 0], "", "center", polygon.labelStyle);
	            }, this);
	        }

	        if (polygon.vertexLabels.length) {
	            polygon.labeledVertices = _.map(polygon.vertexLabels, function(label) {
	                return this.label([0, 0], "", "center", polygon.labelStyle);
	            }, this);
	        }

	        polygon.update();

	        polygon.visibleShape = graphie.raphael.path(polygon.path);
	        polygon.visibleShape.attr(polygon.normalStyle);

	        if (!polygon.fixed) {
	            polygon.mouseTarget = graphie.mouselayer.path(polygon.path);
	            polygon.mouseTarget.attr({fill: "#000", opacity: 0, cursor: "move"});

	            $(polygon.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function(event) {
	                if (event.type === "vmouseover") {
	                    if (!KhanUtil.dragging || polygon.dragging) {
	                        polygon.highlight = true;
	                        polygon.visibleShape.animate(polygon.highlightStyle, 50);
	                        _.each(_.filter(polygon.points, isPoint), function(point) {
	                            point.visibleShape.animate(polygon.pointHighlightStyle, 50);
	                        });
	                    }

	                } else if (event.type === "vmouseout") {
	                    polygon.highlight = false;
	                    if (!polygon.dragging) {
	                        polygon.visibleShape.animate(polygon.normalStyle, 50);
	                        var points = _.filter(polygon.points, isPoint);
	                        if (!_.any(_.pluck(points, "dragging"))) {
	                            _.each(points, function(point) {
	                                point.visibleShape.animate(point.normalStyle, 50);
	                            });
	                        }
	                    }

	                } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
	                    event.preventDefault();

	                    _.each(_.filter(polygon.points, isPoint), function(point) {
	                        point.dragging = true;
	                    });

	                    // start{X|Y} are the scaled coordinate values of the starting mouse position
	                    var startX = (event.pageX - $(graphie.raphael.canvas.parentNode).offset().left) / graphie.scale[0] + graphie.range[0][0];
	                    var startY = graphie.range[1][1] - (event.pageY - $(graphie.raphael.canvas.parentNode).offset().top) / graphie.scale[1];
	                    if (polygon.snapX > 0) {
	                        startX = Math.round(startX / polygon.snapX) * polygon.snapX;
	                    }
	                    if (polygon.snapY > 0) {
	                        startY = Math.round(startY / polygon.snapY) * polygon.snapY;
	                    }
	                    var lastX = startX;
	                    var lastY = startY;

	                    var polygonCoords = polygon.coords.slice();

	                    // Figure out how many pixels of the bounding box of the polygon lie to each direction of the mouse
	                    var offsetLeft = (startX - polygon.left) * graphie.scale[0];
	                    var offsetRight = (polygon.right - startX) * graphie.scale[0];
	                    var offsetTop = (polygon.top - startY) * graphie.scale[1];
	                    var offsetBottom = (startY - polygon.bottom) * graphie.scale[1];

	                    $(document).bind("vmousemove.polygon vmouseup.polygon", function(event) {
	                        event.preventDefault();

	                        polygon.dragging = true;
	                        KhanUtil.dragging = true;

	                        // mouse{X|Y} are in pixels relative to the SVG
	                        var mouseX = event.pageX - $(graphie.raphael.canvas.parentNode).offset().left;
	                        var mouseY = event.pageY - $(graphie.raphael.canvas.parentNode).offset().top;

	                        // no part of the polygon can go beyond 10 pixels from the edge
	                        if (polygon.constrainToGraph) {
	                            mouseX = Math.max(
	                                offsetLeft + 10,
	                                Math.min(
	                                    graphie.xpixels - 10 - offsetRight,
	                                    mouseX
	                                )
	                            );
	                            mouseY = Math.max(
	                                offsetTop + 10,
	                                Math.min(
	                                    graphie.ypixels - 10 - offsetBottom,
	                                    mouseY
	                                )
	                            );
	                        }

	                        // current{X|Y} are the scaled coordinate values of the current mouse position
	                        var currentX = mouseX / graphie.scale[0] + graphie.range[0][0];
	                        var currentY = graphie.range[1][1] - mouseY / graphie.scale[1];
	                        if (polygon.snapX > 0) {
	                            currentX = Math.round(currentX / polygon.snapX) * polygon.snapX;
	                        }
	                        if (polygon.snapY > 0) {
	                            currentY = Math.round(currentY / polygon.snapY) * polygon.snapY;
	                        }

	                        if (event.type === "vmousemove") {
	                            var dX = currentX - startX;
	                            var dY = currentY - startY;

	                            // The caller has the option of adding an onMove()
	                            // method to the movablePolygon object we return as
	                            // a sort of event handler. By returning false from
	                            // onMove(), the move can be vetoed, providing
	                            // custom constraints on where the point can be
	                            // moved. By returning array [dX, dY], the move can
	                            // be overridden.
	                            var doMove = true;
	                            if (_.isFunction(polygon.onMove)) {
	                                var onMoveResult = polygon.onMove(dX, dY);
	                                if (onMoveResult === false) {
	                                    doMove = false;
	                                } else if (_.isArray(onMoveResult)) {
	                                    dX = onMoveResult[0];
	                                    dY = onMoveResult[1];
	                                    currentX = startX + dX;
	                                    currentY = startY + dY;
	                                }
	                            }

	                            var increment = function(i) {
	                                return [
	                                    polygonCoords[i][0] + dX,
	                                    polygonCoords[i][1] + dY
	                                ];
	                            };

	                            if (doMove) {
	                                _.each(polygon.points, function(coordOrPoint, i) {
	                                    if (isPoint(coordOrPoint)) {
	                                        coordOrPoint.setCoord(increment(i));
	                                    } else {
	                                        polygon.points[i] = increment(i);
	                                    }
	                                });

	                                polygon.transform();

	                                $(polygon).trigger("move");

	                                lastX = currentX;
	                                lastY = currentY;
	                            }

	                        } else if (event.type === "vmouseup") {
	                            $(document).unbind(".polygon");

	                            var points = _.filter(polygon.points, isPoint);
	                            _.each(points, function(point) {
	                                point.dragging = false;
	                            });

	                            polygon.dragging = false;
	                            KhanUtil.dragging = false;
	                            if (!polygon.highlight) {
	                                polygon.visibleShape.animate(polygon.normalStyle, 50);

	                                _.each(points, function(point) {
	                                    point.visibleShape.animate(point.normalStyle, 50);
	                                });
	                            }
	                            if (_.isFunction(polygon.onMoveEnd)) {
	                                polygon.onMoveEnd(lastX - startX, lastY - startY);
	                            }
	                        }
	                    });
	                }
	            });
	        }

	        // Bring any movable points to the front
	        _.invoke(_.filter(polygon.points, isPoint), "toFront");

	        return polygon;
	    },

	    /**
	     * Constrain a point to be within the graph (including padding).
	     * If outside graph, point's x and y coordinates are clamped within
	     * the graph.
	     */
	    constrainToBounds: function(point, padding) {
	        var lower = this.unscalePoint([padding, this.ypixels - padding]);
	        var upper = this.unscalePoint([this.xpixels - padding, padding]);
	        var coordX = Math.max(lower[0], Math.min(upper[0], point[0]));
	        var coordY = Math.max(lower[1], Math.min(upper[1], point[1]));
	        return [coordX, coordY];
	    },

	    /**
	     * Constrain a point to be within the graph (including padding).
	     * If outside graph, point is moved along the ray specified by angle
	     * until inside graph.
	     */
	    constrainToBoundsOnAngle: function(point, padding, angle) {
	        var lower = this.unscalePoint([padding, this.ypixels - padding]);
	        var upper = this.unscalePoint([this.xpixels - padding, padding]);

	        var result = point.slice();

	        if (result[0] < lower[0]) {
	            result = [lower[0], result[1] + (lower[0] - result[0]) * Math.tan(angle)];
	        } else if (result[0] > upper[0]) {
	            result = [upper[0], result[1] - (result[0] - upper[0]) * Math.tan(angle)];
	        }

	        if (result[1] < lower[1]) {
	            result = [result[0] + (lower[1] - result[1]) / Math.tan(angle), lower[1]];
	        } else if (result[1] > upper[1]) {
	            result = [result[0] - (result[1] - upper[1]) / Math.tan(angle), upper[1]];
	        }

	        return result;
	    },

	    // MovableAngle is an angle that can be dragged around the screen.
	    // By attaching a smartPoint to the vertex and ray control points, the
	    // rays can be manipulated individually.
	    //
	    // Use only with smartPoints; add the smartPoints first, then:
	    //   addMovableAngle({points: [...]});
	    //
	    // The rays can be controlled to snap on degrees (more useful than snapping
	    // on coordinates) by setting snapDegrees to a positive integer.
	    //
	    // The returned object includes the following properties/methods:
	    //
	    //   - movableAngle.points
	    //         The movableAngle's dynamic smartPoints.
	    //
	    //   - movableAngle.coords
	    //         The movableAngle's current coordinates (generated, don't edit).
	    //
	    addMovableAngle: function(options) {
	        return new MovableAngle(this, options);
	    },

	    addArrowWidget: function(options) {
	        var arrowWidget = $.extend({
	            graph: this,
	            direction: "up",
	            coord: [0, 0],
	            onClick: function() {}
	        }, options);
	        var graph = arrowWidget.graph;

	        if (arrowWidget.direction === "up") {
	            arrowWidget.visibleShape = graph.path([
	                    [arrowWidget.coord[0], arrowWidget.coord[1] - 4 / graph.scale[1]],
	                    [arrowWidget.coord[0] - 4 / graph.scale[0], arrowWidget.coord[1] - 4 / graph.scale[1]],
	                    [arrowWidget.coord[0], arrowWidget.coord[1] + 4 / graph.scale[1]],
	                    [arrowWidget.coord[0] + 4 / graph.scale[0], arrowWidget.coord[1] - 4 / graph.scale[1]],
	                    [arrowWidget.coord[0], arrowWidget.coord[1] - 4 / graph.scale[1]]
	                    ], { stroke: "", fill: KhanUtil.INTERACTIVE });
	        } else if (arrowWidget.direction === "down") {
	            arrowWidget.visibleShape = graph.path([
	                    [arrowWidget.coord[0], arrowWidget.coord[1] + 4 / graph.scale[1]],
	                    [arrowWidget.coord[0] - 4 / graph.scale[0], arrowWidget.coord[1] + 4 / graph.scale[1]],
	                    [arrowWidget.coord[0], arrowWidget.coord[1] - 4 / graph.scale[1]],
	                    [arrowWidget.coord[0] + 4 / graph.scale[0], arrowWidget.coord[1] + 4 / graph.scale[1]],
	                    [arrowWidget.coord[0], arrowWidget.coord[1] + 4 / graph.scale[1]]
	                    ], { stroke: "", fill: KhanUtil.INTERACTIVE });
	        }

	        // You might think we JUST NOW set the style when we drew this. But
	        // does IE8 care? No! Of course not! It was too busy being slow and
	        // obnoxious. So apparently we have to set the style again, later, when
	        // it's paying attention. Or something.
	        _.defer(function() {
	            arrowWidget.visibleShape.attr({stroke: "", fill: KhanUtil.INTERACTIVE});
	        });

	        arrowWidget.mouseTarget = graph.mouselayer.circle(
	                graph.scalePoint(arrowWidget.coord)[0], graph.scalePoint(arrowWidget.coord)[1], 15);
	        arrowWidget.mouseTarget.attr({fill: "#000", "opacity": 0.0});

	        $(arrowWidget.mouseTarget[0]).css("cursor", "pointer");
	        $(arrowWidget.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function(event) {
	            if (event.type === "vmouseover") {
	                arrowWidget.visibleShape.animate({ scale: 2, fill: KhanUtil.INTERACTING }, 20);
	            } else if (event.type === "vmouseout") {
	                arrowWidget.visibleShape.animate({ scale: 1, fill: KhanUtil.INTERACTING }, 20);
	            } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
	                if (!arrowWidget.hidden) {
	                    arrowWidget.onClick();
	                }
	                return false;
	            }
	        });

	        arrowWidget.hide = function() {
	            arrowWidget.visibleShape.hide();
	            arrowWidget.hidden = true;
	            $(arrowWidget.mouseTarget[0]).css("cursor", "default");
	        };

	        arrowWidget.show = function() {
	            arrowWidget.visibleShape.show();
	            arrowWidget.hidden = false;
	            $(arrowWidget.mouseTarget[0]).css("cursor", "pointer");
	        };

	        return arrowWidget;
	    },


	    addRectGraph: function(options) {
	        // settings
	        var rect = $.extend(true, {
	            x: 0,
	            y: 0,
	            width: 1,
	            height: 1,
	            normalStyle: {
	                points: {
	                    stroke: KhanUtil.INTERACTIVE,
	                    fill: KhanUtil.INTERACTIVE,
	                    opacity: 1
	                },
	                edges: {
	                    stroke: KhanUtil.INTERACTIVE,
	                    opacity: 1,
	                    "stroke-width": 1
	                },
	                area: {
	                    fill: KhanUtil.INTERACTIVE,
	                    "fill-opacity": 0.1,
	                    "stroke-width": 0
	                }
	            },
	            hoverStyle: {
	                points: {
	                    color: KhanUtil.INTERACTING,
	                    opacity: 1,
	                    width: 2
	                },
	                edges: {
	                    stroke: KhanUtil.INTERACTING,
	                    opacity: 1,
	                    "stroke-width": 1
	                },
	                area: {
	                    fill: KhanUtil.INTERACTING,
	                    "fill-opacity": 0.2,
	                    "stroke-width": 0
	                }
	            },
	            fixed: {
	                // if true, users cannot move the edge independently
	                edges: [false, false, false, false],

	                // if true, users cannot move the point independently
	                points: [false, false, false, false]
	            },
	            constraints: {
	                constrainX: false, // limit movement to y axis
	                constrainY: false, // limit movement to x axis

	                // bounds for translations
	                xmin: null,
	                xmax: null,
	                ymin: null,
	                ymax: null
	            },
	            snapX: 0,
	            snapY: 0,

	            // this function will be called whenever .translate(), .snap(), or
	            // .moveTo() are called
	            onMove: function() {}
	        }, options);


	        // functions
	        rect = $.extend({
	            initialized: function() {
	                return rect.points && rect.points.length;
	            },
	            x2: function() {
	                return this.x + this.width;
	            },
	            y2: function() {
	                return this.y + this.height;
	            },
	            getX: function() {
	                if (rect.initialized()) {
	                    return rect.points[0].coord[0];
	                }
	                return rect.x;
	            },
	            getY: function() {
	                if (rect.initialized()) {
	                    return rect.points[0].coord[1];
	                }
	                return rect.y;
	            },
	            getX2: function() {
	                return rect.getX() + rect.getWidth();
	            },
	            getY2: function() {
	                return rect.getY() + rect.getHeight();
	            },
	            getXLims: function() {
	                var x = rect.getX();
	                return [x, x + rect.getWidth()];
	            },
	            getYLims: function() {
	                var y = rect.getY();
	                return [y, y + rect.getHeight()];
	            },
	            getWidth: function() {
	                if (rect.initialized()) {
	                    var x0 = rect.points[1].coord[0];
	                    var x1 = rect.points[2].coord[0];
	                    return x1 - x0;
	                }
	                return rect.width;
	            },
	            getHeight: function() {
	                if (rect.initialized()) {
	                    var y0 = rect.points[0].coord[1];
	                    var y1 = rect.points[1].coord[1];
	                    return y1 - y0;
	                }
	                return rect.height;
	            },
	            getCoord: function() {
	                return [rect.getX(), rect.getY()];
	            },
	            getRaphaelParamsArr: function() {
	                var width = rect.getWidth();
	                var height = rect.getHeight();
	                var x = rect.getX();
	                var y = rect.getY();
	                var point = graphie.scalePoint([x, y + height]);
	                var dims = graphie.scaleVector([width, height]);
	                return point.concat(dims);
	            },
	            getRaphaelParams: function() {
	                var arr = rect.getRaphaelParamsArr();
	                return {
	                    x: arr[0],
	                    y: arr[1],
	                    width: arr[2],
	                    height: arr[3]
	                };
	            }
	        }, rect);

	        var graphie = this;



	        // ADD RECTANGLE AND MOUSE TARGET

	        rect.fillArea = graphie.rect().attr(rect.normalStyle.area);
	        rect.mouseTarget = graphie.mouselayer.rect()
	            .attr({
	                fill: "#000",
	                opacity: 0,
	                "fill-opacity": 0
	            });

	        rect.render = function() {
	            rect.fillArea.attr(rect.getRaphaelParams());
	            rect.mouseTarget.attr(rect.getRaphaelParams());
	        };

	        rect.render(); // initialize



	        // ADD POINTS

	        rect.points = [];

	        var coords = [[rect.x, rect.y], [rect.x, rect.y2()], [rect.x2(), rect.y2()], [rect.x2(), rect.y]];
	        var sames = [[1, 3], [0, 2], [3, 1], [2, 0]];
	        var moveLimits = [[1, 1], [1, 0], [0, 0], [0, 1]];


	        function adjustNeighboringPoints(x, y, sameX, sameY) {
	            rect.points[sameX].setCoord([x, rect.points[sameX].coord[1]]);
	            rect.points[sameY].setCoord([rect.points[sameY].coord[0], y]);
	            rect.points[sameX].updateLineEnds();
	            rect.points[sameY].updateLineEnds();
	        }

	        function coordInBounds(limit, newVal, checkIsGreater) {
	            return checkIsGreater ? newVal < limit : newVal > limit;
	        }

	        function moveIsInBounds(index, newX, newY) {
	            var xlims = rect.getXLims();
	            var ylims = rect.getYLims();

	            var i = moveLimits[index];

	            var xInBounds = coordInBounds(xlims[i[0]], newX, i[0] === 1);
	            var yInBounds = coordInBounds(ylims[i[1]], newY, i[1] === 1);

	            return xInBounds && yInBounds;
	        }

	        _.times(4, function(i) {
	            var sameX = sames[i][0];
	            var sameY = sames[i][1];
	            var coord = coords[i];

	            var point = graphie.addMovablePoint({
	                graph: graphie,
	                coord: coord,
	                normalStyle: rect.normalStyle.points,
	                hoverStyle: rect.hoverStyle.points,
	                snapX: rect.snapX,
	                snapY: rect.snapY,
	                visible: !rect.fixed.points[i],
	                constraints: {
	                    fixed: rect.fixed.points[i]
	                },
	                onMove: function(x, y) {
	                    if (!moveIsInBounds(i, x, y)) {
	                        return false;
	                    }
	                    adjustNeighboringPoints(x, y, sameX, sameY);
	                    rect.render();
	                }
	            });

	            rect.points.push(point);
	        });



	        // ADD EDGES

	        rect.edges = [];

	        rect.moveEdge = function(dx, dy, edgeIndex) {
	            var a = rect.edges[edgeIndex].pointA;
	            var z = rect.edges[edgeIndex].pointZ;
	            a.setCoord([a.coord[0] + dx, a.coord[1] + dy]);
	            z.setCoord([z.coord[0] + dx, z.coord[1] + dy]);
	            a.updateLineEnds();
	            z.updateLineEnds();
	        };

	        _.times(4, function(i) {
	            var pointA = rect.points[i];
	            var pointZ = rect.points[(i + 1) % 4]; // next point
	            var constrainX = (i % 2); // odd edges have X constrained
	            var constrainY = ((i + 1) % 2); // even edges have Y constrained

	            var edge = graphie.addMovableLineSegment({
	                graph: graphie,
	                pointA: pointA,
	                pointZ: pointZ,
	                normalStyle: rect.normalStyle.edges,
	                hoverStyle: rect.hoverStyle.edges,
	                snapX: rect.snapX,
	                snapY: rect.snapY,
	                fixed: rect.fixed.edges[i],
	                constraints: {
	                    constrainX: constrainX,
	                    constrainY: constrainY
	                },
	                onMove: function(dx, dy) {
	                    rect.moveEdge(dx, dy, i);
	                    rect.render();
	                }
	            });

	            rect.edges.push(edge);
	        });



	        // CREATE COLLECTION OF ALL ELEMENTS (used in toFront)
	        var elems = [rect.fillArea, rect.mouseTarget];
	        rect.elems = elems.concat(rect.edges).concat(rect.points);



	        // MOVING FUNCTIONS

	        function constrainTranslation(dx, dy) {
	            var xC = rect.constraints.constrainX;
	            var xLT = rect.getX() + dx < rect.constraints.xmin;
	            var xGT = rect.getX2() + dx > rect.constraints.xmax;
	            var yC = rect.constraints.constrainY;
	            var yLT = rect.getY() + dy < rect.constraints.ymin;
	            var yGT = rect.getY2() + dy > rect.constraints.ymax;

	            dx = xC || xLT || xGT ? 0 : dx;
	            dy = yC || yLT || yGT ? 0 : dy;

	            return [dx, dy];
	        }

	        rect.translate = function(dx, dy) {
	            if (rect.constraints.constrainX && rect.constraints.constrainY) {
	                return;
	            }
	            var d = constrainTranslation(dx, dy);
	            dx = d[0];
	            dy = d[1];

	            _.each(rect.points, function(point, i) {
	                var x = point.coord[0] + dx;
	                var y = point.coord[1] + dy;
	                // move points
	                point.setCoord([x, y]);
	                // move edges
	                point.updateLineEnds();
	            });

	            // move rectangle & mouseTarget
	            rect.render();

	            // fire "on move" event with the new xlims and ylims
	            rect.onMove(dx, dy);
	        };

	        rect.moveTo = function(x, y) {
	            var dx = x - rect.getX();
	            var dy = y - rect.getY();
	            rect.translate(dx, dy);
	        };

	        rect.snap = function() {
	            var dx;
	            var dy;
	            _.each(rect.points, function(point, i) {
	                var x0 = point.coord[0];
	                var y0 = point.coord[1];
	                var x1 = x0;
	                var y1 = y0;

	                if (rect.snapX) {
	                    x1 = KhanUtil.roundToNearest(rect.snapX, x0);
	                }
	                if (rect.snapY) {
	                    y1 = KhanUtil.roundToNearest(rect.snapY, y0);
	                }

	                if (!dx || !dy) {
	                    dx = x1 - x0;
	                    dy = y1 - y0;
	                }

	                // move points
	                point.setCoord([x1, y1]);
	                // move edges
	                point.updateLineEnds();
	            });

	            // move rectangle & mouseTarget
	            rect.render();

	            // fire "on move" event with the new xlims and ylims
	            rect.onMove(dx, dy);
	        };

	        // TODO(stephanie): confirm this works
	        rect.toFront = function() {
	            _.each(rect.elems, function(elem) {
	                elem.toFront();
	            });
	        };

	        rect.hide = function(speed) {
	            if (rect.hidden) {
	                return;
	            }

	            speed = speed || 100;

	            rect.fillArea.animate({
	                "fill-opacity": 0
	            }, speed);
	            $(rect.mouseTarget[0]).css("display", "none");

	            rect.hidden = true;
	        };

	        rect.show = function(speed) {
	            if (!rect.hidden) {
	                return;
	            }

	            speed = speed || 100;

	            rect.fillArea.animate(rect.normalStyle.area, speed);
	            $(rect.mouseTarget[0]).css("display", "block");

	            rect.hidden = false;
	        };

	        rect.enableHoverStyle = function() {
	            rect.highlight = true;
	            if (!KhanUtil.dragging) {
	                rect.fillArea.animate(rect.hoverStyle.area, 100);
	            }
	        };

	        rect.enableNormalStyle = function() {
	            rect.highlight = false;
	            if (!rect.dragging) {
	                rect.fillArea.animate(rect.normalStyle.area, 100);
	            }
	        };

	        // tie actual translation events to the translate function
	        var bindTranslation = function() {
	            $(rect.mouseTarget[0]).css("cursor", "move");
	            $(rect.mouseTarget[0]).on(
	                "vmouseover vmouseout vmousedown", function(event) {
	                    if (event.type === "vmouseover") {
	                        rect.enableHoverStyle();

	                    } else if (event.type === "vmouseout") {
	                        rect.enableNormalStyle();

	                    } else if (event.type === "vmousedown" &&
	                            (event.which === 1 || event.which === 0)) {
	                        event.preventDefault();
	                        rect.toFront();
	                        rect.prevCoord = graphie.getMouseCoord(event);

	                        rect.enableHoverStyle();

	                        $(document).on("vmousemove vmouseup", function(event) {
	                            event.preventDefault();
	                            rect.dragging = true;
	                            KhanUtil.dragging = true;

	                            if (event.type === "vmousemove") {
	                                var currCoord = graphie.getMouseCoord(event);

	                                if (rect.prevCoord && rect.prevCoord.length === 2) {
	                                    var diff = KhanUtil.coordDiff(rect.prevCoord, currCoord);
	                                    rect.translate(diff[0], diff[1]);
	                                }

	                                rect.prevCoord = currCoord;

	                            } else if (event.type === "vmouseup") {
	                                $(document).off("vmousemove vmouseup");
	                                rect.dragging = false;
	                                KhanUtil.dragging = false;

	                                var currCoord = graphie.getMouseCoord(event);
	                                if (currCoord[0] < rect.getX() ||
	                                    currCoord[0] > rect.getX2() ||
	                                    currCoord[1] < rect.getY() ||
	                                    currCoord[1] > rect.getY2()) {
	                                        rect.enableNormalStyle();
	                                }

	                                // snap to grid
	                                rect.snap();
	                            }
	                        });
	                    }
	            });
	        };

	        bindTranslation();

	        return rect;
	    },

	    // center: movable point
	    // radius: int
	    // circ: graphie circle
	    // perim: invisible mouse target for dragging/changing radius
	    addCircleGraph: function(options) {
	        var graphie = this;
	        var circle = $.extend({
	            center: [0, 0],
	            radius: 2,
	            snapX: 0.5,
	            snapY: 0.5,
	            snapRadius: 0.5,
	            minRadius: 1,
	            centerConstraints: {},
	            centerNormalStyle: {},
	            centerHighlightStyle: {
	                stroke: KhanUtil.INTERACTING,
	                fill: KhanUtil.INTERACTING
	            },
	            circleNormalStyle: {
	                stroke: KhanUtil.INTERACTIVE,
	                "fill-opacity": 0
	            },
	            circleHighlightStyle: {
	                stroke: KhanUtil.INTERACTING,
	                fill: KhanUtil.INTERACTING,
	                "fill-opacity": 0.05
	            }
	        }, options);

	        // Set normal styling based on interactability
	        var normalColor = (circle.centerConstraints.fixed) ?
	                                  KhanUtil.DYNAMIC
	                                : KhanUtil.INTERACTIVE;
	        var centerNormalStyle = (options) ? options.centerNormalStyle : null;
	        circle.centerNormalStyle = _.extend({}, {
	            "fill": normalColor,
	            "stroke": normalColor
	        }, centerNormalStyle);

	        circle.centerPoint = graphie.addMovablePoint({
	            graph: graphie,
	            coord: circle.center,
	            normalStyle: circle.centerNormalStyle,
	            snapX: circle.snapX,
	            snapY: circle.snapY,
	            constraints: circle.centerConstraints
	        });
	        circle.circ = graphie.circle(circle.center, circle.radius,
	                circle.circleNormalStyle);
	        circle.perim = graphie.mouselayer.circle(
	            graphie.scalePoint(circle.center)[0],
	            graphie.scalePoint(circle.center)[1],
	            graphie.scaleVector(circle.radius)[0]).attr({
	                "stroke-width": 20,
	                "opacity": 0.002  // This is as close to 0 as MSIE will allow
	            });

	        // Highlight circle circumference on center point hover
	        if (!circle.centerConstraints.fixed) {
	            $(circle.centerPoint.mouseTarget[0]).on("vmouseover vmouseout",
	                    function(event) {
	                if (circle.centerPoint.highlight ||
	                        circle.centerPoint.dragging) {
	                    circle.circ.animate(circle.circleHighlightStyle, 50);
	                } else {
	                    circle.circ.animate(circle.circleNormalStyle, 50);
	                }
	            });
	        }

	        circle.toFront = function() {
	            circle.circ.toFront();
	            circle.perim.toFront();
	            circle.centerPoint.visibleShape.toFront();
	            if (!circle.centerConstraints.fixed) {
	                circle.centerPoint.mouseTarget.toFront();
	            }
	        };

	        circle.centerPoint.onMove = function(x, y) {
	            circle.toFront();
	            circle.circ.attr({
	                cx: graphie.scalePoint(x)[0],
	                cy: graphie.scalePoint(y)[1]
	            });
	            circle.perim.attr({
	                cx: graphie.scalePoint(x)[0],
	                cy: graphie.scalePoint(y)[1]
	            });
	            if (circle.onMove) {
	                circle.onMove(x, y);
	            }
	        };

	        $(circle.centerPoint).on("move", function() {
	            circle.center = this.coord;
	            $(circle).trigger("move");
	        });

	        // circle.setCenter(x, y) moves the circle to the specified
	        // x, y coordinate as if the user had dragged it there.
	        circle.setCenter = function(x, y) {
	            circle.centerPoint.setCoord([x, y]);
	            circle.centerPoint.onMove(x, y);
	            circle.center = [x, y];
	        };

	        // circle.setRadius(r) sets the circle's radius to the specified
	        // value as if the user had dragged it there.
	        circle.setRadius = function(r) {
	            circle.radius = r;

	            circle.perim.attr({
	                r: graphie.scaleVector(r)[0]
	            });
	            circle.circ.attr({
	                rx: graphie.scaleVector(r)[0],
	                ry: graphie.scaleVector(r)[1]
	            });
	        };

	        circle.remove = function() {
	            circle.centerPoint.remove();
	            circle.circ.remove();
	            circle.perim.remove();
	        };

	        $(circle.perim[0]).css("cursor", "move");
	        $(circle.perim[0]).on(
	            "vmouseover vmouseout vmousedown", function(event) {
	                if (event.type === "vmouseover") {
	                    circle.highlight = true;
	                    if (!KhanUtil.dragging) {
	                        // TODO(jack): Figure out why this doesn't work
	                        // for circleHighlightStyle's that change
	                        // stroke-dasharray
	                        circle.circ.animate(circle.circleHighlightStyle, 50);
	                        circle.centerPoint.visibleShape.animate(
	                            circle.centerHighlightStyle,
	                            50
	                        );
	                    }

	                } else if (event.type === "vmouseout") {
	                    circle.highlight = false;
	                    if (!circle.dragging && !circle.centerPoint.dragging) {
	                        circle.circ.animate(circle.circleNormalStyle, 50);
	                        circle.centerPoint.visibleShape.animate(
	                            circle.centerNormalStyle,
	                            50
	                        );
	                    }

	                } else if (event.type === "vmousedown" &&
	                        (event.which === 1 || event.which === 0)) {
	                    event.preventDefault();
	                    circle.toFront();
	                    var startRadius = circle.radius;

	                    $(document).on("vmousemove vmouseup", function(event) {
	                        event.preventDefault();
	                        circle.dragging = true;
	                        KhanUtil.dragging = true;

	                        if (event.type === "vmousemove") {
	                            // can't go beyond 10 pixels from the edge
	                            // coord is the scaled coordinate
	                            var coord = graphie.constrainToBounds(
	                                graphie.getMouseCoord(event), 10);

	                            var radius = KhanUtil.getDistance(
	                                circle.centerPoint.coord, coord);
	                            radius = Math.max(circle.minRadius,
	                                Math.round(radius / circle.snapRadius) *
	                                circle.snapRadius);
	                            var oldRadius = circle.radius;
	                            var doResize = true;
	                            if (circle.onResize) {
	                                var onResizeResult = circle.onResize(radius, oldRadius);
	                                if (_.isNumber(onResizeResult)) {
	                                    radius = onResizeResult;
	                                } else if (onResizeResult === false) {
	                                    doResize = false;
	                                }
	                            }
	                            if (doResize) {
	                                circle.setRadius(radius);
	                                $(circle).trigger("move");
	                            }
	                        } else if (event.type === "vmouseup") {
	                            $(document).off("vmousemove vmouseup");
	                            circle.dragging = false;
	                            KhanUtil.dragging = false;
	                            if (circle.onResizeEnd) {
	                                circle.onResizeEnd(circle.radius, startRadius);
	                            }
	                        }
	                    });
	                }
	        });

	        return circle;
	    },

	    interactiveEllipse: function(options) {
	        var graphie = this;
	        var ellipse = $.extend({
	            center: [0, 0],
	            radius: 2,
	            xRadius: 2,
	            yRadius: 2,
	            ellipseNormalStyle: {
	                stroke: KhanUtil.INTERACTIVE,
	                "fill-opacity": 0
	            },
	            ellipseBoundaryHideStyle: {
	                "fill-opacity": 0,
	                "stroke-width": 0
	            },
	            ellipseBoundaryShowStyle: {
	                "fill-opacity": 1,
	                fill: KhanUtil.INTERACTIVE
	            },
	            onMove: function(coordX, coordY) { /* Here to be overriden */ },
	            onLeave: function(coordX, coordY) { /* Here to be overriden */ }
	        }, options);

	        ellipse.circ = graphie.ellipse(ellipse.center, [ellipse.xRadius, ellipse.yRadius], ellipse.ellipseNormalStyle);
	        ellipse.perim = graphie.mouselayer.ellipse(
	            graphie.scalePoint(ellipse.center)[0],
	            graphie.scalePoint(ellipse.center)[1],
	            graphie.scaleVector(ellipse.xRadius)[0],
	            graphie.scaleVector(ellipse.yRadius)[0]).attr({
	                "stroke-width": 30,
	                "opacity": 0.002  // This is as close to 0 as MSIE will allow
	        });

	        ellipse.boundaryPoint = graphie.circle(ellipse.center, 0.4, ellipse.ellipseBoundaryHideStyle);

	        ellipse.remove = function() {
	            ellipse.circ.remove();
	            ellipse.perim.remove();
	        };

	        ellipse.showPoint = function(event) {
	            // Fix to ellipse boundary by finding angle and adjusting the radius
	            var coord = graphie.constrainToBounds(graphie.getMouseCoord(event), 10);
	            var dx = ellipse.yRadius * (ellipse.center[0] - coord[0]);
	            var dy = ellipse.xRadius * (ellipse.center[1] - coord[1]);
	            var angle = Math.atan2(dy, dx);

	            coord[0] = ellipse.center[0] - ellipse.xRadius * Math.cos(angle);
	            coord[1] = ellipse.center[1] - ellipse.yRadius * Math.sin(angle);

	            var scaledPoint = graphie.scalePoint(coord);
	            ellipse.boundaryPoint.attr({ cx: scaledPoint[0] });
	            ellipse.boundaryPoint.attr({ cy: scaledPoint[1] });
	            ellipse.boundaryPoint.animate(ellipse.ellipseBoundaryShowStyle, 50);

	            ellipse.onMove(coord[0], coord[1]);
	        };

	        $(ellipse.perim[0]).on(
	            "vmouseover vmouseout vmousemove", function(event) {
	                if (event.type === "vmouseover") {
	                    ellipse.showPoint(event);
	                } else if (event.type === "vmouseout") {
	                    ellipse.boundaryPoint.animate(ellipse.ellipseBoundaryHideStyle, 50);
	                    ellipse.onLeave();
	                } else if (event.type === "vmousemove") {
	                    ellipse.showPoint(event);
	                }
	        });

	        return ellipse;
	    },

	    addRotateHandle: (function() {
	        var drawRotateHandle = function(graphie, center, radius, halfWidth,
	                lengthAngle, angle, interacting) {
	            // Get a point on the arrow, given an angle offset and a distance
	            // from the "midline" of the arrow (ROTATE_HANDLE_DIST away from
	            // the rotation point).
	            var getRotateHandlePoint = function(offset,
	                    distanceFromArrowMidline) {
	                var distFromRotationCenter = radius + distanceFromArrowMidline;
	                var vec = KhanUtil.kvector.cartFromPolarDeg([
	                    distFromRotationCenter,
	                    angle + offset
	                ]);
	                var absolute = KhanUtil.kvector.add(center, vec);
	                var pixels = graphie.scalePoint(absolute);
	                return pixels[0] + "," + pixels[1];
	            };

	            // Inner and outer radii for the curved part of the arrow
	            var innerR = graphie.scaleVector(radius - halfWidth);
	            var outerR = graphie.scaleVector(radius + halfWidth);

	            // Draw the double-headed arrow thing that shows users where to
	            // click and drag to rotate
	            return graphie.raphael.path(
	                // upper arrowhead
	                " M" + getRotateHandlePoint(lengthAngle, -halfWidth) +
	                " L" + getRotateHandlePoint(lengthAngle, -3 * halfWidth) +
	                " L" + getRotateHandlePoint(2 * lengthAngle, 0) +
	                " L" + getRotateHandlePoint(lengthAngle, 3 * halfWidth) +
	                " L" + getRotateHandlePoint(lengthAngle, halfWidth) +
	                // outer arc
	                " A" + outerR[0] + "," + outerR[1] + ",0,0,1," +
	                    getRotateHandlePoint(-lengthAngle, halfWidth) +
	                // lower arrowhead
	                " L" + getRotateHandlePoint(-lengthAngle, 3 * halfWidth) +
	                " L" + getRotateHandlePoint(-2 * lengthAngle, 0) +
	                " L" + getRotateHandlePoint(-lengthAngle, -3 * halfWidth) +
	                " L" + getRotateHandlePoint(-lengthAngle, -halfWidth) +
	                // inner arc
	                " A" + innerR[0] + "," + innerR[1] + ",0,0,0," +
	                    getRotateHandlePoint(lengthAngle, -halfWidth) +
	                " Z"
	            ).attr({
	                stroke: null,
	                fill: (interacting) ? KhanUtil.INTERACTING
	                                    : KhanUtil.INTERACTIVE
	            });
	        };

	        return function(options) {
	            var graph = this;

	            var rotatePoint = options.center;
	            var radius = options.radius;
	            var lengthAngle = options.lengthAngle || 30;
	            var hideArrow = options.hideArrow || false;
	            var mouseTarget = options.mouseTarget;
	            var id = _.uniqueId("rotateHandle");

	            // Normalize rotatePoint into something that always looks
	            // like a movablePoint
	            if (_.isArray(rotatePoint)) {
	                rotatePoint = {
	                    coord: rotatePoint
	                };
	            }

	            var rotateHandle = graph.addMovablePoint({
	                coord: KhanUtil.kpoint.addVector(
	                    rotatePoint.coord,
	                    KhanUtil.kvector.cartFromPolarDeg(
	                        radius,
	                        options.angleDeg || 0
	                )),
	                constraints: {
	                    fixedDistance: {
	                        dist: radius,
	                        point: rotatePoint
	                    }
	                },
	                mouseTarget: mouseTarget
	            });

	            // move the rotatePoint in front of the rotateHandle to avoid
	            // confusing clicking/scaling of the rotateHandle when the user
	            // intends to click on the rotatePoint
	            rotatePoint.toFront();

	            // The logic below in onMove handlers is to make sure we
	            // move rotateHandle with rotatePoint
	            var rotatePointPrevCoord = rotatePoint.coord;
	            var rotateHandlePrevCoord = rotateHandle.coord;
	            var rotateHandleStartCoord = rotateHandlePrevCoord;
	            var isRotating = false;
	            var isHovering = false;
	            var drawnRotateHandle;

	            var redrawRotateHandle = function(handleCoord) {
	                if (hideArrow) {
	                    return; // Don't draw anything!
	                }

	                var handleVec = KhanUtil.kvector.subtract(handleCoord,
	                        rotatePoint.coord);
	                var handlePolar = KhanUtil.kvector.polarDegFromCart(handleVec);
	                var angle = handlePolar[1];

	                if (drawnRotateHandle) {
	                    drawnRotateHandle.remove();
	                }

	                drawnRotateHandle = drawRotateHandle(
	                    graph,
	                    rotatePoint.coord,
	                    options.radius,
	                    (isRotating || isHovering ?
	                        options.hoverWidth / 2 :
	                        options.width / 2
	                    ),
	                    lengthAngle,
	                    angle,
	                    isRotating || isHovering
	                );
	            };


	            // when the rotation center moves, we need to move
	            // the rotationHandle as well, or it will end up out
	            // of sync
	            $(rotatePoint).on("move." + id, function() {
	                var delta = KhanUtil.kvector.subtract(
	                    rotatePoint.coord,
	                    rotatePointPrevCoord
	                );

	                rotateHandle.setCoord(KhanUtil.kvector.add(
	                    rotateHandle.coord,
	                    delta
	                ));

	                redrawRotateHandle(rotateHandle.coord);

	                rotatePointPrevCoord = rotatePoint.coord;
	                rotateHandle.constraints.fixedDistance.point = rotatePoint;
	                rotateHandlePrevCoord = rotateHandle.coord;
	            });

	            // Rotate polygon with rotateHandle
	            rotateHandle.onMove = function(x, y) {
	                if (!isRotating) {
	                    rotateHandleStartCoord = rotateHandlePrevCoord;
	                    isRotating = true;
	                }

	                var coord = [x, y];

	                if (options.onMove) {
	                    var oldPolar = KhanUtil.kvector.polarDegFromCart(
	                        KhanUtil.kvector.subtract(
	                            rotateHandlePrevCoord,
	                            rotatePoint.coord
	                        )
	                    );
	                    var newPolar = KhanUtil.kvector.polarDegFromCart(
	                        KhanUtil.kvector.subtract(coord, rotatePoint.coord)
	                    );

	                    var oldAngle = oldPolar[1];
	                    var newAngle = newPolar[1];
	                    var result = options.onMove(newAngle, oldAngle);
	                    if (result != null && result !== true) {
	                        if (result === false) {
	                            result = oldAngle;
	                        }
	                        coord = KhanUtil.kvector.add(
	                            rotatePoint.coord,
	                            KhanUtil.kvector.cartFromPolarDeg(
	                                [oldPolar[0], result]
	                            )
	                        );
	                    }
	                }

	                redrawRotateHandle(coord);

	                rotateHandlePrevCoord = coord;
	                return coord;
	            };

	            rotateHandle.onMoveEnd = function() {
	                isRotating = false;
	                redrawRotateHandle(rotateHandle.coord);
	                if (options.onMoveEnd) {
	                    var oldPolar = KhanUtil.kvector.polarDegFromCart(
	                        KhanUtil.kvector.subtract(
	                            rotateHandleStartCoord,
	                            rotatePoint.coord
	                        )
	                    );
	                    var newPolar = KhanUtil.kvector.polarDegFromCart(
	                        KhanUtil.kvector.subtract(
	                            rotateHandle.coord,
	                            rotatePoint.coord
	                        )
	                    );
	                    options.onMoveEnd(newPolar[1], oldPolar[1]);
	                }
	            };

	            // Remove the default dot added by the movablePoint since we have
	            // our double-arrow thing
	            rotateHandle.visibleShape.remove();

	            if (!mouseTarget) {
	                // Make the default mouse target bigger to encompass the whole
	                // area around the double-arrow thing
	                rotateHandle.mouseTarget.attr({scale: 2});
	            }

	            // Make the arrow-thing grow and shrink with mouseover/out
	            $(rotateHandle.mouseTarget[0]).bind("vmouseover", function(e) {
	                isHovering = true;
	                redrawRotateHandle(rotateHandle.coord);
	            });
	            $(rotateHandle.mouseTarget[0]).bind("vmouseout", function(e) {
	                isHovering = false;
	                redrawRotateHandle(rotateHandle.coord);
	            });

	            redrawRotateHandle(rotateHandle.coord);

	            var oldRemove = rotateHandle.remove;
	            rotateHandle.remove = function() {
	                oldRemove.call(rotateHandle);
	                if (drawnRotateHandle) {
	                    drawnRotateHandle.remove();
	                }
	                $(rotatePoint).off("move." + id);
	            };

	            rotateHandle.update = function() {
	                redrawRotateHandle(rotateHandle.coord);
	            };

	            return rotateHandle;
	        };
	    })(),

	    addReflectButton: (function() {
	        var drawButton = function(
	                graphie,
	                buttonCoord,
	                lineCoords,
	                size,
	                distanceFromCenter,
	                leftStyle,
	                rightStyle) {

	            // Avoid invalid lines
	            if (kpoint.equal(lineCoords[0], lineCoords[1])) {
	                lineCoords = [
	                    lineCoords[0],
	                    kpoint.addVector(lineCoords[0], [1, 1])
	                ];
	            }

	            var lineDirection = kvector.normalize(
	                kvector.subtract(lineCoords[1], lineCoords[0])
	            );

	            var lineVec = kvector.scale(
	                lineDirection,
	                size/2
	            );

	            // Calculate the offset the center points should be placed at
	            var centerVec = kvector.scale(lineDirection, distanceFromCenter);
	            var leftCenterVec = kvector.rotateDeg(centerVec, 90);
	            var rightCenterVec = kvector.rotateDeg(centerVec, -90);

	            // Calculate the offsets for the far points
	            var negLineVec = kvector.negate(lineVec);
	            var leftVec = kvector.rotateDeg(lineVec, 90);
	            var rightVec = kvector.rotateDeg(lineVec, -90);

	            // Calculate the center point locations
	            var leftCenter = kpoint.addVectors(buttonCoord, leftCenterVec);
	            var rightCenter = kpoint.addVectors(buttonCoord, rightCenterVec);

	            // Calculate the far point locations
	            var leftCoord1 = kpoint.addVectors(buttonCoord, leftCenterVec, lineVec, leftVec);
	            var leftCoord2 = kpoint.addVectors(buttonCoord, leftCenterVec, negLineVec, leftVec);
	            var rightCoord1 = kpoint.addVectors(buttonCoord, rightCenterVec, lineVec, rightVec);
	            var rightCoord2 = kpoint.addVectors(buttonCoord, rightCenterVec, negLineVec, rightVec);

	            var leftButton = graphie.path(
	                [leftCenter, leftCoord1, leftCoord2, true],
	                leftStyle
	            );
	            var rightButton = graphie.path(
	                [rightCenter, rightCoord1, rightCoord2, true],
	                rightStyle
	            );

	            return {
	                remove: function() {
	                    leftButton.remove();
	                    rightButton.remove();
	                }
	            };
	        };

	        return function(options) {
	            var graphie = this;

	            var line = options.line;

	            var button = graphie.addMovablePoint({
	                constraints: options.constraints,
	                coord: kline.midpoint([
	                    line.pointA.coord,
	                    line.pointZ.coord
	                ]),
	                snapX: graphie.snap[0],
	                snapY: graphie.snap[1],
	                onMove: function(x, y) {
	                    // Don't allow the button to actually move. This is a hack
	                    // around the inability to both set a point as fixed AND
	                    // allow it to be clicked.
	                    return false;
	                },
	                onMoveEnd: function(x, y) {
	                    if (options.onMoveEnd) {
	                        options.onMoveEnd.call(this, x, y);
	                    }
	                }
	            });

	            var isHovering = false;
	            var isFlipped = false;
	            var currentlyDrawnButton;

	            var isHighlight = function() {
	                return isHovering;
	            };

	            var styles = _.map([0, 1], function(isHighlight) {
	                var baseStyle = isHighlight ?
	                        options.highlightStyle :
	                        options.normalStyle;

	                return _.map([0, 1], function(opacity) {
	                    return _.defaults({
	                        "fill-opacity": opacity
	                    }, baseStyle);
	                });
	            });

	            var getStyle = function(isRight) {
	                if (isFlipped) {
	                    isRight = !isRight;
	                }
	                return styles[+isHighlight()][+isRight];
	            };

	            var redraw = function(coord, lineCoords) {
	                if (currentlyDrawnButton) {
	                    currentlyDrawnButton.remove();
	                }
	                currentlyDrawnButton = drawButton(
	                    graphie,
	                    coord,
	                    lineCoords,
	                    isHighlight() ? options.size * 1.5 : options.size,
	                    isHighlight() ? options.size * 0.125 : 0.25,
	                    getStyle(0),
	                    getStyle(1)
	                );
	            };

	            // Keep the button's position in-sync with the line
	            var update = function(coordA, coordZ) {
	                coordA = coordA || line.pointA.coord;
	                coordZ = coordZ || line.pointZ.coord;

	                var buttonCoord = kline.midpoint([coordA, coordZ]);
	                button.setCoord(buttonCoord);

	                redraw(buttonCoord, [coordA, coordZ]);
	            };

	            $(line).on("move", _.bind(update, button, null, null));

	            // Add click handling
	            $(button.mouseTarget[0]).on("vclick", function() {
	                var result = options.onClick();
	                if (result !== false) {
	                    isFlipped = !isFlipped;
	                    redraw(button.coord,
	                        [line.pointA.coord, line.pointZ.coord]);
	                }
	            });

	            // Bring the reflection line handles in front of the button, so
	            // that if we drag the reflectPoints really close together, we can
	            // still move the handles away from each other, rather than only
	            // being able to apply the reflection.
	            line.pointA.toFront();
	            line.pointZ.toFront();

	            // Replace the visual point with the double triangle thing
	            button.visibleShape.remove();
	            // Resize the hidden point to cover the size of the visual point
	            var pointScale = graphie.scaleVector(options.size)[0] / 20;
	            button.mouseTarget.attr({scale: 1.5 * pointScale});
	            $(button.mouseTarget[0]).css("cursor", "pointer");

	            // Make the arrow-thing grow and shrink with mouseover/out
	            $(button.mouseTarget[0]).bind("vmouseover", function(e) {
	                isHovering = true;
	                redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
	            });
	            $(button.mouseTarget[0]).bind("vmouseout", function(e) {
	                isHovering = false;
	                redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
	            });

	            var oldButtonRemove = button.remove;
	            button.remove = function() {
	                currentlyDrawnButton.remove();
	                oldButtonRemove.call(button);
	            };

	            button.update = update;
	            button.isFlipped = function() {
	                return isFlipped;
	            };

	            update();
	            return button;
	        };
	    })(),

	    protractor: function(center) {
	        return new Protractor(this, center);
	    },

	    ruler: function(options) {
	        return new Ruler(this, options || {});
	    },

	    addPoints: addPoints
	});


	function Protractor(graph, center) {
	    this.set = graph.raphael.set();

	    this.cx = center[0];
	    this.cy = center[1];
	    var pro = this;

	    var r = graph.unscaleVector(180.5)[0];
	    var imgPos = graph.scalePoint([this.cx - r, this.cy + r - graph.unscaleVector(10.5)[1]]);
	    this.set.push(graph.mouselayer.image(
	            "https://ka-perseus-graphie.s3.amazonaws.com/e9d032f2ab8b95979f674fbfa67056442ba1ff6a.png",
	            imgPos[0], imgPos[1], 360, 180));


	    // Customized polar coordinate thingie to make it easier to draw the double-headed arrow thing.
	    // angle is what you'd expect -- use that big protractor on your screen :)
	    // pixels from edge is relative to the edge of the protractor; it's not the full radius
	    var arrowHelper = function(angle, pixelsFromEdge) {
	        var scaledRadius = graph.scaleVector(r);
	        scaledRadius[0] -= 16;
	        scaledRadius[1] -= 16;
	        var scaledCenter = graph.scalePoint(center);
	        var x = Math.sin((angle + 90) * Math.PI / 180) * (scaledRadius[0] + pixelsFromEdge) + scaledCenter[0];
	        var y = Math.cos((angle + 90) * Math.PI / 180) * (scaledRadius[1] + pixelsFromEdge) + scaledCenter[1];
	        return x + "," + y;
	    };

	    // Draw the double-headed arrow thing that shows users where to click and drag to rotate
	    var arrow = graph.raphael.path(
	        " M" + arrowHelper(180, 6) +
	        " L" + arrowHelper(180, 2) +
	        " L" + arrowHelper(183, 10) +
	        " L" + arrowHelper(180, 18) +
	        " L" + arrowHelper(180, 14) +
	        " A" + (graph.scaleVector(r)[0] + 10) + "," + (graph.scaleVector(r)[1] + 10) + ",0,0,1," + arrowHelper(170, 14) +
	        " L" + arrowHelper(170, 18) +
	        " L" + arrowHelper(167, 10) +
	        " L" + arrowHelper(170, 2) +
	        " L" + arrowHelper(170, 6) +
	        " A" + (graph.scaleVector(r)[0] + 10) + "," + (graph.scaleVector(r)[1] + 10) + ",0,0,0," + arrowHelper(180, 6) +
	        " Z"
	    ).attr({
	        "stroke": null,
	        "fill": KhanUtil.INTERACTIVE
	    });

	    // add it to the set so it translates with everything else
	    this.set.push(arrow);

	    this.centerPoint = graph.addMovablePoint({
	        coord: center,
	        visible: false
	    });

	    // Use a movablePoint for rotation
	    this.rotateHandle = graph.addMovablePoint({
	        coord: [
	            Math.sin(275 * Math.PI / 180) * (r + 0.5) + this.cx,
	            Math.cos(275 * Math.PI / 180) * (r + 0.5) + this.cy
	        ],
	        onMove: function(x, y) {
	            var angle = Math.atan2(pro.centerPoint.coord[1] - y, pro.centerPoint.coord[0] - x) * 180 / Math.PI;
	            pro.rotate(-angle - 5, true);
	        }
	    });

	    // Add a constraint so the point moves in a circle
	    this.rotateHandle.constraints.fixedDistance.dist = r + 0.5;
	    this.rotateHandle.constraints.fixedDistance.point = this.centerPoint;

	    // Remove the default dot added by the movablePoint since we have our double-arrow thing
	    this.rotateHandle.visibleShape.remove();
	    // Make the mouse target bigger to encompass the whole area around the double-arrow thing
	    this.rotateHandle.mouseTarget.attr({ scale: 2.0 });

	    // Make the arrow-thing grow and shrink with mouseover/out
	    var isDragging = false;
	    var isHovering = false;
	    var isHighlight = function() {
	        return isHovering || isDragging;
	    };

	    var self = this;
	    $(self.rotateHandle.mouseTarget[0]).bind("vmousedown", function(event) {
	        isDragging = true;
	        arrow.animate({ scale: 1.5, fill: KhanUtil.INTERACTING }, 50);

	        $(document).bind("vmouseup.rotateHandle", function(event) {
	            isDragging = false;

	            if (!isHighlight()) {
	                arrow.animate({ scale: 1.0, fill: KhanUtil.INTERACTIVE }, 50);
	            }

	            $(document).unbind("vmouseup.rotateHandle");
	        });
	    });

	    $(self.rotateHandle.mouseTarget[0]).bind("vmouseover", function(event) {
	        isHovering = true;
	        arrow.animate({ scale: 1.5, fill: KhanUtil.INTERACTING }, 50);
	    });
	    $(self.rotateHandle.mouseTarget[0]).bind("vmouseout", function(event) {
	        isHovering = false;
	        if (!isHighlight()) {
	            arrow.animate({ scale: 1.0, fill: KhanUtil.INTERACTIVE }, 50);
	        }
	    });

	    var setNodes = $.map(this.set, function(el) { return el.node; });
	    this.makeTranslatable = function makeTranslatable() {
	        $(setNodes).css("cursor", "move");

	        $(setNodes).bind("vmousedown", function(event) {
	            event.preventDefault();
	            var startx = event.pageX - $(graph.raphael.canvas.parentNode).offset().left;
	            var starty = event.pageY - $(graph.raphael.canvas.parentNode).offset().top;

	            $(document).bind("vmousemove.protractor", function(event) {
	                // mouse{X|Y} are in pixels relative to the SVG
	                var mouseX = event.pageX - $(graph.raphael.canvas.parentNode).offset().left;
	                var mouseY = event.pageY - $(graph.raphael.canvas.parentNode).offset().top;
	                // can't go beyond 10 pixels from the edge
	                mouseX = Math.max(10, Math.min(graph.xpixels - 10, mouseX));
	                mouseY = Math.max(10, Math.min(graph.ypixels - 10, mouseY));

	                var dx = mouseX - startx;
	                var dy = mouseY - starty;

	                $.each(pro.set.items, function() {
	                    this.translate(dx, dy);
	                });
	                pro.centerPoint.setCoord([pro.centerPoint.coord[0] + dx / graph.scale[0], pro.centerPoint.coord[1] - dy / graph.scale[1]]);
	                pro.rotateHandle.setCoord([pro.rotateHandle.coord[0] + dx / graph.scale[0], pro.rotateHandle.coord[1] - dy / graph.scale[1]]);
	                startx = mouseX;
	                starty = mouseY;
	            });

	            $(document).one("vmouseup", function(event) {
	                $(document).unbind("vmousemove.protractor");
	            });
	        });
	    };


	    this.rotation = 0;

	    this.rotate = function(offset, absolute) {
	        var center = graph.scalePoint(this.centerPoint.coord);

	        if (absolute) {
	            this.rotation = 0;
	        }

	        this.set.rotate(this.rotation + offset, center[0], center[1]);
	        this.rotation = this.rotation + offset;

	        return this;
	    };

	    this.moveTo = function moveTo(x, y) {
	        var start = graph.scalePoint(pro.centerPoint.coord);
	        var end = graph.scalePoint([x, y]);
	        var time = KhanUtil.getDistance(start, end) * 2;  // 2ms per pixel

	        $({ x: start[0], y: start[1] }).animate({ x: end[0], y: end[1] }, {
	            duration: time,
	            step: function(now, fx) {
	                var dx = 0;
	                var dy = 0;
	                if (fx.prop === "x") {
	                    dx = now - graph.scalePoint(pro.centerPoint.coord)[0];
	                } else if (fx.prop === "y") {
	                    dy = now - graph.scalePoint(pro.centerPoint.coord)[1];
	                }
	                $.each(pro.set.items, function() {
	                    this.translate(dx, dy);
	                });
	                pro.centerPoint.setCoord([pro.centerPoint.coord[0] + dx / graph.scale[0], pro.centerPoint.coord[1] - dy / graph.scale[1]]);
	                pro.rotateHandle.setCoord([pro.rotateHandle.coord[0] + dx / graph.scale[0], pro.rotateHandle.coord[1] - dy / graph.scale[1]]);
	            }
	        });
	    };

	    this.rotateTo = function rotateTo(angle) {
	        if (Math.abs(this.rotation - angle) > 180) {
	            this.rotation += 360;
	        }
	        var time = Math.abs(this.rotation - angle) * 5;  // 5ms per deg
	        $({ 0: this.rotation }).animate({ 0: angle }, {
	            duration: time,
	            step: function(now, fx) {
	                pro.rotate(now, true);
	                pro.rotateHandle.setCoord([
	                    Math.sin((now + 275) * Math.PI / 180) * (r + 0.5) + pro.centerPoint.coord[0],
	                    Math.cos((now + 275) * Math.PI / 180) * (r + 0.5) + pro.centerPoint.coord[1]
	                ]);
	            }
	        });
	    };

	    this.remove = function() {
	        this.set.remove();
	    };

	    this.makeTranslatable();
	    return this;
	}

	function Ruler(graphie, options) {
	    _.defaults(options, {
	        center: [0, 0],
	        pixelsPerUnit: 40,
	        ticksPerUnit: 10,   // 10 or power of 2
	        units: 10,          // the length the ruler can measure
	        label: "",          // e.g "cm" (the shorter, the better)
	        style: {
	            fill: null,
	            stroke: KhanUtil.GRAY
	        }
	    });

	    var light = _.extend({}, options.style, {strokeWidth: 1});
	    var bold  = _.extend({}, options.style, {strokeWidth: 2});

	    // Ruler dimensions in pixels
	    var width = options.units * options.pixelsPerUnit;
	    var height = 50;        // arbitrary, but looks good

	    // Bottom left corner of the ruler in graphie units
	    var leftBottom = graphie.unscalePoint(
	        kvector.subtract(
	            graphie.scalePoint(options.center),
	            kvector.scale([width, -height], 0.5)
	        )
	    );

	    var graphieUnitsPerUnit = options.pixelsPerUnit / graphie.scale[0];
	    var graphieUnitsHeight = height / graphie.scale[0];

	    // Top right corner of the ruler in graphie units
	    var rightTop = kvector.add(
	        leftBottom,
	        [options.units * graphieUnitsPerUnit, graphieUnitsHeight]
	    );

	    var tickHeight = 1.0;   // percent of ruler height
	    var tickHeightMap;      // mapping of tick frequency to tick height
	                            // {n: h} means every n-th tick will have height h

	    if (options.ticksPerUnit === 10) {
	        // decimal, as on a centimeter ruler
	        tickHeightMap = {
	            10: tickHeight,
	            5:  tickHeight * 0.55,
	            1:  tickHeight * 0.35
	        };
	    } else {
	        // powers of 2, as on an inch ruler
	        var sizes = [1, 0.6, 0.45, 0.3];

	        tickHeightMap = {};
	        for (var i = options.ticksPerUnit; i >= 1; i /= 2) {
	            tickHeightMap[i] = tickHeight * (sizes.shift() || 0.2);
	        }
	    }

	    var tickFrequencies = _.keys(tickHeightMap).sort(function(a, b) {
	        return b - a;
	    });

	    function getTickHeight(i) {
	        for (var k = 0; k < tickFrequencies.length; k++) {
	            var key = tickFrequencies[k];
	            if (i % key === 0) {
	                return tickHeightMap[key];
	            }
	        }
	    }

	    // Draw the ruler
	    var left = leftBottom[0];
	    var bottom = leftBottom[1];
	    var right = rightTop[0];
	    var top = rightTop[1];

	    var numTicks = options.units * options.ticksPerUnit + 1;

	    var set = graphie.raphael.set();

	    var px = 1 / graphie.scale[0]; // one pixel
	    set.push(graphie.line([left - px, bottom], [right + px, bottom], bold));
	    set.push(graphie.line([left - px, top], [right + px, top], bold));

	    _.times(numTicks, function(i) {
	        var n = i / options.ticksPerUnit;
	        var x = left + n * graphieUnitsPerUnit;
	        var height = getTickHeight(i) * graphieUnitsHeight;

	        var style = (i === 0 || i === numTicks - 1) ? bold : light;
	        set.push(graphie.line([x, bottom], [x, bottom + height], style));

	        if (n % 1 === 0) {
	            // Graphie labels are difficult to rotate in IE8,
	            // so use raphael.text() instead
	            var coord = graphie.scalePoint([x, top]);
	            var text;
	            var offset;

	            if (n === 0) {
	                // Unit label
	                text = options.label;
	                offset = {
	                    mm: 13,
	                    cm: 11,
	                    m: 8,
	                    km: 11,
	                    in: 8,
	                    ft: 8,
	                    yd: 10,
	                    mi: 10
	                }[text] || (3 * text.toString().length);
	            } else {
	                // Tick label
	                text = n;
	                offset = -3 * (n.toString().length + 1);
	            }
	            var label = graphie.raphael.text(
	                coord[0] + offset,
	                coord[1] + 10,
	                text
	            );
	            label.attr({
	                "font-family": "katex_main",
	                "font-size": "12px",
	                "color": "#444"
	            });
	            set.push(label);
	        }
	    });

	    // Add a mouse target
	    var mouseTarget = graphie.mouselayer.path(KhanUtil.svgPath([
	        leftBottom, [left, top], rightTop, [right, bottom], /* closed */ true
	    ]));
	    mouseTarget.attr({
	        fill: "#000",
	        opacity: 0,
	        stroke: "#000",
	        "stroke-width": 2
	    });
	    set.push(mouseTarget);

	    var setNodes = $.map(set, function(el) { return el.node; });
	    $(setNodes).css("cursor", "move");

	    $(setNodes).bind("vmousedown", function(event) {
	        event.preventDefault();
	        var startx = event.pageX - $(graphie.raphael.canvas.parentNode).offset().left;
	        var starty = event.pageY - $(graphie.raphael.canvas.parentNode).offset().top;

	        $(document).bind("vmousemove.ruler", function(event) {
	            // mouse{X|Y} are in pixels relative to the SVG
	            var mouseX = event.pageX - $(graphie.raphael.canvas.parentNode).offset().left;
	            var mouseY = event.pageY - $(graphie.raphael.canvas.parentNode).offset().top;
	            // can't go beyond 10 pixels from the edge
	            mouseX = Math.max(10, Math.min(graphie.xpixels - 10, mouseX));
	            mouseY = Math.max(10, Math.min(graphie.ypixels - 10, mouseY));

	            var dx = mouseX - startx;
	            var dy = mouseY - starty;

	            set.translate(dx, dy);
	            leftBottomHandle.setCoord([leftBottomHandle.coord[0] + dx / graphie.scale[0], leftBottomHandle.coord[1] - dy / graphie.scale[1]]);
	            rightBottomHandle.setCoord([rightBottomHandle.coord[0] + dx / graphie.scale[0], rightBottomHandle.coord[1] - dy / graphie.scale[1]]);

	            startx = mouseX;
	            starty = mouseY;
	        });

	        $(document).one("vmouseup", function(event) {
	            $(document).unbind("vmousemove.ruler");
	        });
	    });

	    // Handles for rotation
	    var leftBottomHandle = graphie.addMovablePoint({
	        coord: leftBottom,
	        normalStyle: {
	            fill: KhanUtil.INTERACTIVE,
	            "fill-opacity": 0,
	            stroke: KhanUtil.INTERACTIVE
	        },
	        highlightStyle: {
	            fill: KhanUtil.INTERACTING,
	            "fill-opacity": 0.1,
	            stroke: KhanUtil.INTERACTING
	        },
	        pointSize: 6, // or 8 maybe?
	        onMove: function(x, y) {
	            var dy = rightBottomHandle.coord[1] - y;
	            var dx = rightBottomHandle.coord[0] - x;
	            var angle = Math.atan2(dy, dx) * 180 / Math.PI;
	            var center = kvector.scale(kvector.add([x, y], rightBottomHandle.coord), 0.5);
	            var scaledCenter = graphie.scalePoint(center);
	            var oldCenter = kvector.scale(kvector.add(leftBottomHandle.coord, rightBottomHandle.coord), 0.5);
	            var scaledOldCenter = graphie.scalePoint(oldCenter);
	            var diff = kvector.subtract(scaledCenter, scaledOldCenter);
	            set.rotate(-angle, scaledOldCenter[0], scaledOldCenter[1]);
	            set.translate(diff[0], diff[1]);
	        }
	    });
	    var rightBottomHandle = graphie.addMovablePoint({
	        coord: [right, bottom],
	        normalStyle: {
	            fill: KhanUtil.INTERACTIVE,
	            "fill-opacity": 0,
	            stroke: KhanUtil.INTERACTIVE
	        },
	        highlightStyle: {
	            fill: KhanUtil.INTERACTING,
	            "fill-opacity": 0.1,
	            stroke: KhanUtil.INTERACTING
	        },
	        pointSize: 6, // or 8 maybe?
	        onMove: function(x, y) {
	            var dy = y - leftBottomHandle.coord[1];
	            var dx = x - leftBottomHandle.coord[0];
	            var angle = Math.atan2(dy, dx) * 180 / Math.PI;
	            var center = kvector.scale(kvector.add([x, y], leftBottomHandle.coord), 0.5);
	            var scaledCenter = graphie.scalePoint(center);
	            var oldCenter = kvector.scale(kvector.add(leftBottomHandle.coord, rightBottomHandle.coord), 0.5);
	            var scaledOldCenter = graphie.scalePoint(oldCenter);
	            var diff = kvector.subtract(scaledCenter, scaledOldCenter);
	            set.rotate(-angle, scaledOldCenter[0], scaledOldCenter[1]);
	            set.translate(diff[0], diff[1]);
	        }
	    });

	    // Make each handle rotate the ruler about the other one
	    leftBottomHandle.constraints.fixedDistance.dist = width / graphie.scale[0];
	    leftBottomHandle.constraints.fixedDistance.point = rightBottomHandle;
	    rightBottomHandle.constraints.fixedDistance.dist = width / graphie.scale[0];
	    rightBottomHandle.constraints.fixedDistance.point = leftBottomHandle;

	    this.remove = function() {
	        set.remove();
	        leftBottomHandle.remove();
	        rightBottomHandle.remove();
	    };

	    return this;
	}

	function MovableAngle(graphie, options) {
	    this.graphie = graphie;

	    // TODO(alex): Move standard colors from math.js to somewhere else
	    // so that they are available when this file is first parsed
	    _.extend(this, options);
	    _.defaults(this, {
	        normalStyle: {
	            "stroke": KhanUtil.INTERACTIVE,
	            "stroke-width": 2,
	            "fill": KhanUtil.INTERACTIVE
	        },
	        highlightStyle: {
	            "stroke": KhanUtil.INTERACTING,
	            "stroke-width": 2,
	            "fill": KhanUtil.INTERACTING
	        },
	        labelStyle: {
	            "stroke": KhanUtil.DYNAMIC,
	            "stroke-width": 1,
	            "color": KhanUtil.DYNAMIC
	        },
	        angleStyle: {
	            "stroke": KhanUtil.DYNAMIC,
	            "stroke-width": 1,
	            "color": KhanUtil.DYNAMIC
	        },
	        allowReflex: true // not on MovableAngle.prototype so that
	                          // it is not overridden by undefined
	    });

	    if (!this.points || this.points.length !== 3) {
	        throw new Error("MovableAngle requires 3 points");
	    }

	    // Handle coordinates that are not MovablePoints (i.e. [2, 4])
	    this.points = _.map(options.points, function(point) {
	        if (_.isArray(point)) {
	            return graphie.addMovablePoint({
	                coord: point,
	                visible: false,
	                constraints: {
	                    fixed: true
	                },
	                normalStyle: this.normalStyle
	            });
	        } else {
	            return point;
	        }
	    }, this);
	    this.coords = _.pluck(this.points, "coord");
	    if (this.reflex == null) {
	        if (this.allowReflex) {
	            this.reflex = (this._getClockwiseAngle(this.coords) > 180);
	        } else {
	            this.reflex = false;
	        }
	    }

	    this.rays = _.map([0, 2], function(i) {
	        return graphie.addMovableLineSegment({
	            pointA: this.points[1],
	            pointZ: this.points[i],
	            fixed: true,
	            extendRay: true
	        });
	    }, this);

	    this.temp = [];
	    this.labeledAngle = graphie.label([0, 0], "", "center", this.labelStyle);

	    if (!this.fixed) {
	        this.addMoveHandlers();
	        this.addHighlightHandlers();
	    }
	    this.update();
	}

	_.extend(MovableAngle.prototype, {
	    points: [],
	    snapDegrees: 0,
	    snapOffsetDeg: 0,
	    angleLabel: "",
	    numArcs: 1,
	    pushOut: 0,
	    fixed: false,

	    addMoveHandlers: function() {
	        var graphie = this.graphie;

	        function tooClose(point1, point2) {
	            // Vertex and ray points can't be closer than this many pixels
	            var safeDistance = 30;
	            var distance = KhanUtil.getDistance(
	                graphie.scalePoint(point1),
	                graphie.scalePoint(point2)
	            );
	            return distance < safeDistance;
	        }

	        var points = this.points;

	        // Drag the vertex to move the entire angle
	        points[1].onMove = function(x, y) {
	            var oldVertex = points[1].coord;
	            var newVertex = [x, y];
	            var delta = addPoints(newVertex, reverseVector(oldVertex));

	            var valid = true;
	            var newPoints = {};
	            _.each([0, 2], function(i) {
	                var oldPoint = points[i].coord;
	                var newPoint = addPoints(oldPoint, delta);

	                // Constrain ray points to stay the same angle from vertex
	                var angle = KhanUtil.findAngle(newVertex, newPoint);
	                angle *= Math.PI / 180;
	                newPoint = graphie.constrainToBoundsOnAngle(newPoint, 10, angle);
	                newPoints[i] = newPoint;

	                if (tooClose(newVertex, newPoint)) {
	                    valid = false;
	                }
	            });

	            // Only move points if all new positions are valid
	            if (valid) {
	                _.each(newPoints, function(newPoint, i) {
	                    points[i].setCoord(newPoint);
	                });
	            }
	            return valid;
	        };

	        var snap = this.snapDegrees;
	        var snapOffset = this.snapOffsetDeg;

	        // Drag ray control points to move each ray individually
	        _.each([0, 2], function(i) {
	            points[i].onMove = function(x, y) {
	                var newPoint = [x, y];
	                var vertex = points[1].coord;

	                if (tooClose(vertex, newPoint)) {
	                    return false;
	                } else if (snap) {
	                    var angle = KhanUtil.findAngle(newPoint, vertex);
	                    angle = Math.round((angle - snapOffset) / snap) * snap +
	                            snapOffset;
	                    var distance = KhanUtil.getDistance(newPoint, vertex);
	                    return addPoints(vertex, graphie.polar(distance, angle));
	                } else {
	                    return true;
	                }
	            };
	        });

	        // Expose only a single move event
	        $(points).on("move", function() {
	            this.update();
	            $(this).trigger("move");
	        }.bind(this));
	    },

	    addHighlightHandlers: function() {
	        var vertex = this.points[1];

	        vertex.onHighlight = function() {
	            _.each(this.points, function(point) {
	                point.visibleShape.animate(this.highlightStyle, 50);
	            }, this);
	            _.each(this.rays, function(ray) {
	                ray.visibleLine.animate(this.highlightStyle, 50);
	                ray.arrowStyle = _.extend({}, ray.arrowStyle, {
	                    "color": this.highlightStyle.stroke,
	                    "stroke": this.highlightStyle.stroke
	                });
	            }, this);

	            this.angleStyle = _.extend({}, this.angleStyle, {
	                "color": this.highlightStyle.stroke,
	                "stroke": this.highlightStyle.stroke
	            });
	            this.update();

	        }.bind(this);

	        vertex.onUnhighlight = function() {
	            _.each(this.points, function(point) {
	                point.visibleShape.animate(this.normalStyle, 50);
	            }, this);
	            _.each(this.rays, function(ray) {
	                ray.visibleLine.animate(ray.normalStyle, 50);
	                ray.arrowStyle = _.extend({}, ray.arrowStyle, {
	                    "color": ray.normalStyle.stroke,
	                    "stroke": ray.normalStyle.stroke
	                });
	            }, this);

	            this.angleStyle = _.extend({}, this.angleStyle, {
	                "color": KhanUtil.DYNAMIC,
	                "stroke": KhanUtil.DYNAMIC
	            });
	            this.update();

	        }.bind(this);
	    },

	    /**
	     * Returns the angle in [0, 360) degrees created by the
	     * coords when interpreted in a clockwise direction.
	     */
	    _getClockwiseAngle: function(coords) {
	        // TODO(jack): Add this to a kangle.js
	        var clockwiseAngle = (KhanUtil.findAngle(
	            // The order of these is "weird" to match what a clockwise
	            // order is in graphie.labelAngle
	            coords[2], // from the second point
	            coords[0], // clockwise to the first point
	            coords[1] // the vertex parameter is last
	        ) + 360) % 360;

	        return clockwiseAngle;
	    },

	    isReflex: function() {
	        return this.reflex;
	    },

	    isClockwise: function() {
	        var clockwiseReflexive = (this._getClockwiseAngle(this.coords) > 180);
	        return clockwiseReflexive === this.reflex;
	    },

	    getClockwiseCoords: function() {
	        if (this.isClockwise()) {
	            return _.clone(this.coords);
	        } else {
	            return _.clone(this.coords).reverse();
	        }
	    },

	    update: function(shouldChangeReflexivity) {
	        // Update coords
	        var prevCoords = this.coords;
	        this.coords = _.pluck(this.points, "coord");

	        // Update lines
	        _.invoke(this.points, "updateLineEnds");

	        var prevAngle = this._getClockwiseAngle(prevCoords);
	        var angle = this._getClockwiseAngle(this.coords);
	        var prevClockwiseReflexive = (prevAngle > 180);
	        var clockwiseReflexive = (angle > 180);

	        if (this.allowReflex) {
	            if (shouldChangeReflexivity == null) {
	                shouldChangeReflexivity =
	                        (prevClockwiseReflexive !== clockwiseReflexive) &&
	                        (Math.abs(angle - prevAngle) < 180);
	            }

	            if (shouldChangeReflexivity) {
	                this.reflex = !this.reflex;
	            }
	        }

	        _.invoke(this.temp, "remove");
	        this.temp = this.graphie.labelAngle({
	            point1: this.coords[0],
	            vertex: this.coords[1],
	            point3: this.coords[2],
	            label: this.labeledAngle,
	            text: this.angleLabel,
	            numArcs: this.numArcs,
	            pushOut: this.pushOut,
	            clockwise: this.reflex === clockwiseReflexive,
	            style: this.angleStyle
	        });
	    },

	    remove: function() {
	        _.invoke(this.rays, "remove");
	        _.invoke(this.temp, "remove");
	        this.labeledAngle.remove();
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Line Utils
	 * A line is an array of two points e.g. [[-5, 0], [5, 0]].
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var kpoint = __webpack_require__(7);
	var kvector = __webpack_require__(9);
	var knumber = __webpack_require__(6);

	var kline = KhanUtil.kline = {

	    distanceToPoint: function(line, point) {
	        return kpoint.distanceToLine(point, line);
	    },

	    reflectPoint: function(line, point) {
	        return kpoint.reflectOverLine(point, line);
	    },

	    midpoint: function(line) {
	        return [
	            (line[0][0] + line[1][0]) / 2,
	            (line[0][1] + line[1][1]) / 2
	        ];
	    },

	    /**
	    * Tests if two lines are collinear.
	    * https://en.wikipedia.org/wiki/Collinearity
	    */
	    equal: function(line1, line2, tolerance) {
	        /**
	        * line1's points are trivially collinear.
	        * So check against each point in line2.
	        * Form a triangle of the points (line1 and a single point from line2)
	        * iff the area of the triangle is zero, are the points collinear
	        * http://mathworld.wolfram.com/Collinear.html
	        */
	        var x1 = line1[0][0];
	        var y1 = line1[0][1];
	        var x2 = line1[1][0];
	        var y2 = line1[1][1];
	        return _.every(line2, function(point) {
	            var x3 = point[0];
	            var y3 = point[1];
	            
	            //calculating area of triangle formed by the three points
	            //https://en.wikipedia.org/wiki/Shoelace_formula#Examples
	            //A = 1/2|x1*y2 + x2*y3 + x3*y1 - x2*y1 - x3*y2 - x1*y3|
	            var area = (1/2)*Math.abs(x1*y2 + x2*y3 + x3*y1 -
	                x2*y1 - x3*y2 - x1*y3);

	            return knumber.equal(area, 0, tolerance);
	        });
	    },

	    intersect: function(px, py, rx, ry, qx, qy, sx, sy) {
	        // Returns true is the line from (px, py) to (rx, ry) intersections the line (qx, qy) to (sx, sy)
	        // http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#565282
	        function cross(vx, vy, wx, wy) {
	            return vx * wy - vy * wx;
	        }

	        if (cross(rx, ry, sx, sy) === 0) {
	            return cross(qx - px, qy - py, rx, ry) === 0;
	        } else {
	            var t = cross(qx - px, qy - py, sx, sy) / cross(rx, ry, sx, sy);
	            var u = cross(qx - px, qy - py, rx, ry) / cross(rx, ry, sx, sy);
	            return 0 <= t && t <= 1 && 0 <= u && u <= 1;
	        }
	    }
	};

	return kline;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Number Utils
	 * A number is a js-number, e.g. 5.12
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var DEFAULT_TOLERANCE = 1e-9;
	var EPSILON = Math.pow(2, -42);

	var knumber = KhanUtil.knumber = {

	    DEFAULT_TOLERANCE: DEFAULT_TOLERANCE,
	    EPSILON: EPSILON,

	    is: function(x) {
	        return _.isNumber(x) && !_.isNaN(x);
	    },

	    equal: function(x, y, tolerance) {
	        // Checking for undefined makes this function behave nicely
	        // with vectors of different lengths that are _.zip'd together
	        if (x == null || y == null) {
	            return x === y;
	        }
	        if (tolerance == null) {
	            tolerance = DEFAULT_TOLERANCE;
	        }
	        return Math.abs(x - y) < tolerance;
	    },

	    sign: function(x, tolerance) {
	        return knumber.equal(x, 0, tolerance) ? 0 : Math.abs(x) / x;
	    },

	    // Round a number to a certain number of decimal places
	    round: function(num, precision) {
	        var factor = Math.pow(10, precision);
	        return Math.round(num * factor) / factor;
	    },

	    // Round num to the nearest multiple of increment
	    // i.e. roundTo(83, 5) -> 85
	    roundTo: function(num, increment) {
	        return Math.round(num / increment) * increment;
	    },

	    floorTo: function(num, increment) {
	        return Math.floor(num / increment) * increment;
	    },

	    ceilTo: function(num, increment) {
	        return Math.ceil(num / increment) * increment;
	    },

	    isInteger: function(num, tolerance) {
	        return knumber.equal(Math.round(num), num, tolerance);
	    },

	    /**
	     * toFraction
	     *
	     * Returns a [numerator, denominator] array rational representation
	     * of `decimal`
	     *
	     * See http://en.wikipedia.org/wiki/Continued_fraction for implementation
	     * details
	     *
	     * toFraction(4/8) => [1, 2]
	     * toFraction(0.66) => [33, 50]
	     * toFraction(0.66, 0.01) => [2/3]
	     * toFraction(283 + 1/3) => [850, 3]
	     */
	    toFraction: function(decimal, tolerance, max_denominator) {
	        max_denominator = max_denominator || 1000;
	        tolerance = tolerance || EPSILON; // can't be 0

	        // Initialize everything to compute successive terms of
	        // continued-fraction approximations via recurrence relation
	        var n = [1, 0], d = [0, 1];
	        var a = Math.floor(decimal), t;
	        var rem = decimal - a;

	        while (d[0] <= max_denominator) {
	            if (knumber.equal(n[0] / d[0], decimal, tolerance)) {
	                return [n[0], d[0]];
	            }
	            n = [a*n[0] + n[1], n[0]];
	            d = [a*d[0] + d[1], d[0]];
	            a = Math.floor(1 / rem);
	            rem = 1/rem - a;
	        }

	        // We failed to find a nice rational representation,
	        // so return an irrational "fraction"
	        return [decimal, 1];
	    }
	};

	return knumber;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Point Utils
	 * A point is an array of two numbers e.g. [0, 0].
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var kvector = __webpack_require__(9);
	var knumber = __webpack_require__(6);

	var kpoint = KhanUtil.kpoint = {

	    // Rotate point (around origin unless a center is specified)
	    rotateRad: function(point, theta, center) {
	        if (center === undefined) {
	            return kvector.rotateRad(point, theta);
	        } else {
	            return kvector.add(
	                center,
	                kvector.rotateRad(
	                    kvector.subtract(point, center),
	                    theta
	                )
	            );
	        }
	    },

	    rotateDeg: function(point, theta, center) {
	        if (center === undefined) {
	            return kvector.rotateDeg(point, theta);
	        } else {
	            return kvector.add(
	                center,
	                kvector.rotateDeg(
	                    kvector.subtract(point, center),
	                    theta
	                )
	            );
	        }
	    },

	    // Distance between two points
	    distanceToPoint: function(point1, point2) {
	        return kvector.length(kvector.subtract(point1, point2));
	    },

	    // Distance between point and line
	    distanceToLine: function(point, line) {
	        var lv = kvector.subtract(line[1], line[0]);
	        var pv = kvector.subtract(point, line[0]);
	        var projectedPv = kvector.projection(pv, lv);
	        var distancePv = kvector.subtract(projectedPv, pv);
	        return kvector.length(distancePv);
	    },

	    // Reflect point over line
	    reflectOverLine: function(point, line) {
	        var lv = kvector.subtract(line[1], line[0]);
	        var pv = kvector.subtract(point, line[0]);
	        var projectedPv = kvector.projection(pv, lv);
	        var reflectedPv = kvector.subtract(kvector.scale(projectedPv, 2), pv);
	        return kvector.add(line[0], reflectedPv);
	    },

	    /**
	     * Compares two points, returning -1, 0, or 1, for use with
	     * Array.prototype.sort
	     *
	     * Note: This technically doesn't satisfy the total-ordering
	     * requirements of Array.prototype.sort unless equalityTolerance
	     * is 0. In some cases very close points that compare within a
	     * few equalityTolerances could appear in the wrong order.
	     */
	    compare: function(point1, point2, equalityTolerance) {
	        if (point1.length !== point2.length) {
	            return point1.length - point2.length;
	        }
	        for (var i = 0; i < point1.length; i++) {
	            if (!knumber.equal(point1[i], point2[i], equalityTolerance)) {
	                return point1[i] - point2[i];
	            }
	        }
	        return 0;
	    }
	};

	_.extend(kpoint, {
	    // Check if a value is a point
	    is: kvector.is,

	    // Add and subtract vector(s)
	    addVector: kvector.add,
	    addVectors: kvector.add,
	    subtractVector: kvector.subtract,
	    equal: kvector.equal,

	    // Convert from cartesian to polar and back
	    polarRadFromCart: kvector.polarRadFromCart,
	    polarDegFromCart: kvector.polarDegFromCart,
	    cartFromPolarRad: kvector.cartFromPolarRad,
	    cartFromPolarDeg: kvector.cartFromPolarDeg,

	    // Rounding
	    round: kvector.round,
	    roundTo: kvector.roundTo,
	    floorTo: kvector.floorTo,
	    ceilTo: kvector.ceilTo
	});

	return kpoint;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Ray Utils
	 * A ray is an array of an endpoint and another point along the ray.
	 * For example, [[0, 0], [1, 0]] is the ray starting at the origin and
	 * traveling along the positive x-axis.
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var kvector = __webpack_require__(9);
	var kpoint = __webpack_require__(7);

	var kray = KhanUtil.kray = {

	    equal: function(ray1, ray2, tolerance) {
	        // Compare the directions of the rays
	        var v1 = kvector.subtract(ray1[1],ray1[0]);
	        var v2 = kvector.subtract(ray2[1],ray2[0]);

	        var sameOrigin = kpoint.equal(ray1[0], ray2[0]);
	        var codirectional = kvector.codirectional(v1, v2, tolerance);

	        return sameOrigin && codirectional;
	    }
	};

	return kray;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Vector Utils 
	 * A vector is an array of numbers e.g. [0, 3, 4].
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var knumber = __webpack_require__(6);

	function arraySum(array) {
	    return _.reduce(array, function(memo, arg) { return memo + arg; }, 0);
	}

	function arrayProduct(array) {
	    return _.reduce(array, function(memo, arg) { return memo * arg; }, 1);
	}

	var kvector = KhanUtil.kvector = {

	    is: function(vec, length) {
	        if (!_.isArray(vec)) {
	            return false;
	        }
	        if (length !== undefined && vec.length !== length) {
	            return false;
	        }
	        return _.all(vec, knumber.is);
	    },

	    // Normalize to a unit vector
	    normalize: function(v) {
	        return kvector.scale(v, 1 / kvector.length(v));
	    },

	    // Length/magnitude of a vector
	    length: function(v) {
	        return Math.sqrt(kvector.dot(v, v));
	    },

	    // Dot product of two vectors
	    dot: function(a, b) {
	        var vecs = _.toArray(arguments);
	        var zipped = _.zip.apply(_, vecs);
	        var multiplied = _.map(zipped, arrayProduct);
	        return arraySum(multiplied);
	    },

	    /* vector-add multiple [x, y] coords/vectors
	     *
	     * kvector.add([1, 2], [3, 4]) -> [4, 6]
	     */
	    add: function() {
	        var points = _.toArray(arguments);
	        var zipped = _.zip.apply(_, points);
	        return _.map(zipped, arraySum);
	    },

	    subtract: function(v1, v2) {
	        return _.map(_.zip(v1, v2), function(dim) {
	            return dim[0] - dim[1];
	        });
	    },

	    negate: function(v) {
	        return _.map(v, function(x) {
	            return -x;
	        });
	    },

	    // Scale a vector
	    scale: function(v1, scalar) {
	        return _.map(v1, function(x) {
	            return x * scalar;
	        });
	    },

	    equal: function(v1, v2, tolerance) {
	        // _.zip will nicely deal with the lengths, going through
	        // the length of the longest vector. knumber.equal then
	        // returns false for any number compared to the undefined
	        // passed in if one of the vectors is shorter.
	        return _.all(_.zip(v1, v2), function(pair) {
	            return knumber.equal(pair[0], pair[1], tolerance);
	        });
	    },

	    codirectional: function(v1, v2, tolerance) {
	        // The origin is trivially codirectional with all other vectors.
	        // This gives nice semantics for codirectionality between points when
	        // comparing their difference vectors.
	        if (knumber.equal(kvector.length(v1), 0, tolerance) ||
	                knumber.equal(kvector.length(v2), 0, tolerance)) {
	            return true;
	        }

	        v1 = kvector.normalize(v1);
	        v2 = kvector.normalize(v2);

	        return kvector.equal(v1, v2, tolerance);
	    },

	    collinear: function(v1, v2, tolerance) {
	        return kvector.codirectional(v1, v2, tolerance) ||
	                kvector.codirectional(v1, kvector.negate(v2), tolerance);
	    },

	    // Convert a cartesian coordinate into a radian polar coordinate
	    polarRadFromCart: function(v) {
	        var radius = kvector.length(v);
	        var theta = Math.atan2(v[1], v[0]);

	        // Convert angle range from [-pi, pi] to [0, 2pi]
	        if (theta < 0) {
	            theta += 2 * Math.PI;
	        }

	        return [radius, theta];
	    },

	    // Converts a cartesian coordinate into a degree polar coordinate
	    polarDegFromCart: function(v) {
	        var polar = kvector.polarRadFromCart(v);
	        return [polar[0], polar[1] * 180 / Math.PI];
	    },

	    /* Convert a polar coordinate into a cartesian coordinate
	     *
	     * Examples:
	     * cartFromPolarRad(5, Math.PI)
	     * cartFromPolarRad([5, Math.PI])
	     */
	    cartFromPolarRad: function(radius, theta) {
	        if (_.isUndefined(theta)) {
	            theta = radius[1];
	            radius = radius[0];
	        }

	        return [radius * Math.cos(theta), radius * Math.sin(theta)];
	    },

	    /* Convert a polar coordinate into a cartesian coordinate
	     *
	     * Examples:
	     * cartFromPolarDeg(5, 30)
	     * cartFromPolarDeg([5, 30])
	     */
	    cartFromPolarDeg: function(radius, theta) {
	        if (_.isUndefined(theta)) {
	            theta = radius[1];
	            radius = radius[0];
	        }

	        return kvector.cartFromPolarRad(radius, theta * Math.PI / 180);
	    },

	    // Rotate vector
	    rotateRad: function(v, theta) {
	        var polar = kvector.polarRadFromCart(v);
	        var angle = polar[1] + theta;
	        return kvector.cartFromPolarRad(polar[0], angle);
	    },

	    rotateDeg: function(v, theta) {
	        var polar = kvector.polarDegFromCart(v);
	        var angle = polar[1] + theta;
	        return kvector.cartFromPolarDeg(polar[0], angle);
	    },

	    // Angle between two vectors
	    angleRad: function(v1, v2) {
	        return Math.acos(kvector.dot(v1, v2) /
	            (kvector.length(v1) * kvector.length(v2)));
	    },

	    angleDeg: function(v1, v2) {
	        return kvector.angleRad(v1, v2) * 180 / Math.PI;
	    },

	    // Vector projection of v1 onto v2
	    projection: function(v1, v2) {
	        var scalar = kvector.dot(v1, v2) / kvector.dot(v2, v2);
	        return kvector.scale(v2, scalar);
	    },

	    // Round each number to a certain number of decimal places
	    round: function(vec, precision) {
	        return _.map(vec, function(elem, i) {
	            return knumber.round(elem, precision[i] || precision);
	        });
	    },

	    // Round each number to the nearest increment
	    roundTo: function(vec, increment) {
	        return _.map(vec, function(elem, i) {
	            return knumber.roundTo(elem, increment[i] || increment);
	        });
	    },

	    floorTo: function(vec, increment) {
	        return _.map(vec, function(elem, i) {
	            return knumber.floorTo(elem, increment[i] || increment);
	        });
	    },

	    ceilTo: function(vec, increment) {
	        return _.map(vec, function(elem, i) {
	            return knumber.ceilTo(elem, increment[i] || increment);
	        });
	    }
	};

	return kvector;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	// Minify Raphael ourselves because IE8 has a problem with the 1.5.2 minified release
	// http://groups.google.com/group/raphaeljs/browse_thread/thread/c34c75ad8d431544
	__webpack_require__(17);
	var knumber = __webpack_require__(6);

	$.extend(KhanUtil, {

	    // Simplify formulas before display
	    cleanMath: function(expr) {
	        return typeof expr === "string" ?
	            expr.replace(/\+\s*-/g, "- ")
	                .replace(/-\s*-/g, "+ ")
	                .replace(/\^1/g, "") :
	            expr;
	    },

	    // A simple random number picker
	    // Returns a random int in [0, num)
	    rand: function(num) {
	        return Math.floor(num * KhanUtil.random());
	    },

	    /* Returns an array of the digits of a nonnegative integer in reverse
	     * order: digits(376) = [6, 7, 3] */
	    digits: function(n) {
	        if (n === 0) {
	            return [0];
	        }

	        var list = [];

	        while (n > 0) {
	            list.push(n % 10);
	            n = Math.floor(n / 10);
	        }

	        return list;
	    },

	    // Similar to above digits, but in original order (not reversed)
	    integerToDigits: function(n) {
	        return KhanUtil.digits(n).reverse();
	    },

	    // Convert a decimal number into an array of digits (reversed)
	    decimalDigits: function(n) {
	        var str = "" + Math.abs(n);
	        str = str.replace(".", "");

	        var list = [];
	        for (var i = str.length; i > 0; i--) {
	            list.push(str.charAt(i-1));
	        }

	        return list;
	    },

	    // Find number of digits after the decimal place
	    decimalPlaces: function(n) {
	        var str = "" + Math.abs(n);
	        str = str.split(".");

	        if (str.length === 1) {
	            return 0;
	        } else {
	            return str[1].length;
	        }
	    },

	    digitsToInteger: function(digits) {
	        var place = Math.floor(Math.pow(10, digits.length - 1));
	        var number = 0;

	        $.each(digits, function(index, digit) {
	            number += digit * place;
	            place /= 10;
	        });

	        return number;
	    },

	    padDigitsToNum: function(digits, num) {
	        digits = digits.slice(0);
	        while (digits.length < num) {
	            digits.push(0);
	        }
	        return digits;
	    },

	    placesLeftOfDecimal: [$._("one"), $._("ten"), $._("hundred"),
	        $._("thousand")],
	    placesRightOfDecimal: [$._("one"), $._("tenth"), $._("hundredth"),
	        $._("thousandth"),$._("ten thousandth")],

	    powerToPlace: function(power) {
	        if (power < 0) {
	            return KhanUtil.placesRightOfDecimal[-1 * power];
	        } else {
	            return KhanUtil.placesLeftOfDecimal[power];
	        }
	    },


	    //Adds 0.001 because of floating points uncertainty so it errs on the side of going further away from 0
	    roundTowardsZero: function(x) {
	        if (x < 0) {
	            return Math.ceil(x - 0.001);
	        }
	        return Math.floor(x + 0.001);
	    },

	    factorial: function(x) {
	        if (x <= 1) {
	            return x;
	        } else {
	            return x * KhanUtil.factorial(x - 1);
	        }
	    },

	    getGCD: function(a, b) {
	        if (arguments.length > 2) {
	            var rest = [].slice.call(arguments, 1);
	            return KhanUtil.getGCD(a, KhanUtil.getGCD.apply(KhanUtil, rest));
	        } else {
	            var mod;

	            a = Math.abs(a);
	            b = Math.abs(b);

	            while (b) {
	                mod = a % b;
	                a = b;
	                b = mod;
	            }

	            return a;
	        }
	    },

	    getLCM: function(a, b) {
	        if (arguments.length > 2) {
	            var rest = [].slice.call(arguments, 1);
	            return KhanUtil.getLCM(a, KhanUtil.getLCM.apply(KhanUtil, rest));
	        } else {
	            return Math.abs(a * b) / KhanUtil.getGCD(a, b);
	        }
	    },

	    primes: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,
	        47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97],

	    denominators: [2, 3, 4, 5, 6, 8, 10, 12, 100],
	    smallDenominators: [2, 3, 4, 5, 6, 8, 10, 12],

	    getPrime: function() {
	        return KhanUtil.primes[KhanUtil.rand(KhanUtil.primes.length)];
	    },

	    isPrime: function(n) {
	        if (n <= 1) {
	            return false;
	        } else if (n < 101) {
	            return !!$.grep(KhanUtil.primes, function(p, i) {
	                return Math.abs(p - n) <= 0.5;
	            }).length;
	        } else {
	            if (n <= 1 || n > 2 && n % 2 === 0) {
	                return false;
	            } else {
	                for (var i = 3, sqrt = Math.sqrt(n); i <= sqrt; i += 2) {
	                    if (n % i === 0) {
	                        return false;
	                    }
	                }
	            }

	            return true;
	        }

	    },

	    isOdd: function(n) {
	        return n % 2 === 1;
	    },

	    isEven: function(n) {
	        return n % 2 === 0;
	    },

	    getOddComposite: function(min, max) {
	        if (min === undefined) {
	            min = 0;
	        }

	        if (max === undefined) {
	            max = 100;
	        }

	        var oddComposites = [9, 15, 21, 25, 27, 33, 35, 39, 45, 49, 51, 55];
	        oddComposites = oddComposites.concat([57, 63, 65, 69, 75, 77, 81, 85, 87, 91, 93, 95, 99]);

	        var result = -1;
	        while (result < min || result > max) {
	            result = oddComposites[KhanUtil.rand(oddComposites.length)];
	        }
	        return result;
	    },

	    getEvenComposite: function(min, max) {
	        if (min === undefined) {
	            min = 0;
	        }

	        if (max === undefined) {
	            max = 100;
	        }

	        var evenComposites = [4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26];
	        evenComposites = evenComposites.concat([28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48]);
	        evenComposites = evenComposites.concat([50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72]);
	        evenComposites = evenComposites.concat([74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98]);

	        var result = -1;
	        while (result < min || result > max) {
	            result = evenComposites[KhanUtil.rand(evenComposites.length)];
	        }
	        return result;
	    },

	    getComposite: function() {
	        if (KhanUtil.randRange(0, 1)) {
	            return KhanUtil.getEvenComposite();
	        } else {
	            return KhanUtil.getOddComposite();
	        }
	    },

	    getPrimeFactorization: function(number) {
	        if (number === 1) {
	            return [];
	        } else if (KhanUtil.isPrime(number)) {
	            return [number];
	        }

	        var maxf = Math.sqrt(number);
	        for (var f = 2; f <= maxf; f++) {
	            if (number % f === 0) {
	                return $.merge(KhanUtil.getPrimeFactorization(f), KhanUtil.getPrimeFactorization(number / f));
	            }
	        }
	    },

	    getFactors: function(number) {
	        var factors = [],
	            ins = function(n) {
	                if (_(factors).indexOf(n) === -1) {
	                    factors.push(n);
	                }
	            };

	        var maxf2 = number;
	        for (var f = 1; f * f <= maxf2; f++) {
	            if (number % f === 0) {
	                ins(f);
	                ins(number / f);
	            }
	        }
	        return KhanUtil.sortNumbers(factors);
	    },

	    // Get a random factor of a composite number which is not 1 or that number
	    getNontrivialFactor: function(number) {
	        var factors = KhanUtil.getFactors(number);
	        return factors[KhanUtil.randRange(1, factors.length - 2)];
	    },

	    getMultiples: function(number, upperLimit) {
	        var multiples = [];
	        for (var i = 1; i * number <= upperLimit; i++) {
	            multiples.push(i * number);
	        }
	        return multiples;
	    },

	    // splitRadical(24) gives [2, 6] to mean 2 sqrt(6)
	    splitRadical: function(n) {
	        if (n === 0) {
	            return [0, 1];
	        }

	        var coefficient = 1;
	        var radical = n;

	        for (var i = 2; i * i <= n; i++) {
	            while (radical % (i * i) === 0) {
	                radical /= i * i;
	                coefficient *= i;
	            }
	        }

	        return [coefficient, radical];
	    },

	    // splitCube(24) gives [2, 3] to mean 2 cube_root(3)
	    splitCube: function(n) {
	        if (n === 0) {
	            return [0, 1];
	        }

	        var coefficient = 1;
	        var radical = n;

	        for (var i = 2; i * i * i <= n; i++) {
	            while (radical % (i * i * i) === 0) {
	                radical /= i * i * i;
	                coefficient *= i;
	            }
	        }

	        return [coefficient, radical];
	    },

	    // randRange(min, max) - Get a random integer between min and max, inclusive
	    // randRange(min, max, count) - Get count random integers
	    // randRange(min, max, rows, cols) - Get a rows x cols matrix of random integers
	    // randRange(min, max, x, y, z) - You get the point...
	    randRange: function(min, max) {
	        var dimensions = [].slice.call(arguments, 2);

	        if (dimensions.length === 0) {
	            return Math.floor(KhanUtil.rand(max - min + 1)) + min;
	        } else {
	            var args = [min, max].concat(dimensions.slice(1));
	            return $.map(new Array(dimensions[0]), function() {
	                return [KhanUtil.randRange.apply(null, args)];
	            });
	        }
	    },

	    // Get an array of unique random numbers between min and max
	    randRangeUnique: function(min, max, count) {
	        if (count == null) {
	            return KhanUtil.randRange(min, max);
	        } else {
	            var toReturn = [];
	            for (var i = min; i <= max; i++) {
	                toReturn.push(i);
	            }

	            return KhanUtil.shuffle(toReturn, count);
	        }
	    },

	    // Get an array of unique random numbers between min and max,
	    // that ensures that none of the integers in the array are 0.
	    randRangeUniqueNonZero: function(min, max, count) {
	        if (count == null) {
	            return KhanUtil.randRangeNonZero(min, max);
	        } else {
	            var toReturn = [];
	            for (var i = min; i <= max; i++) {
	                if (i === 0) {
	                    continue;
	                }
	                toReturn.push(i);
	            }

	            return KhanUtil.shuffle(toReturn, count);
	        }
	    },

	    // Get a random integer between min and max with a perc chance of hitting
	    // target (which is assumed to be in the range, but it doesn't have to be).
	    randRangeWeighted: function(min, max, target, perc) {
	        if (KhanUtil.random() < perc || (target === min && target === max)) {
	            return target;
	        } else {
	            return KhanUtil.randRangeExclude(min, max, [target]);
	        }
	    },

	    // Get a random integer between min and max that is never any of the values
	    // in the excludes array.
	    randRangeExclude: function(min, max, excludes) {
	        var result;

	        do {
	            result = KhanUtil.randRange(min, max);
	        } while (_(excludes).indexOf(result) !== -1);

	        return result;
	    },

	    // Get a random integer between min and max with a perc chance of hitting
	    // target (which is assumed to be in the range, but it doesn't have to be).
	    // It never returns any of the values in the excludes array.
	    randRangeWeightedExclude: function(min, max, target, perc, excludes) {
	        var result;

	        do {
	            result = KhanUtil.randRangeWeighted(min, max, target, perc);
	        } while (_(excludes).indexOf(result) !== -1);

	        return result;
	    },

	    // From limits_1
	    randRangeNonZero: function(min, max) {
	        return KhanUtil.randRangeExclude(min, max, [0]);
	    },

	    // Returns a random member of the given array
	    // If a count is passed, it gives an array of random members of the given array
	    randFromArray: function(arr, count) {
	        if (count == null) {
	            return arr[KhanUtil.rand(arr.length)];
	        } else {
	            return $.map(new Array(count), function() {
	                return KhanUtil.randFromArray(arr);
	            });
	        }
	    },

	    // Returns a random member of the given array that is never any of the values
	    // in the excludes array.
	    randFromArrayExclude: function(arr, excludes) {
	        var cleanArr = [];
	        for (var i = 0; i < arr.length; i++) {
	            if (_(excludes).indexOf(arr[i]) === -1) {
	                cleanArr.push(arr[i]);
	            }
	        }
	        return KhanUtil.randFromArray(cleanArr);
	    },

	    // Round a number to the nearest increment
	    // E.g., if increment = 30 and num = 40, return 30. if increment = 30 and num = 45, return 60.
	    roundToNearest: function(increment, num) {
	        return Math.round(num / increment) * increment;
	    },

	    // Round a number to a certain number of decimal places
	    roundTo: function(precision, num) {
	        var factor = Math.pow(10, precision).toFixed(5);
	        return Math.round((num * factor).toFixed(5)) / factor;
	    },

	    /**
	     * Return a string of num rounded to a fixed precision decimal places,
	     * with an approx symbol if num had to be rounded, and trailing 0s
	     */
	    toFixedApprox: function(num, precision) {
	        // TODO(jack): Make this locale-dependent like
	        // KhanUtil.localeToFixed
	        var fixedStr = num.toFixed(precision);
	        if (knumber.equal(+fixedStr, num)) {
	            return fixedStr;
	        } else {
	            return "\\approx " + fixedStr;
	        }
	    },

	    /**
	     * Return a string of num rounded to precision decimal places, with an
	     * approx symbol if num had to be rounded, but no trailing 0s if it was
	     * not rounded.
	     */
	    roundToApprox: function(num, precision) {
	        var fixed = KhanUtil.roundTo(precision, num);
	        if (knumber.equal(fixed, num)) {
	            return String(fixed);
	        } else {
	            return KhanUtil.toFixedApprox(num, precision);
	        }
	    },

	    floorTo: function(precision, num) {
	        var factor = Math.pow(10, precision).toFixed(5);
	        return Math.floor((num * factor).toFixed(5)) / factor;
	    },

	    ceilTo: function(precision, num) {
	        var factor = Math.pow(10, precision).toFixed(5);
	        return Math.ceil((num * factor).toFixed(5)) / factor;
	    },

	    // toFraction(4/8) => [1, 2]
	    // toFraction(0.666) => [333, 500]
	    // toFraction(0.666, 0.001) => [2, 3]
	    //
	    // tolerance can't be bigger than 1, sorry
	    toFraction: function(decimal, tolerance) {
	        if (tolerance == null) {
	            tolerance = Math.pow(2, -46);
	        }

	        if (decimal < 0 || decimal > 1) {
	            var fract = decimal % 1;
	            fract += (fract < 0 ? 1 : 0);

	            var nd = KhanUtil.toFraction(fract, tolerance);
	            nd[0] += Math.round(decimal - fract) * nd[1];
	            return nd;
	        } else if (Math.abs(Math.round(Number(decimal)) - decimal) <= tolerance) {
	            return [Math.round(decimal), 1];
	        } else {
	            var loN = 0, loD = 1, hiN = 1, hiD = 1, midN = 1, midD = 2;

	            while (1) {
	                if (Math.abs(Number(midN / midD) - decimal) <= tolerance) {
	                    return [midN, midD];
	                } else if (midN / midD < decimal) {
	                    loN = midN;
	                    loD = midD;
	                } else {
	                    hiN = midN;
	                    hiD = midD;
	                }

	                midN = loN + hiN;
	                midD = loD + hiD;
	            }
	        }
	    },

	    // Returns the format (string) of a given numeric string
	    // Note: purposively more inclusive than answer-types' predicate.forms
	    // That is, it is not necessarily true that interpreted input are numeric
	    getNumericFormat: function(text) {
	        text = $.trim(text);
	        text = text.replace(/\u2212/, "-").replace(/([+-])\s+/g, "$1");
	        if (text.match(/^[+-]?\d+$/)) {
	            return "integer";
	        } else if (text.match(/^[+-]?\d+\s+\d+\s*\/\s*\d+$/)) {
	            return "mixed";
	        }
	        var fraction = text.match(/^[+-]?(\d+)\s*\/\s*(\d+)$/);
	        if (fraction) {
	            return parseFloat(fraction[1]) > parseFloat(fraction[2]) ?
	                    "improper" : "proper";
	        } else if (text.replace(/[,. ]/g, "").match(/^\d+$/)) {
	            return "decimal";
	        } else if (text.match(/(pi?|\u03c0|t(?:au)?|\u03c4|pau)/)) {
	            return "pi";
	        } else {
	            return null;
	        }
	    },


	    // Returns a string of the number in a specified format
	    toNumericString: function(number, format) {
	        if (number == null) {
	            return "";
	        } else if (number === 0) {
	            return "0"; // otherwise it might end up as 0% or 0pi
	        }

	        if (format === "percent") {
	            return number * 100 + "%";
	        }

	        if (format === "pi") {
	            var fraction = knumber.toFraction(number / Math.PI);
	            var numerator = Math.abs(fraction[0]), denominator = fraction[1];
	            if (knumber.isInteger(numerator)) {
	                var sign = number < 0 ? "-" : "";
	                var pi = "\u03C0";
	                return sign + (numerator === 1 ? "" : numerator) + pi +
	                    (denominator === 1 ? "" : "/" + denominator);
	            }
	        }

	        if (_(["proper", "improper", "mixed", "fraction"]).contains(format)) {
	            var fraction = knumber.toFraction(number);
	            var numerator = Math.abs(fraction[0]), denominator = fraction[1];
	            var sign = number < 0 ? "-" : "";
	            if (denominator === 1) {
	                return sign + numerator; // for integers, irrational, d > 1000
	            } else if (format === "mixed") {
	                var modulus = numerator % denominator;
	                var integer = (numerator - modulus) / denominator;
	                return sign + (integer ? integer + " " : "") +
	                        modulus + "/" + denominator;
	            } // otherwise proper, improper, or fraction
	            return sign + numerator + "/" + denominator;
	        }

	        // otherwise (decimal, float, long long)
	        return String(number);
	    },

	    // Shuffle an array using a Fischer-Yates shuffle
	    // If count is passed, returns an random sublist of that size
	    shuffle: function(array, count) {
	        array = [].slice.call(array, 0);
	        var beginning = typeof count === "undefined" || count > array.length ? 0 : array.length - count;

	        for (var top = array.length; top > beginning; top--) {
	            var newEnd = Math.floor(KhanUtil.random() * top),
	                tmp = array[newEnd];

	            array[newEnd] = array[top - 1];
	            array[top - 1] = tmp;
	        }

	        return array.slice(beginning);
	    },

	    sortNumbers: function(array) {
	        return array.slice(0).sort(function(a, b) {
	            return a - b;
	        });
	    },

	    // From limits_1
	    truncate_to_max: function(num, digits) {
	        return parseFloat(num.toFixed(digits));
	    },

	    // Checks if a number or string representation thereof is an integer
	    isInt: function(num) {
	        return parseFloat(num) === parseInt(num, 10) && !isNaN(num);
	    },


	    /**
	     * Add LaTeX color markup to a given value.
	     */
	    colorMarkup: function(val, color) {
	        return "\\color{" + color + "}{" + val + "}";
	    },

	    /**
	     * Like _.contains except using _.isEqual to verify if item is present.
	     * (Works for lists of non-primitive values.)
	     */
	    contains: function(list, item) {
	        return _.any(list, function(elem) {
	            if (_.isEqual(item, elem)) {
	                return true;
	            }
	            return false;
	        });
	    },

	    BLUE: "#6495ED",
	    ORANGE: "#FFA500",
	    PINK: "#FF00AF",
	    GREEN: "#28AE7B",
	    PURPLE: "#9D38BD",
	    RED: "#DF0030",
	    GRAY: "gray",
	    BLACK: "black",
	    LIGHT_BLUE: "#9AB8ED",
	    LIGHT_ORANGE: "#EDD19B",
	    LIGHT_PINK: "#ED9BD3",
	    LIGHT_GREEN: "#9BEDCE",
	    LIGHT_PURPLE: "#DA9BED",
	    LIGHT_RED: "#ED9AAC",
	    LIGHT_GRAY: "#ED9B9B",
	    LIGHT_BLACK: "#ED9B9B",
	    // Don't actually use _BACKGROUND! Make things transparent instead. The
	    // background color used in exercises is subject to change at the whim
	    // of fickle designers.
	    _BACKGROUND: "#FDFDFD"  // TODO(eater): Get rid of this altogether.
	});

	// For consistent coloring throughout Perseus
	$.extend(KhanUtil, {
	    INTERACTING: KhanUtil.ORANGE,
	    INTERACTIVE: KhanUtil.ORANGE,
	    DYNAMIC: KhanUtil.BLUE
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	/*
	===============================================================================
	Crc32 is a JavaScript function for computing the CRC32 of a string
	...............................................................................

	Version: 1.2 - 2006/11 - http://noteslog.com/category/javascript/

	-------------------------------------------------------------------------------
	Copyright (c) 2006 Andrea Ercolino
	http://www.opensource.org/licenses/mit-license.php
	===============================================================================
	*/

	// CRC32 Lookup Table
	var table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 " +
	            "9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD " +
	            "E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D " +
	            "6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC " +
	            "14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 " +
	            "A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C " +
	            "DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC " +
	            "51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F " +
	            "2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB " +
	            "B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F " +
	            "9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB " +
	            "086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E " +
	            "6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA " +
	            "FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE " +
	            "A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A " +
	            "346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 " +
	            "5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 " +
	            "CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 " +
	            "B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 " +
	            "9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 " +
	            "E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 " +
	            "6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 " +
	            "10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 " +
	            "A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B " +
	            "D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF " +
	            "4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 " +
	            "220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 " +
	            "B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A " +
	            "9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE " +
	            "0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 " +
	            "68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 " +
	            "FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 " +
	            "A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D " +
	            "3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 " +
	            "47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 " +
	            "CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 " +
	            "B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";

	/* Number */
	var crc32 = function(str, crc) {
	    if (crc == null) {
	        crc = 0;
	    }
	    var n = 0; //a number between 0 and 255
	    var x = 0; //a hex number

	    crc = crc ^ (-1);
	    for (var i = 0, iTop = str.length; i < iTop; i++) {
	        n = (crc ^ str.charCodeAt(i)) & 0xFF;
	        x = "0x" + table.substr(n * 9, 8);
	        crc = (crc >>> 8) ^ x;
	    }
	    return Math.abs(crc ^ (-1));
	};

	return crc32;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./algebra-intuition.js": 18,
		"./angles.js": 19,
		"./answer-types.js": 2,
		"./chemistry.js": 20,
		"./cipher.js": 21,
		"./congruency.js": 22,
		"./constructions.js": 23,
		"./convert-values.js": 24,
		"./crc32.js": 11,
		"./derivative-intuition.js": 25,
		"./exponents.js": 26,
		"./expressions.js": 27,
		"./functional.js": 28,
		"./geom.js": 29,
		"./graphie-3d.js": 30,
		"./graphie-drawing.js": 31,
		"./graphie-geometry.js": 32,
		"./graphie-helpers-arithmetic.js": 33,
		"./graphie-helpers.js": 34,
		"./graphie-polygon.js": 35,
		"./graphie.js": 3,
		"./interactive.js": 4,
		"./jquery.adhesion.js": 36,
		"./khanscript.js": 37,
		"./kline.js": 5,
		"./kmatrix.js": 38,
		"./knumber.js": 6,
		"./kpoint.js": 7,
		"./kray.js": 8,
		"./kvector.js": 9,
		"./math-format.js": 39,
		"./math.js": 10,
		"./matrix-input.js": 40,
		"./mean-and-median.js": 41,
		"./parabola-intuition.js": 42,
		"./polynomials.js": 43,
		"./probability.js": 44,
		"./qhints.js": 45,
		"./rational-expressions.js": 46,
		"./scratchpad.js": 47,
		"./slice-clone.js": 48,
		"./spin.js": 49,
		"./stat.js": 50,
		"./subhints.js": 51,
		"./tex.js": 13,
		"./time.js": 52,
		"./tmpl.js": 14,
		"./triangle-congruence.js": 53,
		"./unit-circle.js": 54,
		"./visualizing-derivatives.js": 55,
		"./word-problems.js": 56
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	function findChildOrAdd(elem, className) {
	    var $child = $(elem).find("." + className);
	    if ($child.length === 0) {
	        return $("<span>").addClass(className).appendTo($(elem));
	    } else {
	        return $child;
	    }
	}

	function doCallback(elem, callback) {
	    var tries = 0;
	    (function check() {
	        var height = elem.scrollHeight;
	        // Heuristic to guess if the font has kicked in
	        // so we have box metrics (magic number ick,
	        // but this seems to work mostly-consistently)
	        if (height > 18 || tries >= 10) {
	            callback();
	        } else {
	            tries++;
	            setTimeout(check, 100);
	        }
	    })();
	}


	$.extend(KhanUtil, {
	    // Process a node and add math inside of it. This attempts to use KaTeX to
	    // format the math, and if that fails it falls back to MathJax.
	    //
	    // elem: The element which the math should be added to.
	    //
	    // text: The text that should be formatted inside of the node. If the node
	    //       has already had math formatted inside of it before, this doesn't
	    //       have to be provided. If this is not provided, and the node hasn't
	    //       been formatted before, the text content of the node is used.
	    //
	    // force: (optional) if the node has been processed before, then it will
	    //        not be formatted again, unless this argument is true
	    //
	    // callback: (optional) a callback to be run after the math has been
	    //           processed (note: this might be called synchronously or
	    //           asynchronously, depending on whether KaTeX or MathJax is used)
	    processMath: function(elem, text, force, callback) {
	        var $elem = $(elem);

	        // Only process if it hasn't been done before, or it is forced
	        if ($elem.attr("data-math-formula") == null || force) {
	            var $katexHolder = findChildOrAdd($elem, "katex-holder");
	            var $mathjaxHolder = findChildOrAdd($elem, "mathjax-holder");

	            // Search for MathJax-y script tags inside of the node. These are
	            // used by MathJax to denote the formula to be typeset. Before, we
	            // would update the formula by updating the contents of the script
	            // tag, which shouldn't happen any more, but we manage them just in
	            // case.
	            var script = $mathjaxHolder.find("script[type='math/tex']")[0];

	            // If text wasn't provided, we look in two places
	            if (text == null) {
	                if ($elem.attr("data-math-formula")) {
	                    // The old typeset formula
	                    text = $elem.attr("data-math-formula");
	                } else if (script) {
	                    // The contents of the <script> tag
	                    text = script.text || script.textContent;
	                }
	            }

	            text = text != null ? text + "" : "";

	            // Attempt to clean up some of the math
	            if (KhanUtil.cleanMath) {
	                text = KhanUtil.cleanMath(text);
	            }

	            // Store the formula that we're using
	            $elem.attr("data-math-formula", text);

	            if (Exercises.useKatex) {
	                // Try to process the nodes with KaTeX first
	                try {
	                    katex.process(text, $katexHolder[0]);
	                    // If that worked, and we previously formatted with
	                    // mathjax, do some mathjax cleanup
	                    if ($elem.attr("data-math-type") === "mathjax") {
	                        // Remove the old mathjax stuff
	                        var jax = MathJax.Hub.getJaxFor(script);
	                        if (jax) {
	                            var e = jax.SourceElement();
	                            if (e.previousSibling &&
	                                    e.previousSibling.className) {
	                                jax.Remove();
	                            }
	                        }
	                    }
	                    $elem.attr("data-math-type", "katex");
	                    // Call the callback
	                    if (callback) {
	                        doCallback(elem, callback);
	                    }
	                    return;
	                } catch (err) {
	                    // IE doesn't do instanceof correctly, so we resort to
	                    // manual checking
	                    /* jshint -W103 */
	                    if (err.__proto__ !== katex.ParseError.prototype) {
	                        throw err;
	                    }
	                    /* jshint +W103 */
	                }
	            }

	            // Otherwise, fallback to MathJax

	            // (Note: we don't need to do any katex cleanup here, because
	            // KaTeX is smart and cleans itself up)
	            $elem.attr("data-math-type", "mathjax");
	            // Update the script tag, or add one if necessary
	            if (!script) {
	                $mathjaxHolder.append("<script type='math/tex'>" +
	                        text.replace(/<\//g, "< /") + "</script>");
	            } else {
	                if ("text" in script) {
	                    // IE8, etc
	                    script.text = text;
	                } else {
	                    script.textContent = text;
	                }
	            }
	            if (typeof MathJax !== "undefined") {
	                // Put the process, a debug log, and the callback into the
	                // MathJax queue
	                MathJax.Hub.Queue(["Reprocess", MathJax.Hub,
	                    $mathjaxHolder[0]]);
	                MathJax.Hub.Queue(function() {
	                    KhanUtil.debugLog("MathJax done typesetting (" + text +
	                            ")");
	                });
	                if (callback) {
	                    MathJax.Hub.Queue(function() {
	                        var cb = MathJax.Callback(function() {});
	                        doCallback(elem, function() {
	                            callback();
	                            cb();
	                        });
	                        return cb;
	                    });
	                }
	            }
	        }
	    },

	    processAllMath: function(elem, force) {
	        var $elem = $(elem);
	        $elem.filter("code").add($elem.find("code")).each(function() {
	            var $this = $(this);
	            var text = $this.attr("data-math-formula");
	            if (text == null) {
	                text = $this.text();
	                $this.empty();
	            }
	            KhanUtil.processMath(this, text, force);
	        });
	    },

	    // Function to restore a node to a non-math-processed state
	    cleanupMath: function(elem) {
	        var $elem = $(elem);

	        // Only mess with it if it's been processed before
	        if ($elem.attr("data-math-formula")) {
	            // Remove MathJax remnants
	            if (typeof MathJax !== "undefined") {
	                var jax = MathJax.Hub.getJaxFor($elem.find("script")[0]);
	                if (jax) {
	                    var e = jax.SourceElement();
	                    if (e.previousSibling && e.previousSibling.className) {
	                        jax.Remove();
	                    }
	                }
	            }

	            $elem.text($elem.attr("data-math-formula"));
	            $elem.attr("data-math-formula", null);
	            $elem.attr("data-math-type", null);
	        }

	        return elem;
	    },

	    // Function to retrieve the formula of a typeset math node
	    retrieveMathFormula: function(elem) {
	        return $(elem).attr("data-math-formula");
	    }
	});

	$.fn.tex = function() {
	    KhanUtil.processAllMath(this, false);

	    return this;
	};

	$.fn.texCleanup = function() {
	    this.filter("code").add(this.find("code")).each(function() {
	        KhanUtil.cleanupMath(this);
	    });

	    return this;
	};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var crc32 = __webpack_require__(11);

	var localMode;

	// Keep the template variables private, to prevent external access
	var VARS = {};

	$.tmpl = {
	    DATA_ENSURE_LOOPS: 0,

	    // Processors that act based on element attributes
	    attr: {
	        "data-ensure": function(elem, ensure) {
	            // Returns a function in order to run after other templating and var assignment
	            return function(elem) {
	                // Return a boolean corresponding to the ensure's value
	                // False means all templating will be run again, so new values will be chosen
	                var result = !!(ensure && $.tmpl.getVAR(ensure));
	                if (!result) {
	                    if ($.tmpl.DATA_ENSURE_LOOPS++ > 10000 && localMode) {
	                        // Shucks, probably not possible. Just give up in order
	                        // to not hang the dev's browser.
	                        alert("unsatisfiable data-ensure?");
	                        return true;
	                    }
	                }
	                return result;
	            };
	        },

	        "data-if": function(elem, value) {
	            var $elem = $(elem);

	            value = value && $.tmpl.getVAR(value);

	            // Save the result of this data-if in the next sibling for data-else-if and data-else
	            // Only save the value if no previous value has been set
	            var $nextElem = $elem.next();
	            if ($nextElem.data("lastCond") === undefined) {
	                $nextElem.data("lastCond", value);
	            }

	            if (!value) {
	                // Delete the element if the data-if evaluated to false
	                return [];
	            }
	        },

	        "data-else-if": function(elem, value) {
	            var $elem = $(elem);

	            var lastCond = $elem.data("lastCond");

	            // Show this element iff the preceding element was hidden AND this data-if returns truthily
	            value = !lastCond && value && $.tmpl.getVAR(value);

	            // Succeeding elements care about the visibility of both me and my preceding siblings
	            // Only save the value if no previous value has been set
	            var $nextElem = $elem.next();
	            if ($nextElem.data("lastCond") === undefined) {
	                $nextElem.data("lastCond", lastCond || value);
	            }

	            if (!value) {
	                // Delete the element if appropriate
	                return [];
	            }
	        },

	        "data-else": function(elem) {
	            var $elem = $(elem);

	            if ($elem.data("lastCond")) {
	                // Delete the element if the data-if of the preceding element was true
	                return [];
	            }
	        },

	        "data-each": function(elem, value) {
	            var match;

	            // Remove the data-each attribute so it doesn't end up in the generated elements
	            $(elem).removeAttr("data-each");

	            // HINT_COUNT times
	            // HINT_COUNT times as INDEX
	            if ((match = /^(.+) times(?: as (\w+))?$/.exec(value))) {
	                var times = $.tmpl.getVAR(match[1]);

	                return {
	                    items: $.map(new Array(times), function(e, i) { return i; }),
	                    value: match[2],
	                    oldValue: VARS[match[2]]
	                };

	            // Extract the 1, 2, or 3 parts of the data-each attribute, which could be
	            //   - items
	            //   - items as value
	            //   - items as pos, value
	            } else if ((match = /^(.*?)(?: as (?:(\w+), )?(\w+))?$/.exec(value))) {
	                // See "if (ret.items)" in traverse() for the other half of the data-each code
	                return {
	                    // The collection which we'll iterate through
	                    items: $.tmpl.getVAR(match[1]),

	                    // "value" and "pos" as strings
	                    value: match[3],
	                    pos: match[2],

	                    // Save the values of the iterator variables so we don't permanently overwrite them
	                    oldValue: VARS[match[3]],
	                    oldPos: VARS[match[2]]
	                };
	            }
	        },

	        "data-unwrap": function(elem) {
	            return $(elem).contents();
	        },

	        "data-video-hint": function(elem) {
	            var youtubeIds = $(elem).data("youtube-id");
	            if (!youtubeIds) {
	                return;
	            }

	            youtubeIds = youtubeIds.split(/,\s*/);

	            var author = $(elem).data("video-hint-author") || "Sal";
	            var msg = $._("Watch %(author)s work through a very similar " +
	                "problem:", {author: author});
	            var preface = $("<p>").text(msg);

	            var wrapper = $("<div>", { "class": "video-hint" });
	            wrapper.append(preface);

	            _.each(youtubeIds, function(youtubeId) {
	                var href = "http://www.khanacademy.org/embed_video?v=" +
	                            youtubeId;
	                var iframe = $("<iframe>").attr({
	                    "frameborder": "0",
	                    "scrolling": "no",
	                    "width": "100%",
	                    "height": "360px",
	                    "src": href
	                });

	                wrapper.append(iframe);
	            });

	            return wrapper;
	        }

	    },

	    // Processors that act based on tag names
	    type: {
	        "var": function(elem, value) {
	            // When called by process(), value is undefined

	            // If the <var> has any child elements, run later with the innerHTML
	            // Use $ instead of getElementsByTagName to exclude comment nodes in IE
	            if (!value && $(elem).children().length > 0) {
	                return function(elem) {
	                    return $.tmpl.type["var"](elem, elem.innerHTML);
	                };
	            }

	            // Evaluate the contents of the <var> as a JS string
	            value = value || $.tmpl.getVAR(elem);

	            // If an ID was specified then we're going to save the value
	            var name = elem.id;
	            if (name) {

	                // Utility function for VARS[name] = value, warning if the name overshadows a KhanUtil property
	                var setVAR = function(name, value) {
	                    if (KhanUtil[name]) {
	                        Khan.error("Defining variable '" + name + "' overwrites utility property of same name.");
	                    }

	                    VARS[name] = value;
	                };

	                // Destructure the array if appropriate
	                if (name.indexOf(",") !== -1) {
	                    // Nested arrays are not supported
	                    var parts = name.split(/\s*,\s*/);

	                    $.each(parts, function(i, part) {
	                        // Ignore empty parts
	                        if (part.length > 0) {
	                            setVAR(part, value[i]);
	                        }
	                    });

	                // Just a normal assignment
	                } else {
	                    setVAR(name, value);
	                }

	            // No value was specified so we replace it with a text node of the value
	            } else {
	                if (value == null) {
	                    // Don't show anything
	                    return [];
	                } else {
	                    // Convert the value to a string and replace with those elements and text nodes
	                    // Add a space so that it can end with a "<" in Safari
	                    var div = $("<div>");
	                    var html = div.append(value + " ").html();
	                    return div.html(html.slice(0, -1)).contents();
	                }
	            }
	        }
	    },

	    // Eval a string in the context of Math, KhanUtil, VARS, and optionally another passed context
	    getVAR: function(elem, ctx) {
	        // We need to compute the value
	        var code = elem.nodeName ? $(elem).text() : elem;

	        // If no extra context was passed, use an empty object
	        if (ctx == null) {
	            ctx = {};
	        }

	        function doEval() {
	            /* jshint -W085 */
	            // Use the methods from JavaScript's built-in Math methods
	            with (Math) {
	                // And the methods provided by the library
	                with (KhanUtil) {
	                    // And the passed-in context
	                    with (ctx) {
	                        // And all the computed variables
	                        with (VARS) {
	                            return eval("(function() { return (" + code + "); })()");
	                        }
	                    }
	                }
	            }
	            /* jshint +W085 */
	        }

	        if (Khan.query.debug != null) {
	            // Skip try-catch in debug mode so that the script panel works
	            return doEval();
	        } else {
	            try {
	                return doEval();
	            } catch (e) {
	                var info;

	                if (elem.nodeName) {
	                    info = elem.nodeName.toLowerCase();

	                    if (elem.id != null && elem.id.length > 0) {
	                        info += "#" + elem.id;
	                    }
	                } else {
	                    info = JSON.stringify(code);
	                }

	                Khan.error("Error while evaluating " + info, e);
	            }
	        }
	    },

	    /**
	     * Get a hash of the problem variables for duplication detection purposes.
	     */
	    // TODO(david): Allow exercise developers to specify which variables are not
	    //     important for duplicate determination purposes.
	    // TODO(david): Just a possibility, but allow exercise developers to specify
	    //     their own variable hash function, so that, eg. for addition 1, 2 + 3
	    //     could hash to the same value as 3 + 2.
	    getVarsHash: function() {
	        // maybe TODO(david): Can base-64 encode the crc32 integer if we want to
	        //     save a few bytes, since localStorage stores strings only.

	        // Just convert top-level values to strings instead of recursively
	        // stringifying, due to issues with circular references.
	        return crc32(JSON.stringify($.map(VARS, function(value, key) {
	            return [key, String(value)];
	        })));
	    }
	};

	if (typeof KhanUtil !== "undefined") {
	    KhanUtil.tmpl = $.tmpl;
	}

	// Reinitialize VARS for each problem
	$.fn.tmplLoad = function(problem, info) {
	    VARS = {};
	    $.tmpl.DATA_ENSURE_LOOPS = 0;

	    localMode = info.localMode;

	    // Expose the variables if we're in local mode
	    if (localMode) {
	        $.tmpl.VARS = VARS;
	    }
	};

	$.fn.tmpl = function() {
	    // Call traverse() for each element in the $ object
	    for (var i = 0, l = this.length; i < l; i++) {
	        traverse(this[i]);
	    }

	    return this;

	    // Walk through the element and its descendants, process()-ing each one using the processors defined above
	    function traverse(elem) {
	        // Array of functions to run after doing the rest of the processing
	        var post = [],

	            // Live NodeList of child nodes to traverse if we don't remove/replace this element
	            child = elem.childNodes,

	            // Result of running the attribute and tag processors on the element
	            ret = process(elem, post);

	        // If false, rerun all templating (like data-ensure)
	        if (ret === false) {
	            return traverse(elem);

	        // If undefined, do nothing
	        } else if (ret === undefined) {

	        // If a (possibly-empty) array of nodes, replace this one with those
	        // The type of ret is checked to ensure it is not a function
	        } else if (typeof ret === "object" && typeof ret.length !== "undefined") {
	            if (elem.parentNode) {
	                // All nodes must be inserted before any are traversed
	                $.each(ret, function(i, rep) {
	                    if (rep.nodeType) {
	                        elem.parentNode.insertBefore(rep, elem);
	                    }
	                });

	                $.each(ret, function(i, rep) {
	                    traverse(rep);
	                });

	                elem.parentNode.removeChild(elem);
	            }

	            return null;

	        // If { items: ... }, this is a data-each loop
	        } else if (ret.items) {
	            // We need these references to insert the elements in the appropriate places
	            var origParent = elem.parentNode,
	                origNext = elem.nextSibling;

	            // Loop though the given array
	            $.each(ret.items, function(pos, value) {
	                // Set the value if appropriate
	                if (ret.value) {
	                    VARS[ret.value] = value;
	                }

	                // Set the position if appropriate
	                if (ret.pos) {
	                    VARS[ret.pos] = pos;
	                }

	                // Do a deep clone (including event handlers and data) of the element
	                var clone = $(elem).clone(true)
	                    .removeAttr("data-each").removeData("each")[0];

	                // Prepend all conditional statements with a declaration of ret.value
	                // and ret.post and an assignment of their current values so that
	                // the conditional will still make sense even when outside of the
	                // data-each context
	                var conditionals = ["data-if", "data-else-if", "data-else"];

	                var declarations = "";
	                declarations += (ret.pos) ? "var " + ret.pos + " = " + JSON.stringify(pos) + ";" : "";
	                declarations += (ret.value) ? "var " + ret.value + " = " + JSON.stringify(value) + ";" : "";

	                for (var i = 0; i < conditionals.length; i++) {
	                    var conditional = conditionals[i];
	                    $(clone).find("[" + conditional + "]").each(function() {
	                        var code = $(this).attr(conditional);
	                        code = "(function() { " + declarations + " return " + code + " })()";
	                        $(this).attr(conditional, code);
	                    });
	                }

	                // Do the same for graphie code
	                $(clone).find(".graphie").addBack().filter(".graphie").each(function() {
	                    var code = $(this).text();
	                    $(this).text(declarations + code);
	                });

	                // Insert in the proper place (depends on whether the loops is the last of its siblings)
	                if (origNext) {
	                    origParent.insertBefore(clone, origNext);
	                } else {
	                    origParent.appendChild(clone);
	                }

	                // Run all templating on the new element
	                traverse(clone);
	            });

	            // Restore the old value of the value variable, if it had one
	            if (ret.value) {
	                VARS[ret.value] = ret.oldValue;
	            }

	            // Restore the old value of the position variable, if it had one
	            if (ret.pos) {
	                VARS[ret.pos] = ret.oldPos;
	            }

	            // Remove the loop element and its handlers now that we've processed it
	            $(elem).remove();

	            // Say that the element was removed so that child traversal doesn't skip anything
	            return null;
	        }

	        // Loop through the element's children if it was not removed
	        for (var i = 0; i < child.length; i++) {
	            // Traverse the child; decrement the counter if the child was removed
	            if (child[i].nodeType === 1 && traverse(child[i]) === null) {
	                i--;
	            }
	        }

	        // Run through each post-processing function
	        for (var i = 0, l = post.length; i < l; i++) {
	            // If false, rerun all templating (for data-ensure and <code> math)
	            if (post[i](elem) === false) {
	                return traverse(elem);
	            }
	        }

	        return elem;
	    }

	    // Run through the attr and type processors, return as soon as one of them is decisive about a plan of action
	    function process(elem, post) {
	        var ret,
	            $elem = $(elem);

	        // Look through each of the attr processors, see if our element has the matching attribute
	        for (var attr in $.tmpl.attr) {
	            if ($.tmpl.attr.hasOwnProperty(attr)) {
	                var value;

	                if ((/^data-/).test(attr)) {
	                    value = $elem.data(attr.replace(/^data-/, ""));
	                } else {
	                    value = $elem.attr(attr);
	                }

	                if (value !== undefined) {
	                    ret = $.tmpl.attr[attr](elem, value);

	                    // If a function, run after all of the other templating
	                    if (typeof ret === "function") {
	                        post.push(ret);

	                    // Return anything else (boolean, array of nodes for replacement, object for data-each)
	                    } else if (ret !== undefined) {
	                        return ret;
	                    }
	                }
	            }
	        }

	        // Look up the processor based on the tag name
	        var type = elem.nodeName.toLowerCase();
	        if ($.tmpl.type[type] != null) {
	            ret = $.tmpl.type[type](elem);

	            // If a function, run after all of the other templating
	            if (typeof ret === "function") {
	                post.push(ret);
	            }
	        }

	        return ret;
	    }
	};

	$.extend($.expr[":"], {
	    inherited: function(el) {
	        return $(el).data("inherited");
	    }
	});

	$.fn.extend({
	    tmplApply: function(options) {
	        options = options || {};

	        // Get the attribute which we'll be checking, defaults to "id"
	        // but "class" is sometimes used
	        var attribute = options.attribute || "id",

	            // Figure out the way in which the application will occur
	            defaultApply = options.defaultApply || "replace",

	            // Store for elements to be used later
	            parent = {};

	        return this.each(function() {
	            var $this = $(this),
	                name = $this.attr(attribute),
	                hint = $this.data("apply") && !$this.data("apply").indexOf("hint");

	            // Only operate on the element if it has the attribute that we're using
	            if (name) {
	                // The inheritance only works if we've seen an element already
	                // that matches the particular name and we're not looking at hint
	                // templating
	                if (name in parent && !hint) {
	                    // Get the method through which we'll be doing the application
	                    // You can specify an application style directly on the sub-element
	                    parent[name] = $.tmplApplyMethods[$this.data("apply") || defaultApply]

	                        // Call it with the context of the parent and the sub-element itself
	                        .call(parent[name], this);

	                    if (parent[name] == null) {
	                        delete parent[name];
	                    }

	                // Store the parent element for later use if it was inherited from somewhere else
	                } else if ($this.closest(":inherited").length > 0) {
	                    parent[name] = this;
	                }
	            }
	        });
	    }
	});

	$.extend({
	    // These methods should be called with context being the parent
	    // and first argument being the child.
	    tmplApplyMethods: {
	        // Removes both the parent and the child
	        remove: function(elem) {
	            $(this).remove();
	            $(elem).remove();
	        },

	        // Replaces the parent with the child
	        replace: function(elem) {
	            $(this).replaceWith(elem);
	            return elem;
	        },

	        // Replaces the parent with the child's content. Useful when
	        // needed to replace an element without introducing additional
	        // wrappers.
	        splice: function(elem) {
	            $(this).replaceWith($(elem).contents());
	        },

	        // Appends the child element to the parent element
	        append: function(elem) {
	            $(this).append(elem);
	            return this;
	        },

	        // Appends the child element's contents to the parent element.
	        appendContents: function(elem) {
	            $(this).append($(elem).contents());
	            $(elem).remove();
	            return this;
	        },

	        // Prepends the child element to the parent.
	        prepend: function(elem) {
	            $(this).prepend(elem);
	            return this;
	        },

	        // Prepends the child element's contents to the parent element.
	        prependContents: function(elem) {
	            $(this).prepend($(elem).contents());
	            $(elem).remove();
	            return this;
	        },

	        // Insert child before the parent.
	        before: function(elem) {
	            $(this).before(elem);
	            return this;
	        },

	        // Insert child's contents before the parent.
	        beforeContents: function(elem) {
	            $(this).before($(elem).contents());
	            $(elem).remove();
	            return this;
	        },

	        // Insert child after the parent.
	        after: function(elem) {
	            $(this).after(elem);
	            return this;
	        },

	        // Insert child's contents after the parent.
	        afterContents: function(elem) {
	            $(this).after($(elem).contents());
	            $(elem).remove();
	            return this;
	        },

	        // Like appendContents but also merges the data-ensures
	        appendVars: function(elem) {
	            var parentEnsure = $(this).data("ensure") || "1";
	            var childEnsure = $(elem).data("ensure") || "1";
	            $(this).data("ensure",
	                "(" + parentEnsure + ") && (" + childEnsure + ")");

	            return $.tmplApplyMethods.appendContents.call(this, elem);
	        },

	        // Like prependContents but also merges the data-ensures
	        prependVars: function(elem) {
	            var parentEnsure = $(this).data("ensure") || "1";
	            var childEnsure = $(elem).data("ensure") || "1";
	            $(this).data("ensure",
	                "(" + childEnsure + ") && (" + parentEnsure + ")");

	            return $.tmplApplyMethods.prependContents.call(this, elem);
	        }
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* parser generated by jison 0.4.13 */
	/*
	  Returns a Parser object of the following structure:

	  Parser: {
	    yy: {}
	  }

	  Parser.prototype: {
	    yy: {},
	    trace: function(),
	    symbols_: {associative list: name ==> number},
	    terminals_: {associative list: number ==> name},
	    productions_: [...],
	    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
	    table: [...],
	    defaultActions: {...},
	    parseError: function(str, hash),
	    parse: function(input),

	    lexer: {
	        EOF: 1,
	        parseError: function(str, hash),
	        setInput: function(input),
	        input: function(),
	        unput: function(str),
	        more: function(),
	        less: function(n),
	        pastInput: function(),
	        upcomingInput: function(),
	        showPosition: function(),
	        test_match: function(regex_match_array, rule_index),
	        next: function(),
	        lex: function(),
	        begin: function(condition),
	        popState: function(),
	        _currentRules: function(),
	        topState: function(),
	        pushState: function(condition),

	        options: {
	            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
	            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
	            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
	        },

	        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
	        rules: [...],
	        conditions: {associative list: name ==> set},
	    }
	  }


	  token location info (@$, _$, etc.): {
	    first_line: n,
	    last_line: n,
	    first_column: n,
	    last_column: n,
	    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
	  }


	  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
	    text:        (matched text)
	    token:       (the produced terminal token, if any)
	    line:        (yylineno)
	  }
	  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
	    loc:         (yylloc)
	    expected:    (string describing the set of expected tokens)
	    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
	  }
	*/
	var Calculator = (function(){
	var parser = {trace: function trace() { },
	yy: {},
	symbols_: {"error":2,"expressions":3,"e":4,"EOF":5,"+":6,"-":7,"*":8,"/":9,"^":10,"!":11,"FN":12,"(":13,")":14,"E":15,"PI":16,"ANS":17,"NUM":18,"$accept":0,"$end":1},
	terminals_: {2:"error",5:"EOF",6:"+",7:"-",8:"*",9:"/",10:"^",11:"!",12:"FN",13:"(",14:")",15:"E",16:"PI",17:"ANS",18:"NUM"},
	productions_: [0,[3,2],[4,3],[4,3],[4,3],[4,3],[4,3],[4,2],[4,2],[4,4],[4,3],[4,1],[4,1],[4,1],[4,1]],
	performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
	/* this == yyval */

	var $0 = $$.length - 1;
	switch (yystate) {
	case 1:return $$[$0-1];
	break;
	case 2:this.$ = ["+", $$[$0-2], $$[$0]];
	break;
	case 3:this.$ = ["-", $$[$0-2], $$[$0]];
	break;
	case 4:this.$ = ["*", $$[$0-2], $$[$0]];
	break;
	case 5:this.$ = ["/", $$[$0-2], $$[$0]];
	break;
	case 6:this.$ = ["^", $$[$0-2], $$[$0]];
	break;
	case 7:this.$ = ["!", $$[$0-1]];
	break;
	case 8:this.$ = ["-", $$[$0]];
	break;
	case 9:this.$ = [$$[$0-3], $$[$0-1]];
	break;
	case 10:this.$ = $$[$0-1];
	break;
	case 11:this.$ = $$[$0];
	break;
	case 12:this.$ = $$[$0];
	break;
	case 13:this.$ = $$[$0];
	break;
	case 14:this.$ = Number(yytext);
	break;
	}
	},
	table: [{3:1,4:2,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{1:[3]},{5:[1,10],6:[1,11],7:[1,12],8:[1,13],9:[1,14],10:[1,15],11:[1,16]},{4:17,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{13:[1,18]},{4:19,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{5:[2,11],6:[2,11],7:[2,11],8:[2,11],9:[2,11],10:[2,11],11:[2,11],14:[2,11]},{5:[2,12],6:[2,12],7:[2,12],8:[2,12],9:[2,12],10:[2,12],11:[2,12],14:[2,12]},{5:[2,13],6:[2,13],7:[2,13],8:[2,13],9:[2,13],10:[2,13],11:[2,13],14:[2,13]},{5:[2,14],6:[2,14],7:[2,14],8:[2,14],9:[2,14],10:[2,14],11:[2,14],14:[2,14]},{1:[2,1]},{4:20,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{4:21,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{4:22,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{4:23,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{4:24,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{5:[2,7],6:[2,7],7:[2,7],8:[2,7],9:[2,7],10:[2,7],11:[2,7],14:[2,7]},{5:[2,8],6:[2,8],7:[2,8],8:[2,8],9:[2,8],10:[1,15],11:[1,16],14:[2,8]},{4:25,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{6:[1,11],7:[1,12],8:[1,13],9:[1,14],10:[1,15],11:[1,16],14:[1,26]},{5:[2,2],6:[2,2],7:[2,2],8:[1,13],9:[1,14],10:[1,15],11:[1,16],14:[2,2]},{5:[2,3],6:[2,3],7:[2,3],8:[1,13],9:[1,14],10:[1,15],11:[1,16],14:[2,3]},{5:[2,4],6:[2,4],7:[2,4],8:[2,4],9:[2,4],10:[1,15],11:[1,16],14:[2,4]},{5:[2,5],6:[2,5],7:[2,5],8:[2,5],9:[2,5],10:[1,15],11:[1,16],14:[2,5]},{5:[2,6],6:[2,6],7:[2,6],8:[2,6],9:[2,6],10:[1,15],11:[1,16],14:[2,6]},{6:[1,11],7:[1,12],8:[1,13],9:[1,14],10:[1,15],11:[1,16],14:[1,27]},{5:[2,10],6:[2,10],7:[2,10],8:[2,10],9:[2,10],10:[2,10],11:[2,10],14:[2,10]},{5:[2,9],6:[2,9],7:[2,9],8:[2,9],9:[2,9],10:[2,9],11:[2,9],14:[2,9]}],
	defaultActions: {10:[2,1]},
	parseError: function parseError(str, hash) {
	    if (hash.recoverable) {
	        this.trace(str);
	    } else {
	        throw new Error(str);
	    }
	},
	parse: function parse(input) {
	    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
	    var args = lstack.slice.call(arguments, 1);
	    this.lexer.setInput(input);
	    this.lexer.yy = this.yy;
	    this.yy.lexer = this.lexer;
	    this.yy.parser = this;
	    if (typeof this.lexer.yylloc == 'undefined') {
	        this.lexer.yylloc = {};
	    }
	    var yyloc = this.lexer.yylloc;
	    lstack.push(yyloc);
	    var ranges = this.lexer.options && this.lexer.options.ranges;
	    if (typeof this.yy.parseError === 'function') {
	        this.parseError = this.yy.parseError;
	    } else {
	        this.parseError = Object.getPrototypeOf(this).parseError;
	    }
	    function popStack(n) {
	        stack.length = stack.length - 2 * n;
	        vstack.length = vstack.length - n;
	        lstack.length = lstack.length - n;
	    }
	    function lex() {
	        var token;
	        token = self.lexer.lex() || EOF;
	        if (typeof token !== 'number') {
	            token = self.symbols_[token] || token;
	        }
	        return token;
	    }
	    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
	    while (true) {
	        state = stack[stack.length - 1];
	        if (this.defaultActions[state]) {
	            action = this.defaultActions[state];
	        } else {
	            if (symbol === null || typeof symbol == 'undefined') {
	                symbol = lex();
	            }
	            action = table[state] && table[state][symbol];
	        }
	                    if (typeof action === 'undefined' || !action.length || !action[0]) {
	                var errStr = '';
	                expected = [];
	                for (p in table[state]) {
	                    if (this.terminals_[p] && p > TERROR) {
	                        expected.push('\'' + this.terminals_[p] + '\'');
	                    }
	                }
	                if (this.lexer.showPosition) {
	                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + this.lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
	                } else {
	                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
	                }
	                this.parseError(errStr, {
	                    text: this.lexer.match,
	                    token: this.terminals_[symbol] || symbol,
	                    line: this.lexer.yylineno,
	                    loc: yyloc,
	                    expected: expected
	                });
	            }
	        if (action[0] instanceof Array && action.length > 1) {
	            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
	        }
	        switch (action[0]) {
	        case 1:
	            stack.push(symbol);
	            vstack.push(this.lexer.yytext);
	            lstack.push(this.lexer.yylloc);
	            stack.push(action[1]);
	            symbol = null;
	            if (!preErrorSymbol) {
	                yyleng = this.lexer.yyleng;
	                yytext = this.lexer.yytext;
	                yylineno = this.lexer.yylineno;
	                yyloc = this.lexer.yylloc;
	                if (recovering > 0) {
	                    recovering--;
	                }
	            } else {
	                symbol = preErrorSymbol;
	                preErrorSymbol = null;
	            }
	            break;
	        case 2:
	            len = this.productions_[action[1]][1];
	            yyval.$ = vstack[vstack.length - len];
	            yyval._$ = {
	                first_line: lstack[lstack.length - (len || 1)].first_line,
	                last_line: lstack[lstack.length - 1].last_line,
	                first_column: lstack[lstack.length - (len || 1)].first_column,
	                last_column: lstack[lstack.length - 1].last_column
	            };
	            if (ranges) {
	                yyval._$.range = [
	                    lstack[lstack.length - (len || 1)].range[0],
	                    lstack[lstack.length - 1].range[1]
	                ];
	            }
	            r = this.performAction.apply(yyval, [
	                yytext,
	                yyleng,
	                yylineno,
	                this.yy,
	                action[1],
	                vstack,
	                lstack
	            ].concat(args));
	            if (typeof r !== 'undefined') {
	                return r;
	            }
	            if (len) {
	                stack = stack.slice(0, -1 * len * 2);
	                vstack = vstack.slice(0, -1 * len);
	                lstack = lstack.slice(0, -1 * len);
	            }
	            stack.push(this.productions_[action[1]][0]);
	            vstack.push(yyval.$);
	            lstack.push(yyval._$);
	            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	            stack.push(newState);
	            break;
	        case 3:
	            return true;
	        }
	    }
	    return true;
	}};
	/* generated by jison-lex 0.2.1 */
	var lexer = (function(){
	var lexer = {

	EOF:1,

	parseError:function parseError(str, hash) {
	        if (this.yy.parser) {
	            this.yy.parser.parseError(str, hash);
	        } else {
	            throw new Error(str);
	        }
	    },

	// resets the lexer, sets new input
	setInput:function (input) {
	        this._input = input;
	        this._more = this._backtrack = this.done = false;
	        this.yylineno = this.yyleng = 0;
	        this.yytext = this.matched = this.match = '';
	        this.conditionStack = ['INITIAL'];
	        this.yylloc = {
	            first_line: 1,
	            first_column: 0,
	            last_line: 1,
	            last_column: 0
	        };
	        if (this.options.ranges) {
	            this.yylloc.range = [0,0];
	        }
	        this.offset = 0;
	        return this;
	    },

	// consumes and returns one char from the input
	input:function () {
	        var ch = this._input[0];
	        this.yytext += ch;
	        this.yyleng++;
	        this.offset++;
	        this.match += ch;
	        this.matched += ch;
	        var lines = ch.match(/(?:\r\n?|\n).*/g);
	        if (lines) {
	            this.yylineno++;
	            this.yylloc.last_line++;
	        } else {
	            this.yylloc.last_column++;
	        }
	        if (this.options.ranges) {
	            this.yylloc.range[1]++;
	        }

	        this._input = this._input.slice(1);
	        return ch;
	    },

	// unshifts one char (or a string) into the input
	unput:function (ch) {
	        var len = ch.length;
	        var lines = ch.split(/(?:\r\n?|\n)/g);

	        this._input = ch + this._input;
	        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
	        //this.yyleng -= len;
	        this.offset -= len;
	        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	        this.match = this.match.substr(0, this.match.length - 1);
	        this.matched = this.matched.substr(0, this.matched.length - 1);

	        if (lines.length - 1) {
	            this.yylineno -= lines.length - 1;
	        }
	        var r = this.yylloc.range;

	        this.yylloc = {
	            first_line: this.yylloc.first_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.first_column,
	            last_column: lines ?
	                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
	                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
	              this.yylloc.first_column - len
	        };

	        if (this.options.ranges) {
	            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	        }
	        this.yyleng = this.yytext.length;
	        return this;
	    },

	// When called from action, caches matched text and appends it on next action
	more:function () {
	        this._more = true;
	        return this;
	    },

	// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
	reject:function () {
	        if (this.options.backtrack_lexer) {
	            this._backtrack = true;
	        } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
	                text: "",
	                token: null,
	                line: this.yylineno
	            });

	        }
	        return this;
	    },

	// retain first n characters of the match
	less:function (n) {
	        this.unput(this.match.slice(n));
	    },

	// displays already matched input, i.e. for error messages
	pastInput:function () {
	        var past = this.matched.substr(0, this.matched.length - this.match.length);
	        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
	    },

	// displays upcoming input, i.e. for error messages
	upcomingInput:function () {
	        var next = this.match;
	        if (next.length < 20) {
	            next += this._input.substr(0, 20-next.length);
	        }
	        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	    },

	// displays the character position where the lexing error occurred, i.e. for error messages
	showPosition:function () {
	        var pre = this.pastInput();
	        var c = new Array(pre.length + 1).join("-");
	        return pre + this.upcomingInput() + "\n" + c + "^";
	    },

	// test the lexed token: return FALSE when not a match, otherwise return token
	test_match:function (match, indexed_rule) {
	        var token,
	            lines,
	            backup;

	        if (this.options.backtrack_lexer) {
	            // save context
	            backup = {
	                yylineno: this.yylineno,
	                yylloc: {
	                    first_line: this.yylloc.first_line,
	                    last_line: this.last_line,
	                    first_column: this.yylloc.first_column,
	                    last_column: this.yylloc.last_column
	                },
	                yytext: this.yytext,
	                match: this.match,
	                matches: this.matches,
	                matched: this.matched,
	                yyleng: this.yyleng,
	                offset: this.offset,
	                _more: this._more,
	                _input: this._input,
	                yy: this.yy,
	                conditionStack: this.conditionStack.slice(0),
	                done: this.done
	            };
	            if (this.options.ranges) {
	                backup.yylloc.range = this.yylloc.range.slice(0);
	            }
	        }

	        lines = match[0].match(/(?:\r\n?|\n).*/g);
	        if (lines) {
	            this.yylineno += lines.length;
	        }
	        this.yylloc = {
	            first_line: this.yylloc.last_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.last_column,
	            last_column: lines ?
	                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
	                         this.yylloc.last_column + match[0].length
	        };
	        this.yytext += match[0];
	        this.match += match[0];
	        this.matches = match;
	        this.yyleng = this.yytext.length;
	        if (this.options.ranges) {
	            this.yylloc.range = [this.offset, this.offset += this.yyleng];
	        }
	        this._more = false;
	        this._backtrack = false;
	        this._input = this._input.slice(match[0].length);
	        this.matched += match[0];
	        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
	        if (this.done && this._input) {
	            this.done = false;
	        }
	        if (token) {
	            return token;
	        } else if (this._backtrack) {
	            // recover context
	            for (var k in backup) {
	                this[k] = backup[k];
	            }
	            return false; // rule action called reject() implying the next rule should be tested instead.
	        }
	        return false;
	    },

	// return next match in input
	next:function () {
	        if (this.done) {
	            return this.EOF;
	        }
	        if (!this._input) {
	            this.done = true;
	        }

	        var token,
	            match,
	            tempMatch,
	            index;
	        if (!this._more) {
	            this.yytext = '';
	            this.match = '';
	        }
	        var rules = this._currentRules();
	        for (var i = 0; i < rules.length; i++) {
	            tempMatch = this._input.match(this.rules[rules[i]]);
	            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                match = tempMatch;
	                index = i;
	                if (this.options.backtrack_lexer) {
	                    token = this.test_match(tempMatch, rules[i]);
	                    if (token !== false) {
	                        return token;
	                    } else if (this._backtrack) {
	                        match = false;
	                        continue; // rule action called reject() implying a rule MISmatch.
	                    } else {
	                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	                        return false;
	                    }
	                } else if (!this.options.flex) {
	                    break;
	                }
	            }
	        }
	        if (match) {
	            token = this.test_match(match, rules[index]);
	            if (token !== false) {
	                return token;
	            }
	            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	            return false;
	        }
	        if (this._input === "") {
	            return this.EOF;
	        } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
	                text: "",
	                token: null,
	                line: this.yylineno
	            });
	        }
	    },

	// return next match that has a token
	lex:function lex() {
	        var r = this.next();
	        if (r) {
	            return r;
	        } else {
	            return this.lex();
	        }
	    },

	// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
	begin:function begin(condition) {
	        this.conditionStack.push(condition);
	    },

	// pop the previously active lexer condition state off the condition stack
	popState:function popState() {
	        var n = this.conditionStack.length - 1;
	        if (n > 0) {
	            return this.conditionStack.pop();
	        } else {
	            return this.conditionStack[0];
	        }
	    },

	// produce the lexer rule set which is active for the currently active lexer condition state
	_currentRules:function _currentRules() {
	        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
	            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	        } else {
	            return this.conditions["INITIAL"].rules;
	        }
	    },

	// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
	topState:function topState(n) {
	        n = this.conditionStack.length - 1 - Math.abs(n || 0);
	        if (n >= 0) {
	            return this.conditionStack[n];
	        } else {
	            return "INITIAL";
	        }
	    },

	// alias for begin(condition)
	pushState:function pushState(condition) {
	        this.begin(condition);
	    },

	// return the number of states currently on the stack
	stateStackSize:function stateStackSize() {
	        return this.conditionStack.length;
	    },
	options: {},
	performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {

	var YYSTATE=YY_START;
	switch($avoiding_name_collisions) {
	case 0:/* skip whitespace */
	break;
	case 1:return 18
	break;
	case 2:return 6
	break;
	case 3:return 7
	break;
	case 4:return 8
	break;
	case 5:return 9
	break;
	case 6:return 10
	break;
	case 7:return 11
	break;
	case 8:return 13
	break;
	case 9:return 14
	break;
	case 10:return 15
	break;
	case 11:return 16
	break;
	case 12:return 17
	break;
	case 13:return 12
	break;
	case 14:return 5
	break;
	case 15:return 'INVALID'
	break;
	}
	},
	rules: [/^(?:\s+)/,/^(?:([\.0-9]+)\b)/,/^(?:\+)/,/^(?:-)/,/^(?:\*)/,/^(?:\/)/,/^(?:\^)/,/^(?:!)/,/^(?:\()/,/^(?:\))/,/^(?:e\b)/,/^(?:pi\b)/,/^(?:ans\b)/,/^(?:[a-z]+)/,/^(?:$)/,/^(?:.)/],
	conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],"inclusive":true}}
	};
	return lexer;
	})();
	parser.lexer = lexer;
	function Parser () {
	  this.yy = {};
	}
	Parser.prototype = parser;parser.Parser = Parser;
	return new Parser;
	})();window.Calculator = (function(parser) {
	    // I18N: calculator error message
	    var ERROR_TEXT = $._("Error");
	    var CalculatorError = function(message) {
	        this.message = message;
	    };
	    CalculatorError.prototype = new Error();
	    CalculatorError.prototype.constructor = CalculatorError;

	    parser.yy.parseError = function parseError(str, hash) {
	        throw new CalculatorError(ERROR_TEXT);
	    };

	    var settings = window.localStorage == null ? {} : $.parseJSON(
	            window.localStorage["calculator_settings:" + window.USERNAME] || "{}");
	    if (settings.angleMode == null) {
	        settings.angleMode = "DEG";
	    }

	    return _.bindAll({
	        settings: settings,
	        parser: parser,
	        parse: _.bind(parser.parse, parser),

	        evaluate: function(tree, ans) {
	            var toRad = function(ang) {
	                if (settings.angleMode === "DEG") {
	                    return ang * Math.PI / 180;
	                }
	                return ang;
	            };
	            var fromRad = function(ang) {
	                if (settings.angleMode === "DEG") {
	                    return ang / Math.PI * 180;
	                }
	                return ang;
	            };
	            if (tree === "ans") {
	                if (ans !== undefined) {
	                    return ans;
	                } else {
	                    throw new CalculatorError($._("Invalid variable ans"));
	                }
	            } else if (tree === "pi") {
	                return Math.PI;
	            } else if (tree === "e") {
	                return Math.E;
	            } else if (_.isNumber(tree)) {
	                return tree;
	            } else if (_.isArray(tree)) {
	                var fns = {
	                    "+": function(a, b) { return a + b; },
	                    "-": function(a, b) { return b === undefined ? -a : a - b; },
	                    "*": function(a, b) { return a * b; },
	                    "/": function(a, b) { return a / b; },
	                    "^": function(a, b) { return Math.pow(a, b); },
	                    "!": function f(a) { return a <= 1 ? 1 : a * f(a - 1); },
	                    sqrt: function(a) { return Math.pow(a, 0.5); },
	                    sin: function(a) { return Math.sin(toRad(a)); },
	                    cos: function(a) { return Math.cos(toRad(a)); },
	                    tan: function(a) {
	                        var ans = Math.tan(toRad(a));
	                        if (isNaN(ans) || Math.abs(ans) > Math.pow(2, 53)) {
	                            throw new CalculatorError($._("undefined"));
	                        }
	                        return ans;
	                    },
	                    asin: function(a) {
	                        var ans = fromRad(Math.asin(a));
	                        if (isNaN(ans)) {
	                            throw new CalculatorError($._("undefined"));
	                        }
	                        return ans;
	                    },
	                    acos: function(a) {
	                        var ans = fromRad(Math.acos(a));
	                        if (isNaN(ans)) {
	                            throw new CalculatorError($._("undefined"));
	                        }
	                        return ans;
	                    },
	                    atan: function(a) {
	                        var ans = fromRad(Math.atan(a));
	                        if (isNaN(ans)) {
	                            throw new CalculatorError($._("undefined"));
	                        }
	                        return ans;
	                    },
	                    ln: function(a) {
	                        var ans = Math.log(a);
	                        if (isNaN(ans) || !isFinite(ans)) {
	                            throw new CalculatorError($._("undefined"));
	                        }
	                        return ans;
	                    },
	                    log: function(a) {
	                        var ans = Math.log(a) / Math.LN10;
	                        if (isNaN(ans) || !isFinite(ans)) {
	                            throw new CalculatorError($._("undefined"));
	                        }
	                        return ans;
	                    }
	                };

	                if (tree[0] in fns) {
	                    var self = this;
	                    return fns[tree[0]].apply(
	                        this, _.map(tree.slice(1), function(t) {
	                            return self.evaluate(t, ans); }));
	                } else {
	                    throw new CalculatorError(ERROR_TEXT);
	                }
	            } else {
	                throw new CalculatorError(
	                    $._("Invalid type %(type)s",
	                        {type: Object.prototype.toString.call(tree)}));
	            }
	        },

	        calculate: function(str, ans) {
	            var tree = this.parse(str);
	            return this.evaluate(tree, ans);
	        },
	        CalculatorError: CalculatorError
	    }, "evaluate", "calculate");
	})(Calculator);


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/*
	* jQuery Mobile Framework : "mouse" plugin
	* Copyright (c) jQuery Project
	* Dual licensed under the MIT or GPL Version 2 licenses.
	* http://jquery.org/license
	*/

	// This plugin is an experiment for abstracting away the touch and mouse
	// events so that developers don't have to worry about which method of input
	// the device their document is loaded on supports.
	//
	// The idea here is to allow the developer to register listeners for the
	// basic mouse events, such as mousedown, mousemove, mouseup, and click,
	// and the plugin will take care of registering the correct listeners
	// behind the scenes to invoke the listener at the fastest possible time
	// for that device, while still retaining the order of event firing in
	// the traditional mouse environment, should multiple handlers be registered
	// on the same element for different events.
	//
	// The current version exposes the following virtual events to jQuery bind methods:
	// "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel"

	(function( $, window, document, undefined ) {

	var dataPropertyName = "virtualMouseBindings",
		touchTargetPropertyName = "virtualTouchID",
		virtualEventNames = "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel".split( " " ),
		touchEventProps = "clientX clientY pageX pageY screenX screenY".split( " " ),
		mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],
		mouseEventProps = $.event.props.concat( mouseHookProps ),
		activeDocHandlers = {},
		resetTimerID = 0,
		startX = 0,
		startY = 0,
		didScroll = false,
		clickBlockList = [],
		blockMouseTriggers = false,
		blockTouchTriggers = false,
		eventCaptureSupported = "addEventListener" in document,
		$document = $( document ),
		nextTouchID = 1,
		lastTouchID = 0;

	$.vmouse = {
		moveDistanceThreshold: 10,
		clickDistanceThreshold: 10,
		resetTimerDuration: 1500
	};

	function getNativeEvent( event ) {

		while ( event && typeof event.originalEvent !== "undefined" ) {
			event = event.originalEvent;
		}
		return event;
	}

	function createVirtualEvent( event, eventType ) {

		var t = event.type,
			oe, props, ne, prop, ct, touch, i, j;

		event = $.Event(event);
		event.type = eventType;

		oe = event.originalEvent;
		props = $.event.props;

		// addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
		// https://github.com/jquery/jquery-mobile/issues/3280
		if ( t.search(/mouse/) >-1 ) {
			props = mouseEventProps;
		}

		// copy original event properties over to the new event
		// this would happen if we could call $.event.fix instead of $.Event
		// but we don't have a way to force an event to be fixed multiple times
		if ( oe ) {
			for ( i = props.length, prop; i; ) {
				prop = props[ --i ];
				event[ prop ] = oe[ prop ];
			}
		}

		// make sure that if the mouse and click virtual events are generated
		// without a .which one is defined
		if ( t.search(/mouse(down|up)|click/) > -1 && !event.which ){
			event.which = 1;
		}

		if ( t.search(/^touch/) !== -1 ) {
			ne = getNativeEvent( oe );
			t = ne.touches;
			ct = ne.changedTouches;
			touch = ( t && t.length ) ? t[0] : ( (ct && ct.length) ? ct[ 0 ] : undefined );

			if ( touch ) {
				for ( j = 0, len = touchEventProps.length; j < len; j++){
					prop = touchEventProps[ j ];
					event[ prop ] = touch[ prop ];
				}
			}
		}

		return event;
	}

	function getVirtualBindingFlags( element ) {

		var flags = {},
			b, k;

		while ( element ) {

			b = $.data( element, dataPropertyName );

			for (  k in b ) {
				if ( b[ k ] ) {
					flags[ k ] = flags.hasVirtualBinding = true;
				}
			}
			element = element.parentNode;
		}
		return flags;
	}

	function getClosestElementWithVirtualBinding( element, eventType ) {
		var b;
		while ( element ) {

			b = $.data( element, dataPropertyName );

			if ( b && ( !eventType || b[ eventType ] ) ) {
				return element;
			}
			element = element.parentNode;
		}
		return null;
	}

	function enableTouchBindings() {
		blockTouchTriggers = false;
	}

	function disableTouchBindings() {
		blockTouchTriggers = true;
	}

	function enableMouseBindings() {
		lastTouchID = 0;
		clickBlockList.length = 0;
		blockMouseTriggers = false;

		// When mouse bindings are enabled, our
		// touch bindings are disabled.
		disableTouchBindings();
	}

	function disableMouseBindings() {
		// When mouse bindings are disabled, our
		// touch bindings are enabled.
		enableTouchBindings();
	}

	function startResetTimer() {
		clearResetTimer();
		resetTimerID = setTimeout(function(){
			resetTimerID = 0;
			enableMouseBindings();
		}, $.vmouse.resetTimerDuration );
	}

	function clearResetTimer() {
		if ( resetTimerID ){
			clearTimeout( resetTimerID );
			resetTimerID = 0;
		}
	}

	function triggerVirtualEvent( eventType, event, flags ) {
		var ve;

		if ( ( flags && flags[ eventType ] ) ||
					( !flags && getClosestElementWithVirtualBinding( event.target, eventType ) ) ) {

			ve = createVirtualEvent( event, eventType );

			$( event.target).trigger( ve );
		}

		return ve;
	}

	function mouseEventCallback( event ) {
		var touchID = $.data(event.target, touchTargetPropertyName);

		if ( !blockMouseTriggers && ( !lastTouchID || lastTouchID !== touchID ) ){
			var ve = triggerVirtualEvent( "v" + event.type, event );
			if ( ve ) {
				if ( ve.isDefaultPrevented() ) {
					event.preventDefault();
				}
				if ( ve.isPropagationStopped() ) {
					event.stopPropagation();
				}
				if ( ve.isImmediatePropagationStopped() ) {
					event.stopImmediatePropagation();
				}
			}
		}
	}

	function handleTouchStart( event ) {

		var touches = getNativeEvent( event ).touches,
			target, flags;

		if ( touches && touches.length === 1 ) {

			target = event.target;
			flags = getVirtualBindingFlags( target );

			if ( flags.hasVirtualBinding ) {

				lastTouchID = nextTouchID++;
				$.data( target, touchTargetPropertyName, lastTouchID );

				clearResetTimer();

				disableMouseBindings();
				didScroll = false;

				var t = getNativeEvent( event ).touches[ 0 ];
				startX = t.pageX;
				startY = t.pageY;

				triggerVirtualEvent( "vmouseover", event, flags );
				triggerVirtualEvent( "vmousedown", event, flags );
			}
		}
	}

	function handleScroll( event ) {
		if ( blockTouchTriggers ) {
			return;
		}

		if ( !didScroll ) {
			triggerVirtualEvent( "vmousecancel", event, getVirtualBindingFlags( event.target ) );
		}

		didScroll = true;
		startResetTimer();
	}

	function handleTouchMove( event ) {
		if ( blockTouchTriggers ) {
			return;
		}

		var t = getNativeEvent( event ).touches[ 0 ],
			didCancel = didScroll,
			moveThreshold = $.vmouse.moveDistanceThreshold;
			didScroll = didScroll ||
				( Math.abs(t.pageX - startX) > moveThreshold ||
					Math.abs(t.pageY - startY) > moveThreshold ),
			flags = getVirtualBindingFlags( event.target );

		if ( didScroll && !didCancel ) {
			triggerVirtualEvent( "vmousecancel", event, flags );
		}

		triggerVirtualEvent( "vmousemove", event, flags );
		startResetTimer();
	}

	function handleTouchEnd( event ) {
		if ( blockTouchTriggers ) {
			return;
		}

		disableTouchBindings();

		var flags = getVirtualBindingFlags( event.target ),
			t;
		triggerVirtualEvent( "vmouseup", event, flags );

		if ( !didScroll ) {
			var ve = triggerVirtualEvent( "vclick", event, flags );
			if ( ve && ve.isDefaultPrevented() ) {
				// The target of the mouse events that follow the touchend
				// event don't necessarily match the target used during the
				// touch. This means we need to rely on coordinates for blocking
				// any click that is generated.
				t = getNativeEvent( event ).changedTouches[ 0 ];
				clickBlockList.push({
					touchID: lastTouchID,
					x: t.clientX,
					y: t.clientY
				});

				// Prevent any mouse events that follow from triggering
				// virtual event notifications.
				blockMouseTriggers = true;
			}
		}
		triggerVirtualEvent( "vmouseout", event, flags);
		didScroll = false;

		startResetTimer();
	}

	function hasVirtualBindings( ele ) {
		var bindings = $.data( ele, dataPropertyName ),
			k;

		if ( bindings ) {
			for ( k in bindings ) {
				if ( bindings[ k ] ) {
					return true;
				}
			}
		}
		return false;
	}

	function dummyMouseHandler(){}

	function getSpecialEventObject( eventType ) {
		var realType = eventType.substr( 1 );

		return {
			setup: function( data, namespace ) {
				// If this is the first virtual mouse binding for this element,
				// add a bindings object to its data.

				if ( !hasVirtualBindings( this ) ) {
					$.data( this, dataPropertyName, {});
				}

				// If setup is called, we know it is the first binding for this
				// eventType, so initialize the count for the eventType to zero.
				var bindings = $.data( this, dataPropertyName );
				bindings[ eventType ] = true;

				// If this is the first virtual mouse event for this type,
				// register a global handler on the document.

				activeDocHandlers[ eventType ] = ( activeDocHandlers[ eventType ] || 0 ) + 1;

				if ( activeDocHandlers[ eventType ] === 1 ) {
					$document.bind( realType, mouseEventCallback );
				}

				// Some browsers, like Opera Mini, won't dispatch mouse/click events
				// for elements unless they actually have handlers registered on them.
				// To get around this, we register dummy handlers on the elements.

				$( this ).bind( realType, dummyMouseHandler );

				// For now, if event capture is not supported, we rely on mouse handlers.
				if ( eventCaptureSupported ) {
					// If this is the first virtual mouse binding for the document,
					// register our touchstart handler on the document.

					activeDocHandlers[ "touchstart" ] = ( activeDocHandlers[ "touchstart" ] || 0) + 1;

					if (activeDocHandlers[ "touchstart" ] === 1) {
						$document.bind( "touchstart", handleTouchStart )
							.bind( "touchend", handleTouchEnd )

							// On touch platforms, touching the screen and then dragging your finger
							// causes the window content to scroll after some distance threshold is
							// exceeded. On these platforms, a scroll prevents a click event from being
							// dispatched, and on some platforms, even the touchend is suppressed. To
							// mimic the suppression of the click event, we need to watch for a scroll
							// event. Unfortunately, some platforms like iOS don't dispatch scroll
							// events until *AFTER* the user lifts their finger (touchend). This means
							// we need to watch both scroll and touchmove events to figure out whether
							// or not a scroll happenens before the touchend event is fired.

							.bind( "touchmove", handleTouchMove )
							.bind( "scroll", handleScroll );
					}
				}
			},

			teardown: function( data, namespace ) {
				// If this is the last virtual binding for this eventType,
				// remove its global handler from the document.

				--activeDocHandlers[ eventType ];

				if ( !activeDocHandlers[ eventType ] ) {
					$document.unbind( realType, mouseEventCallback );
				}

				if ( eventCaptureSupported ) {
					// If this is the last virtual mouse binding in existence,
					// remove our document touchstart listener.

					--activeDocHandlers[ "touchstart" ];

					if ( !activeDocHandlers[ "touchstart" ] ) {
						$document.unbind( "touchstart", handleTouchStart )
							.unbind( "touchmove", handleTouchMove )
							.unbind( "touchend", handleTouchEnd )
							.unbind( "scroll", handleScroll );
					}
				}

				var $this = $( this ),
					bindings = $.data( this, dataPropertyName );

				// teardown may be called when an element was
				// removed from the DOM. If this is the case,
				// jQuery core may have already stripped the element
				// of any data bindings so we need to check it before
				// using it.
				if ( bindings ) {
					bindings[ eventType ] = false;
				}

				// Unregister the dummy event handler.

				$this.unbind( realType, dummyMouseHandler );

				// If this is the last virtual mouse binding on the
				// element, remove the binding data from the element.

				if ( !hasVirtualBindings( this ) ) {
					$this.removeData( dataPropertyName );
				}
			}
		};
	}

	// Expose our custom events to the jQuery bind/unbind mechanism.

	for ( var i = 0; i < virtualEventNames.length; i++ ){
		$.event.special[ virtualEventNames[ i ] ] = getSpecialEventObject( virtualEventNames[ i ] );
	}

	// Add a capture click handler to block clicks.
	// Note that we require event capture support for this so if the device
	// doesn't support it, we punt for now and rely solely on mouse events.
	if ( eventCaptureSupported ) {
		document.addEventListener( "click", function( e ){
			var cnt = clickBlockList.length,
				target = e.target,
				x, y, ele, i, o, touchID;

			if ( cnt ) {
				x = e.clientX;
				y = e.clientY;
				threshold = $.vmouse.clickDistanceThreshold;

				// The idea here is to run through the clickBlockList to see if
				// the current click event is in the proximity of one of our
				// vclick events that had preventDefault() called on it. If we find
				// one, then we block the click.
				//
				// Why do we have to rely on proximity?
				//
				// Because the target of the touch event that triggered the vclick
				// can be different from the target of the click event synthesized
				// by the browser. The target of a mouse/click event that is syntehsized
				// from a touch event seems to be implementation specific. For example,
				// some browsers will fire mouse/click events for a link that is near
				// a touch event, even though the target of the touchstart/touchend event
				// says the user touched outside the link. Also, it seems that with most
				// browsers, the target of the mouse/click event is not calculated until the
				// time it is dispatched, so if you replace an element that you touched
				// with another element, the target of the mouse/click will be the new
				// element underneath that point.
				//
				// Aside from proximity, we also check to see if the target and any
				// of its ancestors were the ones that blocked a click. This is necessary
				// because of the strange mouse/click target calculation done in the
				// Android 2.1 browser, where if you click on an element, and there is a
				// mouse/click handler on one of its ancestors, the target will be the
				// innermost child of the touched element, even if that child is no where
				// near the point of touch.

				ele = target;

				while ( ele ) {
					for ( i = 0; i < cnt; i++ ) {
						o = clickBlockList[ i ];
						touchID = 0;

						if ( ( ele === target && Math.abs( o.x - x ) < threshold && Math.abs( o.y - y ) < threshold ) ||
									$.data( ele, touchTargetPropertyName ) === o.touchID ) {
							// XXX: We may want to consider removing matches from the block list
							//      instead of waiting for the reset timer to fire.
							e.preventDefault();
							e.stopPropagation();
							return;
						}
					}
					ele = ele.parentNode;
				}
			}
		}, true);
	}
	})( jQuery, window, document );


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Raphael 1.5.2 - JavaScript Vector Library
	 *
	 * Copyright (c) 2010 Dmitry Baranovskiy (http://raphaeljs.com)
	 * Licensed under the MIT (http://raphaeljs.com/license.html) license.
	 */
	(function () {
	    var setAttr;
	    if ("".trim) {
	        setAttr = function(node, att, value) {
	            node.setAttribute(att, String(value).trim());
	        };
	    } else {
	        setAttr = function(node, att, value) {
	            node.setAttribute(att, String(value));
	        };
	    }
	    function R() {
	        if (R.is(arguments[0], array)) {
	            var a = arguments[0],
	                cnv = create[apply](R, a.splice(0, 3 + R.is(a[0], nu))),
	                res = cnv.set();
	            for (var i = 0, ii = a[length]; i < ii; i++) {
	                var j = a[i] || {};
	                elements[has](j.type) && res[push](cnv[j.type]().attr(j));
	            }
	            return res;
	        }
	        return create[apply](R, arguments);
	    }
	    R.version = "1.5.2";
	    var separator = /[, ]+/,
	        elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
	        formatrg = /\{(\d+)\}/g,
	        proto = "prototype",
	        has = "hasOwnProperty",
	        doc = document,
	        win = window,
	        oldRaphael = {
	            was: Object[proto][has].call(win, "Raphael"),
	            is: win.Raphael
	        },
	        Paper = function () {
	            this.customAttributes = {};
	        },
	        paperproto,
	        appendChild = "appendChild",
	        apply = "apply",
	        concat = "concat",
	        supportsTouch = "createTouch" in doc,
	        E = "",
	        S = " ",
	        Str = String,
	        split = "split",
	        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend orientationchange touchcancel gesturestart gesturechange gestureend"[split](S),
	        touchMap = {
	            mousedown: "touchstart",
	            mousemove: "touchmove",
	            mouseup: "touchend"
	        },
	        join = "join",
	        length = "length",
	        lowerCase = Str[proto].toLowerCase,
	        math = Math,
	        mmax = math.max,
	        mmin = math.min,
	        abs = math.abs,
	        pow = math.pow,
	        PI = math.PI,
	        nu = "number",
	        string = "string",
	        array = "array",
	        toString = "toString",
	        fillString = "fill",
	        objectToString = Object[proto][toString],
	        paper = {},
	        push = "push",
	        ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
	        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
	        isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
	        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
	        round = math.round,
	        toFloat = parseFloat,
	        toInt = parseInt,
	        ms = " progid:DXImageTransform.Microsoft",
	        upperCase = Str[proto].toUpperCase,
	        availableAttrs = {blur: 0, "clip-rect": "0 0 1e9 1e9", cursor: "default", cx: 0, cy: 0, fill: "#fff", "fill-opacity": 1, font: '10px "Arial"', "font-family": '"Arial"', "font-size": "10", "font-style": "normal", "font-weight": 400, gradient: 0, height: 0, href: "http://raphaeljs.com/", opacity: 1, path: "M0,0", r: 0, rotation: 0, rx: 0, ry: 0, scale: "1 1", src: "", stroke: "#000", "stroke-dasharray": "", "stroke-linecap": "butt", "stroke-linejoin": "butt", "stroke-miterlimit": 0, "stroke-opacity": 1, "stroke-width": 1, target: "_blank", "text-anchor": "middle", title: "Raphael", translation: "0 0", width: 0, x: 0, y: 0},
	        availableAnimAttrs = {along: "along", blur: nu, "clip-rect": "csv", cx: nu, cy: nu, fill: "colour", "fill-opacity": nu, "font-size": nu, height: nu, opacity: nu, path: "path", r: nu, rotation: "csv", rx: nu, ry: nu, scale: "csv", stroke: "colour", "stroke-opacity": nu, "stroke-width": nu, translation: "csv", width: nu, x: nu, y: nu},
	        rp = "replace",
	        animKeyFrames= /^(from|to|\d+%?)$/,
	        commaSpaces = /\s*,\s*/,
	        hsrg = {hs: 1, rg: 1},
	        p2s = /,?([achlmqrstvxz]),?/gi,
	        pathCommand = /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,
	        pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,
	        radial_gradient = /^r(?:\(([^,]+?)\s*,\s*([^\)]+?)\))?/,
	        sortByKey = function (a, b) {
	            return a.key - b.key;
	        };

	    R.type = (win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
	    if (R.type == "VML") {
	        var d = doc.createElement("div"),
	            b;
	        d.innerHTML = '<v:shape adj="1"/>';
	        b = d.firstChild;
	        b.style.behavior = "url(#default#VML)";
	        if (!(b && typeof b.adj == "object")) {
	            return R.type = null;
	        }
	        d = null;
	    }
	    R.svg = !(R.vml = R.type == "VML");
	    Paper[proto] = R[proto];
	    paperproto = Paper[proto];
	    R._id = 0;
	    R._oid = 0;
	    R.fn = {};
	    R.is = function (o, type) {
	        type = lowerCase.call(type);
	        if (type == "finite") {
	            return !isnan[has](+o);
	        }
	        return  (type == "null" && o === null) ||
	                (type == typeof o) ||
	                (type == "object" && o === Object(o)) ||
	                (type == "array" && Array.isArray && Array.isArray(o)) ||
	                objectToString.call(o).slice(8, -1).toLowerCase() == type;
	    };
	    R.angle = function (x1, y1, x2, y2, x3, y3) {
	        if (x3 == null) {
	            var x = x1 - x2,
	                y = y1 - y2;
	            if (!x && !y) {
	                return 0;
	            }
	            return ((x < 0) * 180 + math.atan(-y / -x) * 180 / PI + 360) % 360;
	        } else {
	            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
	        }
	    };
	    R.rad = function (deg) {
	        return deg % 360 * PI / 180;
	    };
	    R.deg = function (rad) {
	        return rad * 180 / PI % 360;
	    };
	    R.snapTo = function (values, value, tolerance) {
	        tolerance = R.is(tolerance, "finite") ? tolerance : 10;
	        if (R.is(values, array)) {
	            var i = values.length;
	            while (i--) if (abs(values[i] - value) <= tolerance) {
	                return values[i];
	            }
	        } else {
	            values = +values;
	            var rem = value % values;
	            if (rem < tolerance) {
	                return value - rem;
	            }
	            if (rem > values - tolerance) {
	                return value - rem + values;
	            }
	        }
	        return value;
	    };
	    function createUUID() {
	        // http://www.ietf.org/rfc/rfc4122.txt
	        var s = [],
	            i = 0;
	        for (; i < 32; i++) {
	            s[i] = (~~(math.random() * 16))[toString](16);
	        }
	        s[12] = 4;  // bits 12-15 of the time_hi_and_version field to 0010
	        s[16] = ((s[16] & 3) | 8)[toString](16);  // bits 6-7 of the clock_seq_hi_and_reserved to 01
	        return "r-" + s[join]("");
	    }

	    R.setWindow = function (newwin) {
	        win = newwin;
	        doc = win.document;
	    };
	    // colour utilities
	    var toHex = function (color) {
	        if (R.vml) {
	            // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
	            var trim = /^\s+|\s+$/g;
	            var bod;
	            try {
	                var docum = new ActiveXObject("htmlfile");
	                docum.write("<body>");
	                docum.close();
	                bod = docum.body;
	            } catch(e) {
	                bod = createPopup().document.body;
	            }
	            var range = bod.createTextRange();
	            toHex = cacher(function (color) {
	                try {
	                    bod.style.color = Str(color)[rp](trim, E);
	                    var value = range.queryCommandValue("ForeColor");
	                    value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
	                    return "#" + ("000000" + value[toString](16)).slice(-6);
	                } catch(e) {
	                    return "none";
	                }
	            });
	        } else {
	            var i = doc.createElement("i");
	            i.title = "Rapha\xebl Colour Picker";
	            i.style.display = "none";
	            doc.body[appendChild](i);
	            toHex = cacher(function (color) {
	                i.style.color = color;
	                return doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
	            });
	        }
	        return toHex(color);
	    },
	    hsbtoString = function () {
	        return "hsb(" + [this.h, this.s, this.b] + ")";
	    },
	    hsltoString = function () {
	        return "hsl(" + [this.h, this.s, this.l] + ")";
	    },
	    rgbtoString = function () {
	        return this.hex;
	    };
	    R.hsb2rgb = function (h, s, b, o) {
	        if (R.is(h, "object") && "h" in h && "s" in h && "b" in h) {
	            b = h.b;
	            s = h.s;
	            h = h.h;
	            o = h.o;
	        }
	        return R.hsl2rgb(h, s, b / 2, o);
	    };
	    R.hsl2rgb = function (h, s, l, o) {
	        if (R.is(h, "object") && "h" in h && "s" in h && "l" in h) {
	            l = h.l;
	            s = h.s;
	            h = h.h;
	        }
	        if (h > 1 || s > 1 || l > 1) {
	            h /= 360;
	            s /= 100;
	            l /= 100;
	        }
	        var rgb = {},
	            channels = ["r", "g", "b"],
	            t2, t1, t3, r, g, b;
	        if (!s) {
	            rgb = {
	                r: l,
	                g: l,
	                b: l
	            };
	        } else {
	            if (l < .5) {
	                t2 = l * (1 + s);
	            } else {
	                t2 = l + s - l * s;
	            }
	            t1 = 2 * l - t2;
	            for (var i = 0; i < 3; i++) {
	                t3 = h + 1 / 3 * -(i - 1);
	                t3 < 0 && t3++;
	                t3 > 1 && t3--;
	                if (t3 * 6 < 1) {
	                    rgb[channels[i]] = t1 + (t2 - t1) * 6 * t3;
	                } else if (t3 * 2 < 1) {
	                    rgb[channels[i]] = t2;
	                } else if (t3 * 3 < 2) {
	                    rgb[channels[i]] = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	                } else {
	                    rgb[channels[i]] = t1;
	                }
	            }
	        }
	        rgb.r *= 255;
	        rgb.g *= 255;
	        rgb.b *= 255;
	        rgb.hex = "#" + (16777216 | rgb.b | (rgb.g << 8) | (rgb.r << 16)).toString(16).slice(1);
	        R.is(o, "finite") && (rgb.opacity = o);
	        rgb.toString = rgbtoString;
	        return rgb;
	    };
	    R.rgb2hsb = function (red, green, blue) {
	        if (green == null && R.is(red, "object") && "r" in red && "g" in red && "b" in red) {
	            blue = red.b;
	            green = red.g;
	            red = red.r;
	        }
	        if (green == null && R.is(red, string)) {
	            var clr = R.getRGB(red);
	            red = clr.r;
	            green = clr.g;
	            blue = clr.b;
	        }
	        if (red > 1 || green > 1 || blue > 1) {
	            red /= 255;
	            green /= 255;
	            blue /= 255;
	        }
	        var max = mmax(red, green, blue),
	            min = mmin(red, green, blue),
	            hue,
	            saturation,
	            brightness = max;
	        if (min == max) {
	            return {h: 0, s: 0, b: max, toString: hsbtoString};
	        } else {
	            var delta = (max - min);
	            saturation = delta / max;
	            if (red == max) {
	                hue = (green - blue) / delta;
	            } else if (green == max) {
	                hue = 2 + ((blue - red) / delta);
	            } else {
	                hue = 4 + ((red - green) / delta);
	            }
	            hue /= 6;
	            hue < 0 && hue++;
	            hue > 1 && hue--;
	        }
	        return {h: hue, s: saturation, b: brightness, toString: hsbtoString};
	    };
	    R.rgb2hsl = function (red, green, blue) {
	        if (green == null && R.is(red, "object") && "r" in red && "g" in red && "b" in red) {
	            blue = red.b;
	            green = red.g;
	            red = red.r;
	        }
	        if (green == null && R.is(red, string)) {
	            var clr = R.getRGB(red);
	            red = clr.r;
	            green = clr.g;
	            blue = clr.b;
	        }
	        if (red > 1 || green > 1 || blue > 1) {
	            red /= 255;
	            green /= 255;
	            blue /= 255;
	        }
	        var max = mmax(red, green, blue),
	            min = mmin(red, green, blue),
	            h,
	            s,
	            l = (max + min) / 2,
	            hsl;
	        if (min == max) {
	            hsl =  {h: 0, s: 0, l: l};
	        } else {
	            var delta = max - min;
	            s = l < .5 ? delta / (max + min) : delta / (2 - max - min);
	            if (red == max) {
	                h = (green - blue) / delta;
	            } else if (green == max) {
	                h = 2 + (blue - red) / delta;
	            } else {
	                h = 4 + (red - green) / delta;
	            }
	            h /= 6;
	            h < 0 && h++;
	            h > 1 && h--;
	            hsl = {h: h, s: s, l: l};
	        }
	        hsl.toString = hsltoString;
	        return hsl;
	    };
	    R._path2string = function () {
	        return this.join(",")[rp](p2s, "$1");
	    };
	    function cacher(f, scope, postprocessor) {
	        function newf() {
	            var arg = Array[proto].slice.call(arguments, 0),
	                args = arg[join]("\u25ba"),
	                cache = newf.cache = newf.cache || {},
	                count = newf.count = newf.count || [];
	            if (cache[has](args)) {
	                return postprocessor ? postprocessor(cache[args]) : cache[args];
	            }
	            count[length] >= 1e3 && delete cache[count.shift()];
	            count[push](args);
	            cache[args] = f[apply](scope, arg);
	            return postprocessor ? postprocessor(cache[args]) : cache[args];
	        }
	        return newf;
	    }

	    R.getRGB = cacher(function (colour) {
	        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
	            return {r: -1, g: -1, b: -1, hex: "none", error: 1};
	        }
	        if (colour == "none") {
	            return {r: -1, g: -1, b: -1, hex: "none"};
	        }
	        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
	        var res,
	            red,
	            green,
	            blue,
	            opacity,
	            t,
	            values,
	            rgb = colour.match(colourRegExp);
	        if (rgb) {
	            if (rgb[2]) {
	                blue = toInt(rgb[2].substring(5), 16);
	                green = toInt(rgb[2].substring(3, 5), 16);
	                red = toInt(rgb[2].substring(1, 3), 16);
	            }
	            if (rgb[3]) {
	                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
	                green = toInt((t = rgb[3].charAt(2)) + t, 16);
	                red = toInt((t = rgb[3].charAt(1)) + t, 16);
	            }
	            if (rgb[4]) {
	                values = rgb[4][split](commaSpaces);
	                red = toFloat(values[0]);
	                values[0].slice(-1) == "%" && (red *= 2.55);
	                green = toFloat(values[1]);
	                values[1].slice(-1) == "%" && (green *= 2.55);
	                blue = toFloat(values[2]);
	                values[2].slice(-1) == "%" && (blue *= 2.55);
	                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
	                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
	            }
	            if (rgb[5]) {
	                values = rgb[5][split](commaSpaces);
	                red = toFloat(values[0]);
	                values[0].slice(-1) == "%" && (red *= 2.55);
	                green = toFloat(values[1]);
	                values[1].slice(-1) == "%" && (green *= 2.55);
	                blue = toFloat(values[2]);
	                values[2].slice(-1) == "%" && (blue *= 2.55);
	                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
	                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
	                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
	                return R.hsb2rgb(red, green, blue, opacity);
	            }
	            if (rgb[6]) {
	                values = rgb[6][split](commaSpaces);
	                red = toFloat(values[0]);
	                values[0].slice(-1) == "%" && (red *= 2.55);
	                green = toFloat(values[1]);
	                values[1].slice(-1) == "%" && (green *= 2.55);
	                blue = toFloat(values[2]);
	                values[2].slice(-1) == "%" && (blue *= 2.55);
	                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
	                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
	                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
	                return R.hsl2rgb(red, green, blue, opacity);
	            }
	            rgb = {r: red, g: green, b: blue};
	            rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
	            R.is(opacity, "finite") && (rgb.opacity = opacity);
	            return rgb;
	        }
	        return {r: -1, g: -1, b: -1, hex: "none", error: 1};
	    }, R);
	    R.getColor = function (value) {
	        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
	            rgb = this.hsb2rgb(start.h, start.s, start.b);
	        start.h += .075;
	        if (start.h > 1) {
	            start.h = 0;
	            start.s -= .2;
	            start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
	        }
	        return rgb.hex;
	    };
	    R.getColor.reset = function () {
	        delete this.start;
	    };
	    // path utilities
	    R.parsePathString = cacher(function (pathString) {
	        if (!pathString) {
	            return null;
	        }
	        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0},
	            data = [];
	        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
	            data = pathClone(pathString);
	        }
	        if (!data[length]) {
	            Str(pathString)[rp](pathCommand, function (a, b, c) {
	                var params = [],
	                    name = lowerCase.call(b);
	                c[rp](pathValues, function (a, b) {
	                    b && params[push](+b);
	                });
	                if (name == "m" && params[length] > 2) {
	                    data[push]([b][concat](params.splice(0, 2)));
	                    name = "l";
	                    b = b == "m" ? "l" : "L";
	                }
	                while (params[length] >= paramCounts[name]) {
	                    data[push]([b][concat](params.splice(0, paramCounts[name])));
	                    if (!paramCounts[name]) {
	                        break;
	                    }
	                }
	            });
	        }
	        data[toString] = R._path2string;
	        return data;
	    });
	    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
	        var t1 = 1 - t,
	            x = pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
	            y = pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y,
	            mx = p1x + 2 * t * (c1x - p1x) + t * t * (c2x - 2 * c1x + p1x),
	            my = p1y + 2 * t * (c1y - p1y) + t * t * (c2y - 2 * c1y + p1y),
	            nx = c1x + 2 * t * (c2x - c1x) + t * t * (p2x - 2 * c2x + c1x),
	            ny = c1y + 2 * t * (c2y - c1y) + t * t * (p2y - 2 * c2y + c1y),
	            ax = (1 - t) * p1x + t * c1x,
	            ay = (1 - t) * p1y + t * c1y,
	            cx = (1 - t) * c2x + t * p2x,
	            cy = (1 - t) * c2y + t * p2y,
	            alpha = (90 - math.atan((mx - nx) / (my - ny)) * 180 / PI);
	        (mx > nx || my < ny) && (alpha += 180);
	        return {x: x, y: y, m: {x: mx, y: my}, n: {x: nx, y: ny}, start: {x: ax, y: ay}, end: {x: cx, y: cy}, alpha: alpha};
	    };
	    var pathDimensions = cacher(function (path) {
	        if (!path) {
	            return {x: 0, y: 0, width: 0, height: 0};
	        }
	        path = path2curve(path);
	        var x = 0,
	            y = 0,
	            X = [],
	            Y = [],
	            p;
	        for (var i = 0, ii = path[length]; i < ii; i++) {
	            p = path[i];
	            if (p[0] == "M") {
	                x = p[1];
	                y = p[2];
	                X[push](x);
	                Y[push](y);
	            } else {
	                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
	                X = X[concat](dim.min.x, dim.max.x);
	                Y = Y[concat](dim.min.y, dim.max.y);
	                x = p[5];
	                y = p[6];
	            }
	        }
	        var xmin = mmin[apply](0, X),
	            ymin = mmin[apply](0, Y);
	        return {
	            x: xmin,
	            y: ymin,
	            width: mmax[apply](0, X) - xmin,
	            height: mmax[apply](0, Y) - ymin
	        };
	    }),
	        pathClone = function (pathArray) {
	            var res = [];
	            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
	                pathArray = R.parsePathString(pathArray);
	            }
	            for (var i = 0, ii = pathArray[length]; i < ii; i++) {
	                res[i] = [];
	                for (var j = 0, jj = pathArray[i][length]; j < jj; j++) {
	                    res[i][j] = pathArray[i][j];
	                }
	            }
	            res[toString] = R._path2string;
	            return res;
	        },
	        pathToRelative = cacher(function (pathArray) {
	            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
	                pathArray = R.parsePathString(pathArray);
	            }
	            var res = [],
	                x = 0,
	                y = 0,
	                mx = 0,
	                my = 0,
	                start = 0;
	            if (pathArray[0][0] == "M") {
	                x = pathArray[0][1];
	                y = pathArray[0][2];
	                mx = x;
	                my = y;
	                start++;
	                res[push](["M", x, y]);
	            }
	            for (var i = start, ii = pathArray[length]; i < ii; i++) {
	                var r = res[i] = [],
	                    pa = pathArray[i];
	                if (pa[0] != lowerCase.call(pa[0])) {
	                    r[0] = lowerCase.call(pa[0]);
	                    switch (r[0]) {
	                        case "a":
	                            r[1] = pa[1];
	                            r[2] = pa[2];
	                            r[3] = pa[3];
	                            r[4] = pa[4];
	                            r[5] = pa[5];
	                            r[6] = +(pa[6] - x).toFixed(3);
	                            r[7] = +(pa[7] - y).toFixed(3);
	                            break;
	                        case "v":
	                            r[1] = +(pa[1] - y).toFixed(3);
	                            break;
	                        case "m":
	                            mx = pa[1];
	                            my = pa[2];
	                        default:
	                            for (var j = 1, jj = pa[length]; j < jj; j++) {
	                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
	                            }
	                    }
	                } else {
	                    r = res[i] = [];
	                    if (pa[0] == "m") {
	                        mx = pa[1] + x;
	                        my = pa[2] + y;
	                    }
	                    for (var k = 0, kk = pa[length]; k < kk; k++) {
	                        res[i][k] = pa[k];
	                    }
	                }
	                var len = res[i][length];
	                switch (res[i][0]) {
	                    case "z":
	                        x = mx;
	                        y = my;
	                        break;
	                    case "h":
	                        x += +res[i][len - 1];
	                        break;
	                    case "v":
	                        y += +res[i][len - 1];
	                        break;
	                    default:
	                        x += +res[i][len - 2];
	                        y += +res[i][len - 1];
	                }
	            }
	            res[toString] = R._path2string;
	            return res;
	        }, 0, pathClone),
	        pathToAbsolute = cacher(function (pathArray) {
	            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
	                pathArray = R.parsePathString(pathArray);
	            }
	            var res = [],
	                x = 0,
	                y = 0,
	                mx = 0,
	                my = 0,
	                start = 0;
	            if (pathArray[0][0] == "M") {
	                x = +pathArray[0][1];
	                y = +pathArray[0][2];
	                mx = x;
	                my = y;
	                start++;
	                res[0] = ["M", x, y];
	            }
	            for (var i = start, ii = pathArray[length]; i < ii; i++) {
	                var r = res[i] = [],
	                    pa = pathArray[i];
	                if (pa[0] != upperCase.call(pa[0])) {
	                    r[0] = upperCase.call(pa[0]);
	                    switch (r[0]) {
	                        case "A":
	                            r[1] = pa[1];
	                            r[2] = pa[2];
	                            r[3] = pa[3];
	                            r[4] = pa[4];
	                            r[5] = pa[5];
	                            r[6] = +(pa[6] + x);
	                            r[7] = +(pa[7] + y);
	                            break;
	                        case "V":
	                            r[1] = +pa[1] + y;
	                            break;
	                        case "H":
	                            r[1] = +pa[1] + x;
	                            break;
	                        case "M":
	                            mx = +pa[1] + x;
	                            my = +pa[2] + y;
	                        default:
	                            for (var j = 1, jj = pa[length]; j < jj; j++) {
	                                r[j] = +pa[j] + ((j % 2) ? x : y);
	                            }
	                    }
	                } else {
	                    for (var k = 0, kk = pa[length]; k < kk; k++) {
	                        res[i][k] = pa[k];
	                    }
	                }
	                switch (r[0]) {
	                    case "Z":
	                        x = mx;
	                        y = my;
	                        break;
	                    case "H":
	                        x = r[1];
	                        break;
	                    case "V":
	                        y = r[1];
	                        break;
	                    case "M":
	                        mx = res[i][res[i][length] - 2];
	                        my = res[i][res[i][length] - 1];
	                    default:
	                        x = res[i][res[i][length] - 2];
	                        y = res[i][res[i][length] - 1];
	                }
	            }
	            res[toString] = R._path2string;
	            return res;
	        }, null, pathClone),
	        l2c = function (x1, y1, x2, y2) {
	            return [x1, y1, x2, y2, x2, y2];
	        },
	        q2c = function (x1, y1, ax, ay, x2, y2) {
	            var _13 = 1 / 3,
	                _23 = 2 / 3;
	            return [
	                    _13 * x1 + _23 * ax,
	                    _13 * y1 + _23 * ay,
	                    _13 * x2 + _23 * ax,
	                    _13 * y2 + _23 * ay,
	                    x2,
	                    y2
	                ];
	        },
	        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
	            // for more information of where this math came from visit:
	            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
	            var _120 = PI * 120 / 180,
	                rad = PI / 180 * (+angle || 0),
	                res = [],
	                xy,
	                rotate = cacher(function (x, y, rad) {
	                    var X = x * math.cos(rad) - y * math.sin(rad),
	                        Y = x * math.sin(rad) + y * math.cos(rad);
	                    return {x: X, y: Y};
	                });
	            if (!recursive) {
	                xy = rotate(x1, y1, -rad);
	                x1 = xy.x;
	                y1 = xy.y;
	                xy = rotate(x2, y2, -rad);
	                x2 = xy.x;
	                y2 = xy.y;
	                var cos = math.cos(PI / 180 * angle),
	                    sin = math.sin(PI / 180 * angle),
	                    x = (x1 - x2) / 2,
	                    y = (y1 - y2) / 2;
	                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
	                if (h > 1) {
	                    h = math.sqrt(h);
	                    rx = h * rx;
	                    ry = h * ry;
	                }
	                var rx2 = rx * rx,
	                    ry2 = ry * ry,
	                    k = (large_arc_flag == sweep_flag ? -1 : 1) *
	                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
	                    cx = k * rx * y / ry + (x1 + x2) / 2,
	                    cy = k * -ry * x / rx + (y1 + y2) / 2,
	                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
	                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));

	                f1 = x1 < cx ? PI - f1 : f1;
	                f2 = x2 < cx ? PI - f2 : f2;
	                f1 < 0 && (f1 = PI * 2 + f1);
	                f2 < 0 && (f2 = PI * 2 + f2);
	                if (sweep_flag && f1 > f2) {
	                    f1 = f1 - PI * 2;
	                }
	                if (!sweep_flag && f2 > f1) {
	                    f2 = f2 - PI * 2;
	                }
	            } else {
	                f1 = recursive[0];
	                f2 = recursive[1];
	                cx = recursive[2];
	                cy = recursive[3];
	            }
	            var df = f2 - f1;
	            if (abs(df) > _120) {
	                var f2old = f2,
	                    x2old = x2,
	                    y2old = y2;
	                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
	                x2 = cx + rx * math.cos(f2);
	                y2 = cy + ry * math.sin(f2);
	                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
	            }
	            df = f2 - f1;
	            var c1 = math.cos(f1),
	                s1 = math.sin(f1),
	                c2 = math.cos(f2),
	                s2 = math.sin(f2),
	                t = math.tan(df / 4),
	                hx = 4 / 3 * rx * t,
	                hy = 4 / 3 * ry * t,
	                m1 = [x1, y1],
	                m2 = [x1 + hx * s1, y1 - hy * c1],
	                m3 = [x2 + hx * s2, y2 - hy * c2],
	                m4 = [x2, y2];
	            m2[0] = 2 * m1[0] - m2[0];
	            m2[1] = 2 * m1[1] - m2[1];
	            if (recursive) {
	                return [m2, m3, m4][concat](res);
	            } else {
	                res = [m2, m3, m4][concat](res)[join]()[split](",");
	                var newres = [];
	                for (var i = 0, ii = res[length]; i < ii; i++) {
	                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
	                }
	                return newres;
	            }
	        },
	        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
	            var t1 = 1 - t;
	            return {
	                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
	                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
	            };
	        },
	        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
	            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
	                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
	                c = p1x - c1x,
	                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
	                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
	                y = [p1y, p2y],
	                x = [p1x, p2x],
	                dot;
	            abs(t1) > "1e12" && (t1 = .5);
	            abs(t2) > "1e12" && (t2 = .5);
	            if (t1 > 0 && t1 < 1) {
	                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
	                x[push](dot.x);
	                y[push](dot.y);
	            }
	            if (t2 > 0 && t2 < 1) {
	                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
	                x[push](dot.x);
	                y[push](dot.y);
	            }
	            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
	            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
	            c = p1y - c1y;
	            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
	            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
	            abs(t1) > "1e12" && (t1 = .5);
	            abs(t2) > "1e12" && (t2 = .5);
	            if (t1 > 0 && t1 < 1) {
	                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
	                x[push](dot.x);
	                y[push](dot.y);
	            }
	            if (t2 > 0 && t2 < 1) {
	                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
	                x[push](dot.x);
	                y[push](dot.y);
	            }
	            return {
	                min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
	                max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
	            };
	        }),
	        path2curve = cacher(function (path, path2) {
	            var p = pathToAbsolute(path),
	                p2 = path2 && pathToAbsolute(path2),
	                attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
	                attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
	                processPath = function (path, d) {
	                    var nx, ny;
	                    if (!path) {
	                        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
	                    }
	                    !(path[0] in {T:1, Q:1}) && (d.qx = d.qy = null);
	                    switch (path[0]) {
	                        case "M":
	                            d.X = path[1];
	                            d.Y = path[2];
	                            break;
	                        case "A":
	                            path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
	                            break;
	                        case "S":
	                            nx = d.x + (d.x - (d.bx || d.x));
	                            ny = d.y + (d.y - (d.by || d.y));
	                            path = ["C", nx, ny][concat](path.slice(1));
	                            break;
	                        case "T":
	                            d.qx = d.x + (d.x - (d.qx || d.x));
	                            d.qy = d.y + (d.y - (d.qy || d.y));
	                            path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
	                            break;
	                        case "Q":
	                            d.qx = path[1];
	                            d.qy = path[2];
	                            path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
	                            break;
	                        case "L":
	                            path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
	                            break;
	                        case "H":
	                            path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
	                            break;
	                        case "V":
	                            path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
	                            break;
	                        case "Z":
	                            path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
	                            break;
	                    }
	                    return path;
	                },
	                fixArc = function (pp, i) {
	                    if (pp[i][length] > 7) {
	                        pp[i].shift();
	                        var pi = pp[i];
	                        while (pi[length]) {
	                            pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
	                        }
	                        pp.splice(i, 1);
	                        ii = mmax(p[length], p2 && p2[length] || 0);
	                    }
	                },
	                fixM = function (path1, path2, a1, a2, i) {
	                    if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
	                        path2.splice(i, 0, ["M", a2.x, a2.y]);
	                        a1.bx = 0;
	                        a1.by = 0;
	                        a1.x = path1[i][1];
	                        a1.y = path1[i][2];
	                        ii = mmax(p[length], p2 && p2[length] || 0);
	                    }
	                };
	            for (var i = 0, ii = mmax(p[length], p2 && p2[length] || 0); i < ii; i++) {
	                p[i] = processPath(p[i], attrs);
	                fixArc(p, i);
	                p2 && (p2[i] = processPath(p2[i], attrs2));
	                p2 && fixArc(p2, i);
	                fixM(p, p2, attrs, attrs2, i);
	                fixM(p2, p, attrs2, attrs, i);
	                var seg = p[i],
	                    seg2 = p2 && p2[i],
	                    seglen = seg[length],
	                    seg2len = p2 && seg2[length];
	                attrs.x = seg[seglen - 2];
	                attrs.y = seg[seglen - 1];
	                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
	                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
	                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
	                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
	                attrs2.x = p2 && seg2[seg2len - 2];
	                attrs2.y = p2 && seg2[seg2len - 1];
	            }
	            return p2 ? [p, p2] : p;
	        }, null, pathClone),
	        parseDots = cacher(function (gradient) {
	            var dots = [];
	            for (var i = 0, ii = gradient[length]; i < ii; i++) {
	                var dot = {},
	                    par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
	                dot.color = R.getRGB(par[1]);
	                if (dot.color.error) {
	                    return null;
	                }
	                dot.color = dot.color.hex;
	                par[2] && (dot.offset = par[2] + "%");
	                dots[push](dot);
	            }
	            for (i = 1, ii = dots[length] - 1; i < ii; i++) {
	                if (!dots[i].offset) {
	                    var start = toFloat(dots[i - 1].offset || 0),
	                        end = 0;
	                    for (var j = i + 1; j < ii; j++) {
	                        if (dots[j].offset) {
	                            end = dots[j].offset;
	                            break;
	                        }
	                    }
	                    if (!end) {
	                        end = 100;
	                        j = ii;
	                    }
	                    end = toFloat(end);
	                    var d = (end - start) / (j - i + 1);
	                    for (; i < j; i++) {
	                        start += d;
	                        dots[i].offset = start + "%";
	                    }
	                }
	            }
	            return dots;
	        }),
	        getContainer = function (x, y, w, h) {
	            var container;
	            if (R.is(x, string) || R.is(x, "object")) {
	                container = R.is(x, string) ? doc.getElementById(x) : x;
	                if (container.tagName) {
	                    if (y == null) {
	                        return {
	                            container: container,
	                            width: container.style.pixelWidth || container.offsetWidth,
	                            height: container.style.pixelHeight || container.offsetHeight
	                        };
	                    } else {
	                        return {container: container, width: y, height: w};
	                    }
	                }
	            } else {
	                return {container: 1, x: x, y: y, width: w, height: h};
	            }
	        },
	        plugins = function (con, add) {
	            var that = this;
	            for (var prop in add) {
	                if (add[has](prop) && !(prop in con)) {
	                    switch (typeof add[prop]) {
	                        case "function":
	                            (function (f) {
	                                con[prop] = con === that ? f : function () { return f[apply](that, arguments); };
	                            })(add[prop]);
	                        break;
	                        case "object":
	                            con[prop] = con[prop] || {};
	                            plugins.call(this, con[prop], add[prop]);
	                        break;
	                        default:
	                            con[prop] = add[prop];
	                        break;
	                    }
	                }
	            }
	        },
	        tear = function (el, paper) {
	            el == paper.top && (paper.top = el.prev);
	            el == paper.bottom && (paper.bottom = el.next);
	            el.next && (el.next.prev = el.prev);
	            el.prev && (el.prev.next = el.next);
	        },
	        tofront = function (el, paper) {
	            if (paper.top === el) {
	                return;
	            }
	            tear(el, paper);
	            el.next = null;
	            el.prev = paper.top;
	            paper.top.next = el;
	            paper.top = el;
	        },
	        toback = function (el, paper) {
	            if (paper.bottom === el) {
	                return;
	            }
	            tear(el, paper);
	            el.next = paper.bottom;
	            el.prev = null;
	            paper.bottom.prev = el;
	            paper.bottom = el;
	        },
	        insertafter = function (el, el2, paper) {
	            tear(el, paper);
	            el2 == paper.top && (paper.top = el);
	            el2.next && (el2.next.prev = el);
	            el.next = el2.next;
	            el.prev = el2;
	            el2.next = el;
	        },
	        insertbefore = function (el, el2, paper) {
	            tear(el, paper);
	            el2 == paper.bottom && (paper.bottom = el);
	            el2.prev && (el2.prev.next = el);
	            el.prev = el2.prev;
	            el2.prev = el;
	            el.next = el2;
	        },
	        removed = function (methodname) {
	            return function () {
	                throw new Error("Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object");
	            };
	        };
	    R.pathToRelative = pathToRelative;
	    // SVG
	    if (R.svg) {
	        paperproto.svgns = "http://www.w3.org/2000/svg";
	        paperproto.xlink = "http://www.w3.org/1999/xlink";
	        round = function (num) {
	            return +num + (~~num === num) * .5;
	        };
	        var $ = function (el, attr) {
	            if (attr) {
	                for (var key in attr) {
	                    if (attr[has](key)) {
	                        setAttr(el, key, Str(attr[key]));
	                    }
	                }
	            } else {
	                el = doc.createElementNS(paperproto.svgns, el);
	                el.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
	                return el;
	            }
	        };
	        R[toString] = function () {
	            return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
	        };
	        var thePath = function (pathString, SVG) {
	            var el = $("path");
	            SVG.canvas && SVG.canvas[appendChild](el);
	            var p = new Element(el, SVG);
	            p.type = "path";
	            setFillAndStroke(p, {fill: "none", stroke: "#000", path: pathString});
	            return p;
	        };
	        var addGradientFill = function (o, gradient, SVG) {
	            var type = "linear",
	                fx = .5, fy = .5,
	                s = o.style;
	            gradient = Str(gradient)[rp](radial_gradient, function (all, _fx, _fy) {
	                type = "radial";
	                if (_fx && _fy) {
	                    fx = toFloat(_fx);
	                    fy = toFloat(_fy);
	                    var dir = ((fy > .5) * 2 - 1);
	                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
	                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
	                        fy != .5 &&
	                        (fy = fy.toFixed(5) - 1e-5 * dir);
	                }
	                return E;
	            });
	            gradient = gradient[split](/\s*\-\s*/);
	            if (type == "linear") {
	                var angle = gradient.shift();
	                angle = -toFloat(angle);
	                if (isNaN(angle)) {
	                    return null;
	                }
	                var vector = [0, 0, math.cos(angle * PI / 180), math.sin(angle * PI / 180)],
	                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
	                vector[2] *= max;
	                vector[3] *= max;
	                if (vector[2] < 0) {
	                    vector[0] = -vector[2];
	                    vector[2] = 0;
	                }
	                if (vector[3] < 0) {
	                    vector[1] = -vector[3];
	                    vector[3] = 0;
	                }
	            }
	            var dots = parseDots(gradient);
	            if (!dots) {
	                return null;
	            }
	            var id = o.getAttribute(fillString);
	            id = id.match(/^url\(#(.*)\)$/);
	            id && SVG.defs.removeChild(doc.getElementById(id[1]));

	            var el = $(type + "Gradient");
	            el.id = createUUID();
	            $(el, type == "radial" ? {fx: fx, fy: fy} : {x1: vector[0], y1: vector[1], x2: vector[2], y2: vector[3]});
	            SVG.defs[appendChild](el);
	            for (var i = 0, ii = dots[length]; i < ii; i++) {
	                var stop = $("stop");
	                $(stop, {
	                    offset: dots[i].offset ? dots[i].offset : !i ? "0%" : "100%",
	                    "stop-color": dots[i].color || "#fff"
	                });
	                el[appendChild](stop);
	            }
	            $(o, {
	                fill: "url(#" + el.id + ")",
	                opacity: 1,
	                "fill-opacity": 1
	            });
	            s.fill = E;
	            s.opacity = 1;
	            s.fillOpacity = 1;
	            return 1;
	        };
	        var updatePosition = function (o) {
	            var bbox = o.getBBox();
	            $(o.pattern, {patternTransform: R.format("translate({0},{1})", bbox.x, bbox.y)});
	        };
	        var setFillAndStroke = function (o, params) {
	            var dasharray = {
	                    "": [0],
	                    "none": [0],
	                    "-": [3, 1],
	                    ".": [1, 1],
	                    "-.": [3, 1, 1, 1],
	                    "-..": [3, 1, 1, 1, 1, 1],
	                    ". ": [1, 3],
	                    "- ": [4, 3],
	                    "--": [8, 3],
	                    "- .": [4, 3, 1, 3],
	                    "--.": [8, 3, 1, 3],
	                    "--..": [8, 3, 1, 3, 1, 3]
	                },
	                node = o.node,
	                attrs = o.attrs,
	                rot = o.rotate(),
	                addDashes = function (o, value) {
	                    value = dasharray[lowerCase.call(value)];
	                    if (value) {
	                        var width = o.attrs["stroke-width"] || "1",
	                            butt = {round: width, square: width, butt: 0}[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
	                            dashes = [];
	                        var i = value[length];
	                        while (i--) {
	                            dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
	                        }
	                        $(node, {"stroke-dasharray": dashes[join](",")});
	                    }
	                };
	            params[has]("rotation") && (rot = params.rotation);
	            var rotxy = Str(rot)[split](separator);
	            if (!(rotxy.length - 1)) {
	                rotxy = null;
	            } else {
	                rotxy[1] = +rotxy[1];
	                rotxy[2] = +rotxy[2];
	            }
	            toFloat(rot) && o.rotate(0, true);
	            for (var att in params) {
	                if (params[has](att)) {
	                    if (!availableAttrs[has](att)) {
	                        continue;
	                    }
	                    var value = params[att];
	                    attrs[att] = value;
	                    switch (att) {
	                        case "blur":
	                            o.blur(value);
	                            break;
	                        case "rotation":
	                            o.rotate(value, true);
	                            break;
	                        case "href":
	                        case "title":
	                        case "target":
	                            var pn = node.parentNode;
	                            if (lowerCase.call(pn.tagName) != "a") {
	                                var hl = $("a");
	                                pn.insertBefore(hl, node);
	                                hl[appendChild](node);
	                                pn = hl;
	                            }
	                            if (att == "target" && value == "blank") {
	                                pn.setAttributeNS(o.paper.xlink, "show", "new");
	                            } else {
	                                pn.setAttributeNS(o.paper.xlink, att, value);
	                            }
	                            break;
	                        case "cursor":
	                            node.style.cursor = value;
	                            break;
	                        case "clip-rect":
	                            var rect = Str(value)[split](separator);
	                            if (rect[length] == 4) {
	                                o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
	                                var el = $("clipPath"),
	                                    rc = $("rect");
	                                el.id = createUUID();
	                                $(rc, {
	                                    x: rect[0],
	                                    y: rect[1],
	                                    width: rect[2],
	                                    height: rect[3]
	                                });
	                                el[appendChild](rc);
	                                o.paper.defs[appendChild](el);
	                                $(node, {"clip-path": "url(#" + el.id + ")"});
	                                o.clip = rc;
	                            }
	                            if (!value) {
	                                var clip = doc.getElementById(node.getAttribute("clip-path")[rp](/(^url\(#|\)$)/g, E));
	                                clip && clip.parentNode.removeChild(clip);
	                                $(node, {"clip-path": E});
	                                delete o.clip;
	                            }
	                        break;
	                        case "path":
	                            if (o.type == "path") {
	                                $(node, {d: value ? attrs.path = pathToAbsolute(value) : "M0,0"});
	                            }
	                            break;
	                        case "width":
	                            setAttr(node, att, value);
	                            if (attrs.fx) {
	                                att = "x";
	                                value = attrs.x;
	                            } else {
	                                break;
	                            }
	                        case "x":
	                            if (attrs.fx) {
	                                value = -attrs.x - (attrs.width || 0);
	                            }
	                        case "rx":
	                            if (att == "rx" && o.type == "rect") {
	                                break;
	                            }
	                        case "cx":
	                            rotxy && (att == "x" || att == "cx") && (rotxy[1] += value - attrs[att]);
	                            setAttr(node, att, value);
	                            o.pattern && updatePosition(o);
	                            break;
	                        case "height":
	                            setAttr(node, att, value);
	                            if (attrs.fy) {
	                                att = "y";
	                                value = attrs.y;
	                            } else {
	                                break;
	                            }
	                        case "y":
	                            if (attrs.fy) {
	                                value = -attrs.y - (attrs.height || 0);
	                            }
	                        case "ry":
	                            if (att == "ry" && o.type == "rect") {
	                                break;
	                            }
	                        case "cy":
	                            rotxy && (att == "y" || att == "cy") && (rotxy[2] += value - attrs[att]);
	                            setAttr(node, att, value);
	                            o.pattern && updatePosition(o);
	                            break;
	                        case "r":
	                            if (o.type == "rect") {
	                                $(node, {rx: value, ry: value});
	                            } else {
	                                setAttr(node, att, value);
	                            }
	                            break;
	                        case "src":
	                            if (o.type == "image") {
	                                node.setAttributeNS(o.paper.xlink, "href", value);
	                            }
	                            break;
	                        case "stroke-width":
	                            node.style.strokeWidth = value;
	                            // Need following line for Firefox
	                            setAttr(node, att, value);
	                            if (attrs["stroke-dasharray"]) {
	                                addDashes(o, attrs["stroke-dasharray"]);
	                            }
	                            break;
	                        case "stroke-dasharray":
	                            addDashes(o, value);
	                            break;
	                        case "translation":
	                            var xy = Str(value)[split](separator);
	                            xy[0] = +xy[0] || 0;
	                            xy[1] = +xy[1] || 0;
	                            if (rotxy) {
	                                rotxy[1] += xy[0];
	                                rotxy[2] += xy[1];
	                            }
	                            translate.call(o, xy[0], xy[1]);
	                            break;
	                        case "scale":
	                            xy = Str(value)[split](separator);
	                            o.scale(+xy[0] || 1, +xy[1] || +xy[0] || 1, isNaN(toFloat(xy[2])) ? null : +xy[2], isNaN(toFloat(xy[3])) ? null : +xy[3]);
	                            break;
	                        case fillString:
	                            var isURL = Str(value).match(ISURL);
	                            if (isURL) {
	                                el = $("pattern");
	                                var ig = $("image");
	                                el.id = createUUID();
	                                $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
	                                $(ig, {x: 0, y: 0});
	                                ig.setAttributeNS(o.paper.xlink, "href", isURL[1]);
	                                el[appendChild](ig);

	                                var img = doc.createElement("img");
	                                img.style.cssText = "position:absolute;left:-9999em;top-9999em";
	                                img.onload = function () {
	                                    $(el, {width: this.offsetWidth, height: this.offsetHeight});
	                                    $(ig, {width: this.offsetWidth, height: this.offsetHeight});
	                                    doc.body.removeChild(this);
	                                    o.paper.safari();
	                                };
	                                doc.body[appendChild](img);
	                                img.src = isURL[1];
	                                o.paper.defs[appendChild](el);
	                                node.style.fill = "url(#" + el.id + ")";
	                                $(node, {fill: "url(#" + el.id + ")"});
	                                o.pattern = el;
	                                o.pattern && updatePosition(o);
	                                break;
	                            }
	                            var clr = R.getRGB(value);
	                            if (!clr.error) {
	                                delete params.gradient;
	                                delete attrs.gradient;
	                                !R.is(attrs.opacity, "undefined") &&
	                                    R.is(params.opacity, "undefined") &&
	                                    $(node, {opacity: attrs.opacity});
	                                !R.is(attrs["fill-opacity"], "undefined") &&
	                                    R.is(params["fill-opacity"], "undefined") &&
	                                    $(node, {"fill-opacity": attrs["fill-opacity"]});
	                            } else if ((({circle: 1, ellipse: 1})[has](o.type) || Str(value).charAt() != "r") && addGradientFill(node, value, o.paper)) {
	                                attrs.gradient = value;
	                                attrs.fill = "none";
	                                break;
	                            }
	                            clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
	                        case "stroke":
	                            clr = R.getRGB(value);
	                            setAttr(node, att, clr.hex);
	                            att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
	                            break;
	                        case "gradient":
	                            (({circle: 1, ellipse: 1})[has](o.type) || Str(value).charAt() != "r") && addGradientFill(node, value, o.paper);
	                            break;
	                        case "opacity":
	                            if (attrs.gradient && !attrs[has]("stroke-opacity")) {
	                                $(node, {"stroke-opacity": value > 1 ? value / 100 : value});
	                            }
	                            // fall
	                        case "fill-opacity":
	                            if (attrs.gradient) {
	                                var gradient = doc.getElementById(node.getAttribute(fillString)[rp](/^url\(#|\)$/g, E));
	                                if (gradient) {
	                                    var stops = gradient.getElementsByTagName("stop");
	                                    setAttr(stops[stops[length] - 1], "stop-opacity", value);
	                                }
	                                break;
	                            }
	                        default:
	                            att == "font-size" && (value = toInt(value, 10) + "px");
	                            var cssrule = att[rp](/(\-.)/g, function (w) {
	                                return upperCase.call(w.substring(1));
	                            });
	                            node.style[cssrule] = value;
	                            // Need following line for Firefox
	                            setAttr(node, att, value);
	                            break;
	                    }
	                }
	            }

	            tuneText(o, params);
	            if (rotxy) {
	                o.rotate(rotxy.join(S));
	            } else {
	                toFloat(rot) && o.rotate(rot, true);
	            }
	        };
	        var leading = 1.2,
	        tuneText = function (el, params) {
	            if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
	                return;
	            }
	            var a = el.attrs,
	                node = el.node,
	                fontSize = node.firstChild ? toInt(doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

	            if (params[has]("text")) {
	                a.text = params.text;
	                while (node.firstChild) {
	                    node.removeChild(node.firstChild);
	                }
	                var texts = Str(params.text)[split]("\n");
	                for (var i = 0, ii = texts[length]; i < ii; i++) if (texts[i]) {
	                    var tspan = $("tspan");
	                    i && $(tspan, {dy: fontSize * leading, x: a.x});
	                    tspan[appendChild](doc.createTextNode(texts[i]));
	                    node[appendChild](tspan);
	                }
	            } else {
	                texts = node.getElementsByTagName("tspan");
	                for (i = 0, ii = texts[length]; i < ii; i++) {
	                    i && $(texts[i], {dy: fontSize * leading, x: a.x});
	                }
	            }
	            $(node, {y: a.y});
	            var bb = el.getBBox(),
	                dif = a.y - (bb.y + bb.height / 2);
	            dif && R.is(dif, "finite") && $(node, {y: a.y + dif});
	        },
	        Element = function (node, svg) {
	            var X = 0,
	                Y = 0;
	            this[0] = node;
	            this.id = R._oid++;
	            this.node = node;
	            node.raphael = this;
	            this.paper = svg;
	            this.attrs = this.attrs || {};
	            this.transformations = []; // rotate, translate, scale
	            this._ = {
	                tx: 0,
	                ty: 0,
	                rt: {deg: 0, cx: 0, cy: 0},
	                sx: 1,
	                sy: 1
	            };
	            !svg.bottom && (svg.bottom = this);
	            this.prev = svg.top;
	            svg.top && (svg.top.next = this);
	            svg.top = this;
	            this.next = null;
	        };
	        var elproto = Element[proto];
	        Element[proto].rotate = function (deg, cx, cy) {
	            if (this.removed) {
	                return this;
	            }
	            if (deg == null) {
	                if (this._.rt.cx) {
	                    return [this._.rt.deg, this._.rt.cx, this._.rt.cy][join](S);
	                }
	                return this._.rt.deg;
	            }
	            var bbox = this.getBBox();
	            deg = Str(deg)[split](separator);
	            if (deg[length] - 1) {
	                cx = toFloat(deg[1]);
	                cy = toFloat(deg[2]);
	            }
	            deg = toFloat(deg[0]);
	            if (cx != null && cx !== false) {
	                this._.rt.deg = deg;
	            } else {
	                this._.rt.deg += deg;
	            }
	            (cy == null) && (cx = null);
	            this._.rt.cx = cx;
	            this._.rt.cy = cy;
	            cx = cx == null ? bbox.x + bbox.width / 2 : cx;
	            cy = cy == null ? bbox.y + bbox.height / 2 : cy;
	            if (this._.rt.deg) {
	                this.transformations[0] = R.format("rotate({0} {1} {2})", this._.rt.deg, cx, cy);
	                this.clip && $(this.clip, {transform: R.format("rotate({0} {1} {2})", -this._.rt.deg, cx, cy)});
	            } else {
	                this.transformations[0] = E;
	                this.clip && $(this.clip, {transform: E});
	            }
	            $(this.node, {transform: this.transformations[join](S)});
	            return this;
	        };
	        Element[proto].hide = function () {
	            !this.removed && (this.node.style.display = "none");
	            return this;
	        };
	        Element[proto].show = function () {
	            !this.removed && (this.node.style.display = "");
	            return this;
	        };
	        Element[proto].remove = function () {
	            if (this.removed) {
	                return;
	            }
	            tear(this, this.paper);
	            this.node.parentNode.removeChild(this.node);
	            for (var i in this) {
	                delete this[i];
	            }
	            this.removed = true;
	        };
	        Element[proto].getBBox = function () {
	            if (this.removed) {
	                return this;
	            }
	            if (this.type == "path") {
	                return pathDimensions(this.attrs.path);
	            }
	            if (this.node.style.display == "none") {
	                this.show();
	                var hide = true;
	            }
	            var bbox = {};
	            try {
	                bbox = this.node.getBBox();
	            } catch(e) {
	                // Firefox 3.0.x plays badly here
	            } finally {
	                bbox = bbox || {};
	            }
	            if (this.type == "text") {
	                bbox = {x: bbox.x, y: Infinity, width: 0, height: 0};
	                for (var i = 0, ii = this.node.getNumberOfChars(); i < ii; i++) {
	                    var bb = this.node.getExtentOfChar(i);
	                    (bb.y < bbox.y) && (bbox.y = bb.y);
	                    (bb.y + bb.height - bbox.y > bbox.height) && (bbox.height = bb.y + bb.height - bbox.y);
	                    (bb.x + bb.width - bbox.x > bbox.width) && (bbox.width = bb.x + bb.width - bbox.x);
	                }
	            }
	            hide && this.hide();
	            return bbox;
	        };
	        Element[proto].attr = function (name, value) {
	            if (this.removed) {
	                return this;
	            }
	            if (name == null) {
	                var res = {};
	                for (var i in this.attrs) if (this.attrs[has](i)) {
	                    res[i] = this.attrs[i];
	                }
	                this._.rt.deg && (res.rotation = this.rotate());
	                (this._.sx != 1 || this._.sy != 1) && (res.scale = this.scale());
	                res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
	                return res;
	            }
	            if (value == null && R.is(name, string)) {
	                if (name == "translation") {
	                    return translate.call(this);
	                }
	                if (name == "rotation") {
	                    return this.rotate();
	                }
	                if (name == "scale") {
	                    return this.scale();
	                }
	                if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
	                    return this.attrs.gradient;
	                }
	                return this.attrs[name];
	            }
	            if (value == null && R.is(name, array)) {
	                var values = {};
	                for (var j = 0, jj = name.length; j < jj; j++) {
	                    values[name[j]] = this.attr(name[j]);
	                }
	                return values;
	            }
	            if (value != null) {
	                var params = {};
	                params[name] = value;
	            } else if (name != null && R.is(name, "object")) {
	                params = name;
	            }
	            for (var key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
	                var par = this.paper.customAttributes[key].apply(this, [][concat](params[key]));
	                this.attrs[key] = params[key];
	                for (var subkey in par) if (par[has](subkey)) {
	                    params[subkey] = par[subkey];
	                }
	            }
	            setFillAndStroke(this, params);
	            return this;
	        };
	        Element[proto].toFront = function () {
	            if (this.removed) {
	                return this;
	            }
	            this.node.parentNode[appendChild](this.node);
	            var svg = this.paper;
	            svg.top != this && tofront(this, svg);
	            return this;
	        };
	        Element[proto].toBack = function () {
	            if (this.removed) {
	                return this;
	            }
	            if (this.node.parentNode.firstChild != this.node) {
	                this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
	                toback(this, this.paper);
	                var svg = this.paper;
	            }
	            return this;
	        };
	        Element[proto].insertAfter = function (element) {
	            if (this.removed) {
	                return this;
	            }
	            var node = element.node || element[element.length - 1].node;
	            if (node.nextSibling) {
	                node.parentNode.insertBefore(this.node, node.nextSibling);
	            } else {
	                node.parentNode[appendChild](this.node);
	            }
	            insertafter(this, element, this.paper);
	            return this;
	        };
	        Element[proto].insertBefore = function (element) {
	            if (this.removed) {
	                return this;
	            }
	            var node = element.node || element[0].node;
	            node.parentNode.insertBefore(this.node, node);
	            insertbefore(this, element, this.paper);
	            return this;
	        };
	        Element[proto].blur = function (size) {
	            // Experimental. No Safari support. Use it on your own risk.
	            var t = this;
	            if (+size !== 0) {
	                var fltr = $("filter"),
	                    blur = $("feGaussianBlur");
	                t.attrs.blur = size;
	                fltr.id = createUUID();
	                $(blur, {stdDeviation: +size || 1.5});
	                fltr.appendChild(blur);
	                t.paper.defs.appendChild(fltr);
	                t._blur = fltr;
	                $(t.node, {filter: "url(#" + fltr.id + ")"});
	            } else {
	                if (t._blur) {
	                    t._blur.parentNode.removeChild(t._blur);
	                    delete t._blur;
	                    delete t.attrs.blur;
	                }
	                t.node.removeAttribute("filter");
	            }
	        };
	        var theCircle = function (svg, x, y, r) {
	            var el = $("circle");
	            svg.canvas && svg.canvas[appendChild](el);
	            var res = new Element(el, svg);
	            res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
	            res.type = "circle";
	            $(el, res.attrs);
	            return res;
	        },
	        theRect = function (svg, x, y, w, h, r) {
	            var el = $("rect");
	            svg.canvas && svg.canvas[appendChild](el);
	            var res = new Element(el, svg);
	            res.attrs = {x: x, y: y, width: w, height: h, r: r || 0, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
	            res.type = "rect";
	            $(el, res.attrs);
	            return res;
	        },
	        theEllipse = function (svg, x, y, rx, ry) {
	            var el = $("ellipse");
	            svg.canvas && svg.canvas[appendChild](el);
	            var res = new Element(el, svg);
	            res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
	            res.type = "ellipse";
	            $(el, res.attrs);
	            return res;
	        },
	        theImage = function (svg, src, x, y, w, h) {
	            var el = $("image");
	            $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
	            el.setAttributeNS(svg.xlink, "href", src);
	            svg.canvas && svg.canvas[appendChild](el);
	            var res = new Element(el, svg);
	            res.attrs = {x: x, y: y, width: w, height: h, src: src};
	            res.type = "image";
	            return res;
	        },
	        theText = function (svg, x, y, text) {
	            var el = $("text");
	            $(el, {x: x, y: y, "text-anchor": "middle"});
	            svg.canvas && svg.canvas[appendChild](el);
	            var res = new Element(el, svg);
	            res.attrs = {x: x, y: y, "text-anchor": "middle", text: text, font: availableAttrs.font, stroke: "none", fill: "#000"};
	            res.type = "text";
	            setFillAndStroke(res, res.attrs);
	            return res;
	        },
	        setSize = function (width, height) {
	            this.width = width || this.width;
	            this.height = height || this.height;
	            setAttr(this.canvas, "width", this.width);
	            setAttr(this.canvas, "height", this.height);
	            return this;
	        },
	        create = function () {
	            var con = getContainer[apply](0, arguments),
	                container = con && con.container,
	                x = con.x,
	                y = con.y,
	                width = con.width,
	                height = con.height;
	            if (!container) {
	                throw new Error("SVG container not found.");
	            }
	            var cnvs = $("svg");
	            x = x || 0;
	            y = y || 0;
	            width = width || 512;
	            height = height || 342;
	            $(cnvs, {
	                xmlns: "http://www.w3.org/2000/svg",
	                version: 1.1,
	                width: width,
	                height: height
	            });
	            if (container == 1) {
	                cnvs.style.cssText = "position:absolute;left:" + x + "px;top:" + y + "px";
	                doc.body[appendChild](cnvs);
	            } else {
	                if (container.firstChild) {
	                    container.insertBefore(cnvs, container.firstChild);
	                } else {
	                    container[appendChild](cnvs);
	                }
	            }
	            container = new Paper;
	            container.width = width;
	            container.height = height;
	            container.canvas = cnvs;
	            plugins.call(container, container, R.fn);
	            container.clear();
	            return container;
	        };
	        paperproto.clear = function () {
	            var c = this.canvas;
	            while (c.firstChild) {
	                c.removeChild(c.firstChild);
	            }
	            this.bottom = this.top = null;
	            (this.desc = $("desc"))[appendChild](doc.createTextNode("Created with Rapha\xebl"));
	            c[appendChild](this.desc);
	            c[appendChild](this.defs = $("defs"));
	        };
	        paperproto.remove = function () {
	            this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
	            for (var i in this) {
	                this[i] = removed(i);
	            }
	        };
	    }

	    // VML
	    if (R.vml) {
	        var map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
	            bites = /([clmz]),?([^clmz]*)/gi,
	            blurregexp = / progid:\S+Blur\([^\)]+\)/g,
	            val = /-?[^,\s-]+/g,
	            coordsize = 1e3 + S + 1e3,
	            zoom = 10,
	            pathlike = {path: 1, rect: 1},
	            path2vml = function (path) {
	                var total =  /[ahqstv]/ig,
	                    command = pathToAbsolute;
	                Str(path).match(total) && (command = path2curve);
	                total = /[clmz]/g;
	                if (command == pathToAbsolute && !Str(path).match(total)) {
	                    var res = Str(path)[rp](bites, function (all, command, args) {
	                        var vals = [],
	                            isMove = lowerCase.call(command) == "m",
	                            res = map[command];
	                        args[rp](val, function (value) {
	                            if (isMove && vals[length] == 2) {
	                                res += vals + map[command == "m" ? "l" : "L"];
	                                vals = [];
	                            }
	                            vals[push](round(value * zoom));
	                        });
	                        return res + vals;
	                    });
	                    return res;
	                }
	                var pa = command(path), p, r;
	                res = [];
	                for (var i = 0, ii = pa[length]; i < ii; i++) {
	                    p = pa[i];
	                    r = lowerCase.call(pa[i][0]);
	                    r == "z" && (r = "x");
	                    for (var j = 1, jj = p[length]; j < jj; j++) {
	                        r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
	                    }
	                    res[push](r);
	                }
	                return res[join](S);
	            };

	        R[toString] = function () {
	            return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
	        };
	        thePath = function (pathString, vml) {
	            var g = createNode("group");
	            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
	            g.coordsize = vml.coordsize;
	            g.coordorigin = vml.coordorigin;
	            var el = createNode("shape"), ol = el.style;
	            ol.width = vml.width + "px";
	            ol.height = vml.height + "px";
	            el.coordsize = coordsize;
	            el.coordorigin = vml.coordorigin;
	            g[appendChild](el);
	            var p = new Element(el, g, vml),
	                attr = {fill: "none", stroke: "#000"};
	            pathString && (attr.path = pathString);
	            p.type = "path";
	            p.path = [];
	            p.Path = E;
	            setFillAndStroke(p, attr);
	            vml.canvas[appendChild](g);
	            return p;
	        };
	        setFillAndStroke = function (o, params) {
	            o.attrs = o.attrs || {};
	            var node = o.node,
	                a = o.attrs,
	                s = node.style,
	                xy,
	                newpath = (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.r != a.r) && o.type == "rect",
	                res = o;

	            for (var par in params) if (params[has](par)) {
	                a[par] = params[par];
	            }
	            if (newpath) {
	                a.path = rectPath(a.x, a.y, a.width, a.height, a.r);
	                o.X = a.x;
	                o.Y = a.y;
	                o.W = a.width;
	                o.H = a.height;
	            }
	            params.href && (node.href = params.href);
	            params.title && (node.title = params.title);
	            params.target && (node.target = params.target);
	            params.cursor && (s.cursor = params.cursor);
	            "blur" in params && o.blur(params.blur);
	            if (params.path && o.type == "path" || newpath) {
	                node.path = path2vml(a.path);
	            }
	            if (params.rotation != null) {
	                o.rotate(params.rotation, true);
	            }
	            if (params.translation) {
	                xy = Str(params.translation)[split](separator);
	                translate.call(o, xy[0], xy[1]);
	                if (o._.rt.cx != null) {
	                    o._.rt.cx +=+ xy[0];
	                    o._.rt.cy +=+ xy[1];
	                    o.setBox(o.attrs, xy[0], xy[1]);
	                }
	            }
	            if (params.scale) {
	                xy = Str(params.scale)[split](separator);
	                o.scale(+xy[0] || 1, +xy[1] || +xy[0] || 1, +xy[2] || null, +xy[3] || null);
	            }
	            if ("clip-rect" in params) {
	                var rect = Str(params["clip-rect"])[split](separator);
	                if (rect[length] == 4) {
	                    rect[2] = +rect[2] + (+rect[0]);
	                    rect[3] = +rect[3] + (+rect[1]);
	                    var div = node.clipRect || doc.createElement("div"),
	                        dstyle = div.style,
	                        group = node.parentNode;
	                    dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
	                    if (!node.clipRect) {
	                        dstyle.position = "absolute";
	                        dstyle.top = 0;
	                        dstyle.left = 0;
	                        dstyle.width = o.paper.width + "px";
	                        dstyle.height = o.paper.height + "px";
	                        group.parentNode.insertBefore(div, group);
	                        div[appendChild](group);
	                        node.clipRect = div;
	                    }
	                }
	                if (!params["clip-rect"]) {
	                    node.clipRect && (node.clipRect.style.clip = E);
	                }
	            }
	            if (o.type == "image" && params.src) {
	                node.src = params.src;
	            }
	            if (o.type == "image" && params.opacity) {
	                node.filterOpacity = ms + ".Alpha(opacity=" + (params.opacity * 100) + ")";
	                s.filter = (node.filterMatrix || E) + (node.filterOpacity || E);
	            }
	            params.font && (s.font = params.font);
	            params["font-family"] && (s.fontFamily = '"' + params["font-family"][split](",")[0][rp](/^['"]+|['"]+$/g, E) + '"');
	            params["font-size"] && (s.fontSize = params["font-size"]);
	            params["font-weight"] && (s.fontWeight = params["font-weight"]);
	            params["font-style"] && (s.fontStyle = params["font-style"]);
	            if (params.opacity != null ||
	                params["stroke-width"] != null ||
	                params.fill != null ||
	                params.stroke != null ||
	                params["stroke-width"] != null ||
	                params["stroke-opacity"] != null ||
	                params["fill-opacity"] != null ||
	                params["stroke-dasharray"] != null ||
	                params["stroke-miterlimit"] != null ||
	                params["stroke-linejoin"] != null ||
	                params["stroke-linecap"] != null) {
	                node = o.shape || node;
	                var fill = (node.getElementsByTagName(fillString) && node.getElementsByTagName(fillString)[0]),
	                    newfill = false;
	                !fill && (newfill = fill = createNode(fillString));
	                if ("fill-opacity" in params || "opacity" in params) {
	                    var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
	                    opacity = mmin(mmax(opacity, 0), 1);
	                    fill.opacity = opacity;
	                }
	                params.fill && (fill.on = true);
	                if (fill.on == null || params.fill == "none") {
	                    fill.on = false;
	                }
	                if (fill.on && params.fill) {
	                    var isURL = params.fill.match(ISURL);
	                    if (isURL) {
	                        fill.src = isURL[1];
	                        fill.type = "tile";
	                    } else {
	                        fill.color = R.getRGB(params.fill).hex;
	                        fill.src = E;
	                        fill.type = "solid";
	                        if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill)) {
	                            a.fill = "none";
	                            a.gradient = params.fill;
	                        }
	                    }
	                }
	                newfill && node[appendChild](fill);
	                var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
	                newstroke = false;
	                !stroke && (newstroke = stroke = createNode("stroke"));
	                if ((params.stroke && params.stroke != "none") ||
	                    params["stroke-width"] ||
	                    params["stroke-opacity"] != null ||
	                    params["stroke-dasharray"] ||
	                    params["stroke-miterlimit"] ||
	                    params["stroke-linejoin"] ||
	                    params["stroke-linecap"]) {
	                    stroke.on = true;
	                }
	                (params.stroke == "none" || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
	                var strokeColor = R.getRGB(params.stroke);
	                stroke.on && params.stroke && (stroke.color = strokeColor.hex);
	                opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
	                var width = (toFloat(params["stroke-width"]) || 1) * .75;
	                opacity = mmin(mmax(opacity, 0), 1);
	                params["stroke-width"] == null && (width = a["stroke-width"]);
	                params["stroke-width"] && (stroke.weight = width);
	                width && width < 1 && (opacity *= width) && (stroke.weight = 1);
	                stroke.opacity = opacity;

	                params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
	                stroke.miterlimit = params["stroke-miterlimit"] || 8;
	                params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
	                if (params["stroke-dasharray"]) {
	                    var dasharray = {
	                        "-": "shortdash",
	                        ".": "shortdot",
	                        "-.": "shortdashdot",
	                        "-..": "shortdashdotdot",
	                        ". ": "dot",
	                        "- ": "dash",
	                        "--": "longdash",
	                        "- .": "dashdot",
	                        "--.": "longdashdot",
	                        "--..": "longdashdotdot"
	                    };
	                    stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
	                }
	                newstroke && node[appendChild](stroke);
	            }
	            if (res.type == "text") {
	                s = res.paper.span.style;
	                a.font && (s.font = a.font);
	                a["font-family"] && (s.fontFamily = a["font-family"]);
	                a["font-size"] && (s.fontSize = a["font-size"]);
	                a["font-weight"] && (s.fontWeight = a["font-weight"]);
	                a["font-style"] && (s.fontStyle = a["font-style"]);
	                res.node.string && (res.paper.span.innerHTML = Str(res.node.string)[rp](/</g, "&#60;")[rp](/&/g, "&#38;")[rp](/\n/g, "<br>"));
	                res.W = a.w = res.paper.span.offsetWidth;
	                res.H = a.h = res.paper.span.offsetHeight;
	                res.X = a.x;
	                res.Y = a.y + round(res.H / 2);

	                // text-anchor emulationm
	                switch (a["text-anchor"]) {
	                    case "start":
	                        res.node.style["v-text-align"] = "left";
	                        res.bbx = round(res.W / 2);
	                    break;
	                    case "end":
	                        res.node.style["v-text-align"] = "right";
	                        res.bbx = -round(res.W / 2);
	                    break;
	                    default:
	                        res.node.style["v-text-align"] = "center";
	                    break;
	                }
	            }
	        };
	        addGradientFill = function (o, gradient) {
	            o.attrs = o.attrs || {};
	            var attrs = o.attrs,
	                fill,
	                type = "linear",
	                fxfy = ".5 .5";
	            o.attrs.gradient = gradient;
	            gradient = Str(gradient)[rp](radial_gradient, function (all, fx, fy) {
	                type = "radial";
	                if (fx && fy) {
	                    fx = toFloat(fx);
	                    fy = toFloat(fy);
	                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
	                    fxfy = fx + S + fy;
	                }
	                return E;
	            });
	            gradient = gradient[split](/\s*\-\s*/);
	            if (type == "linear") {
	                var angle = gradient.shift();
	                angle = -toFloat(angle);
	                if (isNaN(angle)) {
	                    return null;
	                }
	            }
	            var dots = parseDots(gradient);
	            if (!dots) {
	                return null;
	            }
	            o = o.shape || o.node;
	            fill = o.getElementsByTagName(fillString)[0] || createNode(fillString);
	            !fill.parentNode && o.appendChild(fill);
	            if (dots[length]) {
	                fill.on = true;
	                fill.method = "none";
	                fill.color = dots[0].color;
	                fill.color2 = dots[dots[length] - 1].color;
	                var clrs = [];
	                for (var i = 0, ii = dots[length]; i < ii; i++) {
	                    dots[i].offset && clrs[push](dots[i].offset + S + dots[i].color);
	                }
	                fill.colors && (fill.colors.value = clrs[length] ? clrs[join]() : "0% " + fill.color);
	                if (type == "radial") {
	                    fill.type = "gradientradial";
	                    fill.focus = "100%";
	                    fill.focussize = fxfy;
	                    fill.focusposition = fxfy;
	                } else {
	                    fill.type = "gradient";
	                    fill.angle = (270 - angle) % 360;
	                }
	            }
	            return 1;
	        };
	        Element = function (node, group, vml) {
	            var Rotation = 0,
	                RotX = 0,
	                RotY = 0,
	                Scale = 1;
	            this[0] = node;
	            this.id = R._oid++;
	            this.node = node;
	            node.raphael = this;
	            this.X = 0;
	            this.Y = 0;
	            this.attrs = {};
	            this.Group = group;
	            this.paper = vml;
	            this._ = {
	                tx: 0,
	                ty: 0,
	                rt: {deg:0},
	                sx: 1,
	                sy: 1
	            };
	            !vml.bottom && (vml.bottom = this);
	            this.prev = vml.top;
	            vml.top && (vml.top.next = this);
	            vml.top = this;
	            this.next = null;
	        };
	        elproto = Element[proto];
	        elproto.rotate = function (deg, cx, cy) {
	            if (this.removed) {
	                return this;
	            }
	            if (deg == null) {
	                if (this._.rt.cx) {
	                    return [this._.rt.deg, this._.rt.cx, this._.rt.cy][join](S);
	                }
	                return this._.rt.deg;
	            }
	            deg = Str(deg)[split](separator);
	            if (deg[length] - 1) {
	                cx = toFloat(deg[1]);
	                cy = toFloat(deg[2]);
	            }
	            deg = toFloat(deg[0]);
	            if (cx != null) {
	                this._.rt.deg = deg;
	            } else {
	                this._.rt.deg += deg;
	            }
	            cy == null && (cx = null);
	            this._.rt.cx = cx;
	            this._.rt.cy = cy;
	            this.setBox(this.attrs, cx, cy);
	            this.Group.style.rotation = this._.rt.deg;
	            // gradient fix for rotation. TODO
	            // var fill = (this.shape || this.node).getElementsByTagName(fillString);
	            // fill = fill[0] || {};
	            // var b = ((360 - this._.rt.deg) - 270) % 360;
	            // !R.is(fill.angle, "undefined") && (fill.angle = b);
	            return this;
	        };
	        elproto.setBox = function (params, cx, cy) {
	            if (this.removed) {
	                return this;
	            }
	            var gs = this.Group.style,
	                os = (this.shape && this.shape.style) || this.node.style;
	            params = params || {};
	            for (var i in params) if (params[has](i)) {
	                this.attrs[i] = params[i];
	            }
	            cx = cx || this._.rt.cx;
	            cy = cy || this._.rt.cy;
	            var attr = this.attrs,
	                x,
	                y,
	                w,
	                h;
	            switch (this.type) {
	                case "circle":
	                    x = attr.cx - attr.r;
	                    y = attr.cy - attr.r;
	                    w = h = attr.r * 2;
	                    break;
	                case "ellipse":
	                    x = attr.cx - attr.rx;
	                    y = attr.cy - attr.ry;
	                    w = attr.rx * 2;
	                    h = attr.ry * 2;
	                    break;
	                case "image":
	                    x = +attr.x;
	                    y = +attr.y;
	                    w = attr.width || 0;
	                    h = attr.height || 0;
	                    break;
	                case "text":
	                    this.textpath.v = ["m", round(attr.x), ", ", round(attr.y - 2), "l", round(attr.x) + 1, ", ", round(attr.y - 2)][join](E);
	                    x = attr.x - round(this.W / 2);
	                    y = attr.y - this.H / 2;
	                    w = this.W;
	                    h = this.H;
	                    break;
	                case "rect":
	                case "path":
	                    if (!this.attrs.path) {
	                        x = 0;
	                        y = 0;
	                        w = this.paper.width;
	                        h = this.paper.height;
	                    } else {
	                        var dim = pathDimensions(this.attrs.path);
	                        x = dim.x;
	                        y = dim.y;
	                        w = dim.width;
	                        h = dim.height;
	                    }
	                    break;
	                default:
	                    x = 0;
	                    y = 0;
	                    w = this.paper.width;
	                    h = this.paper.height;
	                    break;
	            }
	            cx = (cx == null) ? x + w / 2 : cx;
	            cy = (cy == null) ? y + h / 2 : cy;
	            var left = cx - this.paper.width / 2,
	                top = cy - this.paper.height / 2, t;
	            gs.left != (t = left + "px") && (gs.left = t);
	            gs.top != (t = top + "px") && (gs.top = t);
	            this.X = pathlike[has](this.type) ? -left : x;
	            this.Y = pathlike[has](this.type) ? -top : y;
	            this.W = w;
	            this.H = h;
	            if (pathlike[has](this.type)) {
	                os.left != (t = -left * zoom + "px") && (os.left = t);
	                os.top != (t = -top * zoom + "px") && (os.top = t);
	            } else if (this.type == "text") {
	                os.left != (t = -left + "px") && (os.left = t);
	                os.top != (t = -top + "px") && (os.top = t);
	            } else {
	                gs.width != (t = this.paper.width + "px") && (gs.width = t);
	                gs.height != (t = this.paper.height + "px") && (gs.height = t);
	                os.left != (t = x - left + "px") && (os.left = t);
	                os.top != (t = y - top + "px") && (os.top = t);
	                os.width != (t = w + "px") && (os.width = t);
	                os.height != (t = h + "px") && (os.height = t);
	            }
	        };
	        elproto.hide = function () {
	            !this.removed && (this.Group.style.display = "none");
	            return this;
	        };
	        elproto.show = function () {
	            !this.removed && (this.Group.style.display = "block");
	            return this;
	        };
	        elproto.getBBox = function () {
	            if (this.removed) {
	                return this;
	            }
	            if (pathlike[has](this.type)) {
	                return pathDimensions(this.attrs.path);
	            }
	            return {
	                x: this.X + (this.bbx || 0),
	                y: this.Y,
	                width: this.W,
	                height: this.H
	            };
	        };
	        elproto.remove = function () {
	            if (this.removed) {
	                return;
	            }
	            tear(this, this.paper);
	            this.node.parentNode.removeChild(this.node);
	            this.Group.parentNode.removeChild(this.Group);
	            this.shape && this.shape.parentNode.removeChild(this.shape);
	            for (var i in this) {
	                delete this[i];
	            }
	            this.removed = true;
	        };
	        elproto.attr = function (name, value) {
	            if (this.removed) {
	                return this;
	            }
	            if (name == null) {
	                var res = {};
	                for (var i in this.attrs) if (this.attrs[has](i)) {
	                    res[i] = this.attrs[i];
	                }
	                this._.rt.deg && (res.rotation = this.rotate());
	                (this._.sx != 1 || this._.sy != 1) && (res.scale = this.scale());
	                res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
	                return res;
	            }
	            if (value == null && R.is(name, "string")) {
	                if (name == "translation") {
	                    return translate.call(this);
	                }
	                if (name == "rotation") {
	                    return this.rotate();
	                }
	                if (name == "scale") {
	                    return this.scale();
	                }
	                if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
	                    return this.attrs.gradient;
	                }
	                return this.attrs[name];
	            }
	            if (this.attrs && value == null && R.is(name, array)) {
	                var ii, values = {};
	                for (i = 0, ii = name[length]; i < ii; i++) {
	                    values[name[i]] = this.attr(name[i]);
	                }
	                return values;
	            }
	            var params;
	            if (value != null) {
	                params = {};
	                params[name] = value;
	            }
	            value == null && R.is(name, "object") && (params = name);
	            if (params) {
	                for (var key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
	                    var par = this.paper.customAttributes[key].apply(this, [][concat](params[key]));
	                    this.attrs[key] = params[key];
	                    for (var subkey in par) if (par[has](subkey)) {
	                        params[subkey] = par[subkey];
	                    }
	                }
	                if (params.text && this.type == "text") {
	                    this.node.string = params.text;
	                }
	                setFillAndStroke(this, params);
	                if (params.gradient && (({circle: 1, ellipse: 1})[has](this.type) || Str(params.gradient).charAt() != "r")) {
	                    addGradientFill(this, params.gradient);
	                }
	                (!pathlike[has](this.type) || this._.rt.deg) && this.setBox(this.attrs);
	            }
	            return this;
	        };
	        elproto.toFront = function () {
	            !this.removed && this.Group.parentNode[appendChild](this.Group);
	            this.paper.top != this && tofront(this, this.paper);
	            return this;
	        };
	        elproto.toBack = function () {
	            if (this.removed) {
	                return this;
	            }
	            if (this.Group.parentNode.firstChild != this.Group) {
	                this.Group.parentNode.insertBefore(this.Group, this.Group.parentNode.firstChild);
	                toback(this, this.paper);
	            }
	            return this;
	        };
	        elproto.insertAfter = function (element) {
	            if (this.removed) {
	                return this;
	            }
	            if (element.constructor == Set) {
	                element = element[element.length - 1];
	            }
	            if (element.Group.nextSibling) {
	                element.Group.parentNode.insertBefore(this.Group, element.Group.nextSibling);
	            } else {
	                element.Group.parentNode[appendChild](this.Group);
	            }
	            insertafter(this, element, this.paper);
	            return this;
	        };
	        elproto.insertBefore = function (element) {
	            if (this.removed) {
	                return this;
	            }
	            if (element.constructor == Set) {
	                element = element[0];
	            }
	            element.Group.parentNode.insertBefore(this.Group, element.Group);
	            insertbefore(this, element, this.paper);
	            return this;
	        };
	        elproto.blur = function (size) {
	            var s = this.node.runtimeStyle,
	                f = s.filter;
	            f = f.replace(blurregexp, E);
	            if (+size !== 0) {
	                this.attrs.blur = size;
	                s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
	                s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
	            } else {
	                s.filter = f;
	                s.margin = 0;
	                delete this.attrs.blur;
	            }
	        };

	        theCircle = function (vml, x, y, r) {
	            var g = createNode("group"),
	                o = createNode("oval"),
	                ol = o.style;
	            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
	            g.coordsize = coordsize;
	            g.coordorigin = vml.coordorigin;
	            g[appendChild](o);
	            var res = new Element(o, g, vml);
	            res.type = "circle";
	            setFillAndStroke(res, {stroke: "#000", fill: "none"});
	            res.attrs.cx = x;
	            res.attrs.cy = y;
	            res.attrs.r = r;
	            res.setBox({x: x - r, y: y - r, width: r * 2, height: r * 2});
	            vml.canvas[appendChild](g);
	            return res;
	        };
	        function rectPath(x, y, w, h, r) {
	            if (r) {
	                return R.format("M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z", x + r, y, w - r * 2, r, -r, h - r * 2, r * 2 - w, r * 2 - h);
	            } else {
	                return R.format("M{0},{1}l{2},0,0,{3},{4},0z", x, y, w, h, -w);
	            }
	        }
	        theRect = function (vml, x, y, w, h, r) {
	            var path = rectPath(x, y, w, h, r),
	                res = vml.path(path),
	                a = res.attrs;
	            res.X = a.x = x;
	            res.Y = a.y = y;
	            res.W = a.width = w;
	            res.H = a.height = h;
	            a.r = r;
	            a.path = path;
	            res.type = "rect";
	            return res;
	        };
	        theEllipse = function (vml, x, y, rx, ry) {
	            var g = createNode("group"),
	                o = createNode("oval"),
	                ol = o.style;
	            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
	            g.coordsize = coordsize;
	            g.coordorigin = vml.coordorigin;
	            g[appendChild](o);
	            var res = new Element(o, g, vml);
	            res.type = "ellipse";
	            setFillAndStroke(res, {stroke: "#000"});
	            res.attrs.cx = x;
	            res.attrs.cy = y;
	            res.attrs.rx = rx;
	            res.attrs.ry = ry;
	            res.setBox({x: x - rx, y: y - ry, width: rx * 2, height: ry * 2});
	            vml.canvas[appendChild](g);
	            return res;
	        };
	        theImage = function (vml, src, x, y, w, h) {
	            var g = createNode("group"),
	                o = createNode("image");
	            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
	            g.coordsize = coordsize;
	            g.coordorigin = vml.coordorigin;
	            o.src = src;
	            g[appendChild](o);
	            var res = new Element(o, g, vml);
	            res.type = "image";
	            res.attrs.src = src;
	            res.attrs.x = x;
	            res.attrs.y = y;
	            res.attrs.w = w;
	            res.attrs.h = h;
	            res.setBox({x: x, y: y, width: w, height: h});
	            vml.canvas[appendChild](g);
	            return res;
	        };
	        theText = function (vml, x, y, text) {
	            var g = createNode("group"),
	                el = createNode("shape"),
	                ol = el.style,
	                path = createNode("path"),
	                ps = path.style,
	                o = createNode("textpath");
	            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
	            g.coordsize = coordsize;
	            g.coordorigin = vml.coordorigin;
	            path.v = R.format("m{0},{1}l{2},{1}", round(x * 10), round(y * 10), round(x * 10) + 1);
	            path.textpathok = true;
	            ol.width = vml.width;
	            ol.height = vml.height;
	            o.string = Str(text);
	            o.on = true;
	            el[appendChild](o);
	            el[appendChild](path);
	            g[appendChild](el);
	            var res = new Element(o, g, vml);
	            res.shape = el;
	            res.textpath = path;
	            res.type = "text";
	            res.attrs.text = text;
	            res.attrs.x = x;
	            res.attrs.y = y;
	            res.attrs.w = 1;
	            res.attrs.h = 1;
	            setFillAndStroke(res, {font: availableAttrs.font, stroke: "none", fill: "#000"});
	            res.setBox();
	            vml.canvas[appendChild](g);
	            return res;
	        };
	        setSize = function (width, height) {
	            var cs = this.canvas.style;
	            width == +width && (width += "px");
	            height == +height && (height += "px");
	            cs.width = width;
	            cs.height = height;
	            cs.clip = "rect(0 " + width + " " + height + " 0)";
	            return this;
	        };
	        var createNode;
	        doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
	        try {
	            !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
	            createNode = function (tagName) {
	                return doc.createElement('<rvml:' + tagName + ' class="rvml">');
	            };
	        } catch (e) {
	            createNode = function (tagName) {
	                return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
	            };
	        }
	        create = function () {
	            var con = getContainer[apply](0, arguments),
	                container = con.container,
	                height = con.height,
	                s,
	                width = con.width,
	                x = con.x,
	                y = con.y;
	            if (!container) {
	                throw new Error("VML container not found.");
	            }
	            var res = new Paper,
	                c = res.canvas = doc.createElement("div"),
	                cs = c.style;
	            x = x || 0;
	            y = y || 0;
	            width = width || 512;
	            height = height || 342;
	            width == +width && (width += "px");
	            height == +height && (height += "px");
	            res.width = 1e3;
	            res.height = 1e3;
	            res.coordsize = zoom * 1e3 + S + zoom * 1e3;
	            res.coordorigin = "0 0";
	            res.span = doc.createElement("span");
	            res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
	            c[appendChild](res.span);
	            cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
	            if (container == 1) {
	                doc.body[appendChild](c);
	                cs.left = x + "px";
	                cs.top = y + "px";
	                cs.position = "absolute";
	            } else {
	                if (container.firstChild) {
	                    container.insertBefore(c, container.firstChild);
	                } else {
	                    container[appendChild](c);
	                }
	            }
	            plugins.call(res, res, R.fn);
	            return res;
	        };
	        paperproto.clear = function () {
	            this.canvas.innerHTML = E;
	            this.span = doc.createElement("span");
	            this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
	            this.canvas[appendChild](this.span);
	            this.bottom = this.top = null;
	        };
	        paperproto.remove = function () {
	            this.canvas.parentNode.removeChild(this.canvas);
	            for (var i in this) {
	                this[i] = removed(i);
	            }
	            return true;
	        };
	    }

	    // rest
	    // WebKit rendering bug workaround method
	    var version = navigator.userAgent.match(/Version\/(.*?)\s/);
	    if ((navigator.vendor == "Apple Computer, Inc.") && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP")) {
	        paperproto.safari = function () {
	            var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({stroke: "none"});
	            win.setTimeout(function () {rect.remove();});
	        };
	    } else {
	        paperproto.safari = function () {};
	    }

	    // Events
	    var preventDefault = function () {
	        this.returnValue = false;
	    },
	    preventTouch = function () {
	        return this.originalEvent.preventDefault();
	    },
	    stopPropagation = function () {
	        this.cancelBubble = true;
	    },
	    stopTouch = function () {
	        return this.originalEvent.stopPropagation();
	    },
	    addEvent = (function () {
	        if (doc.addEventListener) {
	            return function (obj, type, fn, element) {
	                var realName = supportsTouch && touchMap[type] ? touchMap[type] : type;
	                var f = function (e) {
	                    if (supportsTouch && touchMap[has](type)) {
	                        for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
	                            if (e.targetTouches[i].target == obj) {
	                                var olde = e;
	                                e = e.targetTouches[i];
	                                e.originalEvent = olde;
	                                e.preventDefault = preventTouch;
	                                e.stopPropagation = stopTouch;
	                                break;
	                            }
	                        }
	                    }
	                    return fn.call(element, e);
	                };
	                obj.addEventListener(realName, f, false);
	                return function () {
	                    obj.removeEventListener(realName, f, false);
	                    return true;
	                };
	            };
	        } else if (doc.attachEvent) {
	            return function (obj, type, fn, element) {
	                var f = function (e) {
	                    e = e || win.event;
	                    e.preventDefault = e.preventDefault || preventDefault;
	                    e.stopPropagation = e.stopPropagation || stopPropagation;
	                    return fn.call(element, e);
	                };
	                obj.attachEvent("on" + type, f);
	                var detacher = function () {
	                    obj.detachEvent("on" + type, f);
	                    return true;
	                };
	                return detacher;
	            };
	        }
	    })(),
	    drag = [],
	    dragMove = function (e) {
	        var x = e.clientX,
	            y = e.clientY,
	            scrollY = doc.documentElement.scrollTop || doc.body.scrollTop,
	            scrollX = doc.documentElement.scrollLeft || doc.body.scrollLeft,
	            dragi,
	            j = drag.length;
	        while (j--) {
	            dragi = drag[j];
	            if (supportsTouch) {
	                var i = e.touches.length,
	                    touch;
	                while (i--) {
	                    touch = e.touches[i];
	                    if (touch.identifier == dragi.el._drag.id) {
	                        x = touch.clientX;
	                        y = touch.clientY;
	                        (e.originalEvent ? e.originalEvent : e).preventDefault();
	                        break;
	                    }
	                }
	            } else {
	                e.preventDefault();
	            }
	            x += scrollX;
	            y += scrollY;
	            dragi.move && dragi.move.call(dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
	        }
	    },
	    dragUp = function (e) {
	        R.unmousemove(dragMove).unmouseup(dragUp);
	        var i = drag.length,
	            dragi;
	        while (i--) {
	            dragi = drag[i];
	            dragi.el._drag = {};
	            dragi.end && dragi.end.call(dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
	        }
	        drag = [];
	    };
	    for (var i = events[length]; i--;) {
	        (function (eventName) {
	            R[eventName] = Element[proto][eventName] = function (fn, scope) {
	                if (R.is(fn, "function")) {
	                    this.events = this.events || [];
	                    this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || doc, eventName, fn, scope || this)});
	                }
	                return this;
	            };
	            R["un" + eventName] = Element[proto]["un" + eventName] = function (fn) {
	                var events = this.events,
	                    l = events[length];
	                while (l--) if (events[l].name == eventName && events[l].f == fn) {
	                    events[l].unbind();
	                    events.splice(l, 1);
	                    !events.length && delete this.events;
	                    return this;
	                }
	                return this;
	            };
	        })(events[i]);
	    }
	    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
	        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
	    };
	    elproto.unhover = function (f_in, f_out) {
	        return this.unmouseover(f_in).unmouseout(f_out);
	    };
	    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
	        this._drag = {};
	        this.mousedown(function (e) {
	            (e.originalEvent || e).preventDefault();
	            var scrollY = doc.documentElement.scrollTop || doc.body.scrollTop,
	                scrollX = doc.documentElement.scrollLeft || doc.body.scrollLeft;
	            this._drag.x = e.clientX + scrollX;
	            this._drag.y = e.clientY + scrollY;
	            this._drag.id = e.identifier;
	            onstart && onstart.call(start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
	            !drag.length && R.mousemove(dragMove).mouseup(dragUp);
	            drag.push({el: this, move: onmove, end: onend, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
	        });
	        return this;
	    };
	    elproto.undrag = function (onmove, onstart, onend) {
	        var i = drag.length;
	        while (i--) {
	            drag[i].el == this && (drag[i].move == onmove && drag[i].end == onend) && drag.splice(i++, 1);
	        }
	        !drag.length && R.unmousemove(dragMove).unmouseup(dragUp);
	    };
	    paperproto.circle = function (x, y, r) {
	        return theCircle(this, x || 0, y || 0, r || 0);
	    };
	    paperproto.rect = function (x, y, w, h, r) {
	        return theRect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
	    };
	    paperproto.ellipse = function (x, y, rx, ry) {
	        return theEllipse(this, x || 0, y || 0, rx || 0, ry || 0);
	    };
	    paperproto.path = function (pathString) {
	        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
	        return thePath(R.format[apply](R, arguments), this);
	    };
	    paperproto.image = function (src, x, y, w, h) {
	        return theImage(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
	    };
	    paperproto.text = function (x, y, text) {
	        return theText(this, x || 0, y || 0, Str(text));
	    };
	    paperproto.set = function (itemsArray) {
	        arguments[length] > 1 && (itemsArray = Array[proto].splice.call(arguments, 0, arguments[length]));
	        return new Set(itemsArray);
	    };
	    paperproto.setSize = setSize;
	    paperproto.top = paperproto.bottom = null;
	    paperproto.raphael = R;
	    function x_y() {
	        return this.x + S + this.y;
	    }
	    elproto.resetScale = function () {
	        if (this.removed) {
	            return this;
	        }
	        this._.sx = 1;
	        this._.sy = 1;
	        this.attrs.scale = "1 1";
	    };
	    elproto.scale = function (x, y, cx, cy) {
	        if (this.removed) {
	            return this;
	        }
	        if (x == null && y == null) {
	            return {
	                x: this._.sx,
	                y: this._.sy,
	                toString: x_y
	            };
	        }
	        y = y || x;
	        !+y && (y = x);
	        var dx,
	            dy,
	            dcx,
	            dcy,
	            a = this.attrs;
	        if (x != 0) {
	            var bb = this.getBBox(),
	                rcx = bb.x + bb.width / 2,
	                rcy = bb.y + bb.height / 2,
	                kx = abs(x / this._.sx),
	                ky = abs(y / this._.sy);
	            cx = (+cx || cx == 0) ? cx : rcx;
	            cy = (+cy || cy == 0) ? cy : rcy;
	            var posx = this._.sx > 0,
	                posy = this._.sy > 0,
	                dirx = ~~(x / abs(x)),
	                diry = ~~(y / abs(y)),
	                dkx = kx * dirx,
	                dky = ky * diry,
	                s = this.node.style,
	                ncx = cx + abs(rcx - cx) * dkx * (rcx > cx == posx ? 1 : -1),
	                ncy = cy + abs(rcy - cy) * dky * (rcy > cy == posy ? 1 : -1),
	                fr = (x * dirx > y * diry ? ky : kx);
	            switch (this.type) {
	                case "rect":
	                case "image":
	                    var neww = a.width * kx,
	                        newh = a.height * ky;
	                    this.attr({
	                        height: newh,
	                        r: a.r * fr,
	                        width: neww,
	                        x: ncx - neww / 2,
	                        y: ncy - newh / 2
	                    });
	                    break;
	                case "circle":
	                case "ellipse":
	                    this.attr({
	                        rx: a.rx * kx,
	                        ry: a.ry * ky,
	                        r: a.r * fr,
	                        cx: ncx,
	                        cy: ncy
	                    });
	                    break;
	                case "text":
	                    this.attr({
	                        x: ncx,
	                        y: ncy
	                    });
	                    break;
	                case "path":
	                    var path = pathToRelative(a.path),
	                        skip = true,
	                        fx = posx ? dkx : kx,
	                        fy = posy ? dky : ky;
	                    for (var i = 0, ii = path[length]; i < ii; i++) {
	                        var p = path[i],
	                            P0 = upperCase.call(p[0]);
	                        if (P0 == "M" && skip) {
	                            continue;
	                        } else {
	                            skip = false;
	                        }
	                        if (P0 == "A") {
	                            p[path[i][length] - 2] *= fx;
	                            p[path[i][length] - 1] *= fy;
	                            p[1] *= kx;
	                            p[2] *= ky;
	                            p[5] = +(dirx + diry ? !!+p[5] : !+p[5]);
	                        } else if (P0 == "H") {
	                            for (var j = 1, jj = p[length]; j < jj; j++) {
	                                p[j] *= fx;
	                            }
	                        } else if (P0 == "V") {
	                            for (j = 1, jj = p[length]; j < jj; j++) {
	                                p[j] *= fy;
	                            }
	                         } else {
	                            for (j = 1, jj = p[length]; j < jj; j++) {
	                                p[j] *= (j % 2) ? fx : fy;
	                            }
	                        }
	                    }
	                    var dim2 = pathDimensions(path);
	                    dx = ncx - dim2.x - dim2.width / 2;
	                    dy = ncy - dim2.y - dim2.height / 2;
	                    path[0][1] += dx;
	                    path[0][2] += dy;
	                    this.attr({path: path});
	                break;
	            }
	            if (this.type in {text: 1, image:1} && (dirx != 1 || diry != 1)) {
	                if (this.transformations) {
	                    this.transformations[2] = "scale("[concat](dirx, ",", diry, ")");
	                    setAttr(this.node, "transform", this.transformations[join](S));
	                    dx = (dirx == -1) ? -a.x - (neww || 0) : a.x;
	                    dy = (diry == -1) ? -a.y - (newh || 0) : a.y;
	                    this.attr({x: dx, y: dy});
	                    a.fx = dirx - 1;
	                    a.fy = diry - 1;
	                } else {
	                    this.node.filterMatrix = ms + ".Matrix(M11="[concat](dirx,
	                        ", M12=0, M21=0, M22=", diry,
	                        ", Dx=0, Dy=0, sizingmethod='auto expand', filtertype='bilinear')");
	                    s.filter = (this.node.filterMatrix || E) + (this.node.filterOpacity || E);
	                }
	            } else {
	                if (this.transformations) {
	                    this.transformations[2] = E;
	                    setAttr(this.node, "transform", this.transformations[join](S));
	                    a.fx = 0;
	                    a.fy = 0;
	                } else {
	                    this.node.filterMatrix = E;
	                    s.filter = (this.node.filterMatrix || E) + (this.node.filterOpacity || E);
	                }
	            }
	            a.scale = [x, y, cx, cy][join](S);
	            this._.sx = x;
	            this._.sy = y;
	        }
	        return this;
	    };
	    elproto.clone = function () {
	        if (this.removed) {
	            return null;
	        }
	        var attr = this.attr();
	        delete attr.scale;
	        delete attr.translation;
	        return this.paper[this.type]().attr(attr);
	    };
	    var curveslengths = {},
	    getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
	        // Is this a straight line?
	        // Added for huge speed improvements
	        if ( p1x === c1x && p1y === c1y && c2x === p2x && c2y == p2y ) {
	            var dx = p2x - p1x, dy = p2y - p1y;
	            var totalLength = Math.sqrt( dx * dx + dy * dy );

	            if ( length == null ) {
	                return totalLength;
	            } else {
	                var fract = length / totalLength;
	                return {
	                    start: { x: p1x, y: p1y },
	                    m: { x: p1x, y: p1y },
	                    n: { x: p2x, y: p2y },
	                    end: { x: p2x, y: p2y },
	                    x: p1x + fract * dx,
	                    y: p1y + fract * dy,
	                    alpha: (90 - math.atan(dx / dy) * 180 / PI)
	                };
	            }
	        }

	        var len = 0,
	            precision = 100,
	            name = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y].join(),
	            cache = curveslengths[name],
	            old, dot;
	        !cache && (curveslengths[name] = cache = {data: []});
	        cache.timer && clearTimeout(cache.timer);
	        cache.timer = setTimeout(function () {delete curveslengths[name];}, 2000);
	        if (length != null) {
	            var total = getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
	            precision = ~~total * 10;
	        }
	        for (var i = 0; i < precision + 1; i++) {
	            if (cache.data[length] > i) {
	                dot = cache.data[i * precision];
	            } else {
	                dot = R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, i / precision);
	                cache.data[i] = dot;
	            }
	            i && (len += pow(pow(old.x - dot.x, 2) + pow(old.y - dot.y, 2), .5));
	            if (length != null && len >= length) {
	                return dot;
	            }
	            old = dot;
	        }
	        if (length == null) {
	            return len;
	        }
	    },
	    getLengthFactory = function (istotal, subpath) {
	        return function (path, length, onlystart) {
	            path = path2curve(path);
	            var x, y, p, l, sp = "", subpaths = {}, point,
	                len = 0;
	            for (var i = 0, ii = path.length; i < ii; i++) {
	                p = path[i];
	                if (p[0] == "M") {
	                    x = +p[1];
	                    y = +p[2];
	                } else {
	                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
	                    if (len + l > length) {
	                        if (subpath && !subpaths.start) {
	                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
	                            sp += ["C", point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
	                            if (onlystart) {return sp;}
	                            subpaths.start = sp;
	                            sp = ["M", point.x, point.y + "C", point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]][join]();
	                            len += l;
	                            x = +p[5];
	                            y = +p[6];
	                            continue;
	                        }
	                        if (!istotal && !subpath) {
	                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
	                            return {x: point.x, y: point.y, alpha: point.alpha};
	                        }
	                    }
	                    len += l;
	                    x = +p[5];
	                    y = +p[6];
	                }
	                sp += p;
	            }
	            subpaths.end = sp;
	            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[1], p[2], p[3], p[4], p[5], p[6], 1);
	            point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
	            return point;
	        };
	    };
	    var getTotalLength = getLengthFactory(1),
	        getPointAtLength = getLengthFactory(),
	        getSubpathsAtLength = getLengthFactory(0, 1);
	    elproto.getTotalLength = function () {
	        if (this.type != "path") {return;}
	        if (this.node.getTotalLength) {
	            return this.node.getTotalLength();
	        }
	        return getTotalLength(this.attrs.path);
	    };
	    elproto.getPointAtLength = function (length) {
	        if (this.type != "path") {return;}
	        return getPointAtLength(this.attrs.path, length);
	    };
	    elproto.getSubpath = function (from, to) {
	        if (this.type != "path") {return;}
	        if (abs(this.getTotalLength() - to) < "1e-6") {
	            return getSubpathsAtLength(this.attrs.path, from).end;
	        }
	        var a = getSubpathsAtLength(this.attrs.path, to, 1);
	        return from ? getSubpathsAtLength(a, from).end : a;
	    };

	    // animation easing formulas
	    R.easing_formulas = {
	        linear: function (n) {
	            return n;
	        },
	        "<": function (n) {
	            return pow(n, 3);
	        },
	        ">": function (n) {
	            return pow(n - 1, 3) + 1;
	        },
	        "<>": function (n) {
	            n = n * 2;
	            if (n < 1) {
	                return pow(n, 3) / 2;
	            }
	            n -= 2;
	            return (pow(n, 3) + 2) / 2;
	        },
	        backIn: function (n) {
	            var s = 1.70158;
	            return n * n * ((s + 1) * n - s);
	        },
	        backOut: function (n) {
	            n = n - 1;
	            var s = 1.70158;
	            return n * n * ((s + 1) * n + s) + 1;
	        },
	        elastic: function (n) {
	            if (n == 0 || n == 1) {
	                return n;
	            }
	            var p = .3,
	                s = p / 4;
	            return pow(2, -10 * n) * math.sin((n - s) * (2 * PI) / p) + 1;
	        },
	        bounce: function (n) {
	            var s = 7.5625,
	                p = 2.75,
	                l;
	            if (n < (1 / p)) {
	                l = s * n * n;
	            } else {
	                if (n < (2 / p)) {
	                    n -= (1.5 / p);
	                    l = s * n * n + .75;
	                } else {
	                    if (n < (2.5 / p)) {
	                        n -= (2.25 / p);
	                        l = s * n * n + .9375;
	                    } else {
	                        n -= (2.625 / p);
	                        l = s * n * n + .984375;
	                    }
	                }
	            }
	            return l;
	        }
	    };

	    var animationElements = [],
	        animation = function () {
	            var Now = +new Date;
	            for (var l = 0; l < animationElements[length]; l++) {
	                var e = animationElements[l];
	                if (e.stop || e.el.removed) {
	                    continue;
	                }
	                var time = Now - e.start,
	                    ms = e.ms,
	                    easing = e.easing,
	                    from = e.from,
	                    diff = e.diff,
	                    to = e.to,
	                    t = e.t,
	                    that = e.el,
	                    set = {},
	                    now;
	                if (time < ms) {
	                    var pos = easing(time / ms);
	                    for (var attr in from) if (from[has](attr)) {
	                        switch (availableAnimAttrs[attr]) {
	                            case "along":
	                                now = pos * ms * diff[attr];
	                                to.back && (now = to.len - now);
	                                var point = getPointAtLength(to[attr], now);
	                                that.translate(diff.sx - diff.x || 0, diff.sy - diff.y || 0);
	                                diff.x = point.x;
	                                diff.y = point.y;
	                                that.translate(point.x - diff.sx, point.y - diff.sy);
	                                to.rot && that.rotate(diff.r + point.alpha, point.x, point.y);
	                                break;
	                            case nu:
	                                now = +from[attr] + pos * ms * diff[attr];
	                                break;
	                            case "colour":
	                                now = "rgb(" + [
	                                    upto255(round(from[attr].r + pos * ms * diff[attr].r)),
	                                    upto255(round(from[attr].g + pos * ms * diff[attr].g)),
	                                    upto255(round(from[attr].b + pos * ms * diff[attr].b))
	                                ][join](",") + ")";
	                                break;
	                            case "path":
	                                now = [];
	                                for (var i = 0, ii = from[attr][length]; i < ii; i++) {
	                                    now[i] = [from[attr][i][0]];
	                                    for (var j = 1, jj = from[attr][i][length]; j < jj; j++) {
	                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
	                                    }
	                                    now[i] = now[i][join](S);
	                                }
	                                now = now[join](S);
	                                break;
	                            case "csv":
	                                switch (attr) {
	                                    case "translation":
	                                        var x = pos * ms * diff[attr][0] - t.x,
	                                            y = pos * ms * diff[attr][1] - t.y;
	                                        t.x += x;
	                                        t.y += y;
	                                        now = x + S + y;
	                                    break;
	                                    case "rotation":
	                                        now = +from[attr][0] + pos * ms * diff[attr][0];
	                                        from[attr][1] && (now += "," + from[attr][1] + "," + from[attr][2]);
	                                    break;
	                                    case "scale":
	                                        now = [+from[attr][0] + pos * ms * diff[attr][0], +from[attr][1] + pos * ms * diff[attr][1], (2 in to[attr] ? to[attr][2] : E), (3 in to[attr] ? to[attr][3] : E)][join](S);
	                                    break;
	                                    case "clip-rect":
	                                        now = [];
	                                        i = 4;
	                                        while (i--) {
	                                            now[i] = +from[attr][i] + pos * ms * diff[attr][i];
	                                        }
	                                    break;
	                                }
	                                break;
	                            default:
	                              var from2 = [].concat(from[attr]);
	                                now = [];
	                                i = that.paper.customAttributes[attr].length;
	                                while (i--) {
	                                    now[i] = +from2[i] + pos * ms * diff[attr][i];
	                                }
	                                break;
	                        }
	                        set[attr] = now;
	                    }
	                    that.attr(set);
	                    that._run && that._run.call(that);
	                } else {
	                    if (to.along) {
	                        point = getPointAtLength(to.along, to.len * !to.back);
	                        that.translate(diff.sx - (diff.x || 0) + point.x - diff.sx, diff.sy - (diff.y || 0) + point.y - diff.sy);
	                        to.rot && that.rotate(diff.r + point.alpha, point.x, point.y);
	                    }
	                    (t.x || t.y) && that.translate(-t.x, -t.y);
	                    to.scale && (to.scale += E);
	                    that.attr(to);
	                    animationElements.splice(l--, 1);
	                }
	            }
	            R.svg && that && that.paper && that.paper.safari();
	            animationElements[length] && setTimeout(animation);
	        },
	        keyframesRun = function (attr, element, time, prev, prevcallback) {
	            var dif = time - prev;
	            element.timeouts.push(setTimeout(function () {
	                R.is(prevcallback, "function") && prevcallback.call(element);
	                element.animate(attr, dif, attr.easing);
	            }, prev));
	        },
	        upto255 = function (color) {
	            return mmax(mmin(color, 255), 0);
	        },
	        translate = function (x, y) {
	            if (x == null) {
	                return {x: this._.tx, y: this._.ty, toString: x_y};
	            }
	            this._.tx += +x;
	            this._.ty += +y;
	            switch (this.type) {
	                case "circle":
	                case "ellipse":
	                    this.attr({cx: +x + this.attrs.cx, cy: +y + this.attrs.cy});
	                    break;
	                case "rect":
	                case "image":
	                case "text":
	                    this.attr({x: +x + this.attrs.x, y: +y + this.attrs.y});
	                    break;
	                case "path":
	                    var path = pathToRelative(this.attrs.path);
	                    path[0][1] += +x;
	                    path[0][2] += +y;
	                    this.attr({path: path});
	                break;
	            }
	            return this;
	        };
	    elproto.animateWith = function (element, params, ms, easing, callback) {
	        for (var i = 0, ii = animationElements.length; i < ii; i++) {
	            if (animationElements[i].el.id == element.id) {
	                params.start = animationElements[i].start;
	            }
	        }
	        return this.animate(params, ms, easing, callback);
	    };
	    elproto.animateAlong = along();
	    elproto.animateAlongBack = along(1);
	    function along(isBack) {
	        return function (path, ms, rotate, callback) {
	            var params = {back: isBack};
	            R.is(rotate, "function") ? (callback = rotate) : (params.rot = rotate);
	            path && path.constructor == Element && (path = path.attrs.path);
	            path && (params.along = path);
	            return this.animate(params, ms, callback);
	        };
	    }
	    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
	        var cx = 3 * p1x,
	            bx = 3 * (p2x - p1x) - cx,
	            ax = 1 - cx - bx,
	            cy = 3 * p1y,
	            by = 3 * (p2y - p1y) - cy,
	            ay = 1 - cy - by;
	        function sampleCurveX(t) {
	            return ((ax * t + bx) * t + cx) * t;
	        }
	        function solve(x, epsilon) {
	            var t = solveCurveX(x, epsilon);
	            return ((ay * t + by) * t + cy) * t;
	        }
	        function solveCurveX(x, epsilon) {
	            var t0, t1, t2, x2, d2, i;
	            for(t2 = x, i = 0; i < 8; i++) {
	                x2 = sampleCurveX(t2) - x;
	                if (abs(x2) < epsilon) {
	                    return t2;
	                }
	                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
	                if (abs(d2) < 1e-6) {
	                    break;
	                }
	                t2 = t2 - x2 / d2;
	            }
	            t0 = 0;
	            t1 = 1;
	            t2 = x;
	            if (t2 < t0) {
	                return t0;
	            }
	            if (t2 > t1) {
	                return t1;
	            }
	            while (t0 < t1) {
	                x2 = sampleCurveX(t2);
	                if (abs(x2 - x) < epsilon) {
	                    return t2;
	                }
	                if (x > x2) {
	                    t0 = t2;
	                } else {
	                    t1 = t2;
	                }
	                t2 = (t1 - t0) / 2 + t0;
	            }
	            return t2;
	        }
	        return solve(t, 1 / (200 * duration));
	    }
	    elproto.onAnimation = function (f) {
	        this._run = f || 0;
	        return this;
	    };
	    elproto.animate = function (params, ms, easing, callback) {
	        var element = this;
	        element.timeouts = element.timeouts || [];
	        if (R.is(easing, "function") || !easing) {
	            callback = easing || null;
	        }
	        if (element.removed) {
	            callback && callback.call(element);
	            return element;
	        }
	        var from = {},
	            to = {},
	            animateable = false,
	            diff = {};
	        for (var attr in params) if (params[has](attr)) {
	            if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
	                animateable = true;
	                from[attr] = element.attr(attr);
	                (from[attr] == null) && (from[attr] = availableAttrs[attr]);
	                to[attr] = params[attr];
	                switch (availableAnimAttrs[attr]) {
	                    case "along":
	                        var len = getTotalLength(params[attr]);
	                        var point = getPointAtLength(params[attr], len * !!params.back);
	                        var bb = element.getBBox();
	                        diff[attr] = len / ms;
	                        diff.tx = bb.x;
	                        diff.ty = bb.y;
	                        diff.sx = point.x;
	                        diff.sy = point.y;
	                        to.rot = params.rot;
	                        to.back = params.back;
	                        to.len = len;
	                        params.rot && (diff.r = toFloat(element.rotate()) || 0);
	                        break;
	                    case nu:
	                        diff[attr] = (to[attr] - from[attr]) / ms;
	                        break;
	                    case "colour":
	                        from[attr] = R.getRGB(from[attr]);
	                        var toColour = R.getRGB(to[attr]);
	                        diff[attr] = {
	                            r: (toColour.r - from[attr].r) / ms,
	                            g: (toColour.g - from[attr].g) / ms,
	                            b: (toColour.b - from[attr].b) / ms
	                        };
	                        break;
	                    case "path":
	                        var pathes = path2curve(from[attr], to[attr]);
	                        from[attr] = pathes[0];
	                        var toPath = pathes[1];
	                        diff[attr] = [];
	                        for (var i = 0, ii = from[attr][length]; i < ii; i++) {
	                            diff[attr][i] = [0];
	                            for (var j = 1, jj = from[attr][i][length]; j < jj; j++) {
	                                diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
	                            }
	                        }
	                        break;
	                    case "csv":
	                        var values = Str(params[attr])[split](separator),
	                            from2 = Str(from[attr])[split](separator);
	                        switch (attr) {
	                            case "translation":
	                                from[attr] = [0, 0];
	                                diff[attr] = [values[0] / ms, values[1] / ms];
	                            break;
	                            case "rotation":
	                                from[attr] = (from2[1] == values[1] && from2[2] == values[2]) ? from2 : [0, values[1], values[2]];
	                                diff[attr] = [(values[0] - from[attr][0]) / ms, 0, 0];
	                            break;
	                            case "scale":
	                                params[attr] = values;
	                                from[attr] = Str(from[attr])[split](separator);
	                                diff[attr] = [(values[0] - from[attr][0]) / ms, (values[1] - from[attr][1]) / ms, 0, 0];
	                            break;
	                            case "clip-rect":
	                                from[attr] = Str(from[attr])[split](separator);
	                                diff[attr] = [];
	                                i = 4;
	                                while (i--) {
	                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;
	                                }
	                            break;
	                        }
	                        to[attr] = values;
	                        break;
	                    default:
	                        values = [].concat(params[attr]);
	                        from2 = [].concat(from[attr]);
	                        diff[attr] = [];
	                        i = element.paper.customAttributes[attr][length];
	                        while (i--) {
	                            diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
	                        }
	                        break;
	                }
	            }
	        }
	        if (!animateable) {
	            var attrs = [],
	                lastcall;
	            for (var key in params) if (params[has](key) && animKeyFrames.test(key)) {
	                attr = {value: params[key]};
	                key == "from" && (key = 0);
	                key == "to" && (key = 100);
	                attr.key = toInt(key, 10);
	                attrs.push(attr);
	            }
	            attrs.sort(sortByKey);
	            if (attrs[0].key) {
	                attrs.unshift({key: 0, value: element.attrs});
	            }
	            for (i = 0, ii = attrs[length]; i < ii; i++) {
	                keyframesRun(attrs[i].value, element, ms / 100 * attrs[i].key, ms / 100 * (attrs[i - 1] && attrs[i - 1].key || 0), attrs[i - 1] && attrs[i - 1].value.callback);
	            }
	            lastcall = attrs[attrs[length] - 1].value.callback;
	            if (lastcall) {
	                element.timeouts.push(setTimeout(function () {lastcall.call(element);}, ms));
	            }
	        } else {
	            var easyeasy = R.easing_formulas[easing];
	            if (!easyeasy) {
	                easyeasy = Str(easing).match(bezierrg);
	                if (easyeasy && easyeasy[length] == 5) {
	                    var curve = easyeasy;
	                    easyeasy = function (t) {
	                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
	                    };
	                } else {
	                    easyeasy = function (t) {
	                        return t;
	                    };
	                }
	            }
	            animationElements.push({
	                start: params.start || +new Date,
	                ms: ms,
	                easing: easyeasy,
	                from: from,
	                diff: diff,
	                to: to,
	                el: element,
	                t: {x: 0, y: 0}
	            });
	            R.is(callback, "function") && (element._ac = setTimeout(function () {
	                callback.call(element);
	            }, ms));
	            animationElements[length] == 1 && setTimeout(animation);
	        }
	        return this;
	    };
	    elproto.stop = function () {
	        for (var i = 0; i < animationElements.length; i++) {
	            animationElements[i].el.id == this.id && animationElements.splice(i--, 1);
	        }
	        for (i = 0, ii = this.timeouts && this.timeouts.length; i < ii; i++) {
	            clearTimeout(this.timeouts[i]);
	        }
	        this.timeouts = [];
	        clearTimeout(this._ac);
	        delete this._ac;
	        return this;
	    };
	    elproto.translate = function (x, y) {
	        return this.attr({translation: x + " " + y});
	    };
	    elproto[toString] = function () {
	        return "Rapha\xebl\u2019s object";
	    };
	    R.ae = animationElements;

	    // Set
	    var Set = function (items) {
	        this.items = [];
	        this[length] = 0;
	        this.type = "set";
	        if (items) {
	            for (var i = 0, ii = items[length]; i < ii; i++) {
	                if (items[i] && (items[i].constructor == Element || items[i].constructor == Set)) {
	                    this[this.items[length]] = this.items[this.items[length]] = items[i];
	                    this[length]++;
	                }
	            }
	        }
	    };
	    Set[proto][push] = function () {
	        var item,
	            len;
	        for (var i = 0, ii = arguments[length]; i < ii; i++) {
	            item = arguments[i];
	            if (item && (item.constructor == Element || item.constructor == Set)) {
	                len = this.items[length];
	                this[len] = this.items[len] = item;
	                this[length]++;
	            }
	        }
	        return this;
	    };
	    Set[proto].pop = function () {
	        delete this[this[length]--];
	        return this.items.pop();
	    };
	    for (var method in elproto) if (elproto[has](method)) {
	        Set[proto][method] = (function (methodname) {
	            return function () {
	                for (var i = 0, ii = this.items[length]; i < ii; i++) {
	                    this.items[i][methodname][apply](this.items[i], arguments);
	                }
	                return this;
	            };
	        })(method);
	    }
	    Set[proto].attr = function (name, value) {
	        if (name && R.is(name, array) && R.is(name[0], "object")) {
	            for (var j = 0, jj = name[length]; j < jj; j++) {
	                this.items[j].attr(name[j]);
	            }
	        } else {
	            for (var i = 0, ii = this.items[length]; i < ii; i++) {
	                this.items[i].attr(name, value);
	            }
	        }
	        return this;
	    };
	    Set[proto].animate = function (params, ms, easing, callback) {
	        (R.is(easing, "function") || !easing) && (callback = easing || null);
	        var len = this.items[length],
	            i = len,
	            item,
	            set = this,
	            collector;
	        callback && (collector = function () {
	            !--len && callback.call(set);
	        });
	        easing = R.is(easing, string) ? easing : collector;
	        item = this.items[--i].animate(params, ms, easing, collector);
	        while (i--) {
	            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, params, ms, easing, collector);
	        }
	        return this;
	    };
	    Set[proto].insertAfter = function (el) {
	        var i = this.items[length];
	        while (i--) {
	            this.items[i].insertAfter(el);
	        }
	        return this;
	    };
	    Set[proto].getBBox = function () {
	        var x = [],
	            y = [],
	            w = [],
	            h = [];
	        for (var i = this.items[length]; i--;) {
	            var box = this.items[i].getBBox();
	            x[push](box.x);
	            y[push](box.y);
	            w[push](box.x + box.width);
	            h[push](box.y + box.height);
	        }
	        x = mmin[apply](0, x);
	        y = mmin[apply](0, y);
	        return {
	            x: x,
	            y: y,
	            width: mmax[apply](0, w) - x,
	            height: mmax[apply](0, h) - y
	        };
	    };
	    Set[proto].clone = function (s) {
	        s = new Set;
	        for (var i = 0, ii = this.items[length]; i < ii; i++) {
	            s[push](this.items[i].clone());
	        }
	        return s;
	    };

	    R.registerFont = function (font) {
	        if (!font.face) {
	            return font;
	        }
	        this.fonts = this.fonts || {};
	        var fontcopy = {
	                w: font.w,
	                face: {},
	                glyphs: {}
	            },
	            family = font.face["font-family"];
	        for (var prop in font.face) if (font.face[has](prop)) {
	            fontcopy.face[prop] = font.face[prop];
	        }
	        if (this.fonts[family]) {
	            this.fonts[family][push](fontcopy);
	        } else {
	            this.fonts[family] = [fontcopy];
	        }
	        if (!font.svg) {
	            fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
	            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
	                var path = font.glyphs[glyph];
	                fontcopy.glyphs[glyph] = {
	                    w: path.w,
	                    k: {},
	                    d: path.d && "M" + path.d[rp](/[mlcxtrv]/g, function (command) {
	                            return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
	                        }) + "z"
	                };
	                if (path.k) {
	                    for (var k in path.k) if (path[has](k)) {
	                        fontcopy.glyphs[glyph].k[k] = path.k[k];
	                    }
	                }
	            }
	        }
	        return font;
	    };
	    paperproto.getFont = function (family, weight, style, stretch) {
	        stretch = stretch || "normal";
	        style = style || "normal";
	        weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
	        if (!R.fonts) {
	            return;
	        }
	        var font = R.fonts[family];
	        if (!font) {
	            var name = new RegExp("(^|\\s)" + family[rp](/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
	            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
	                if (name.test(fontName)) {
	                    font = R.fonts[fontName];
	                    break;
	                }
	            }
	        }
	        var thefont;
	        if (font) {
	            for (var i = 0, ii = font[length]; i < ii; i++) {
	                thefont = font[i];
	                if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
	                    break;
	                }
	            }
	        }
	        return thefont;
	    };
	    paperproto.print = function (x, y, string, font, size, origin, letter_spacing) {
	        origin = origin || "middle"; // baseline|middle
	        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
	        var out = this.set(),
	            letters = Str(string)[split](E),
	            shift = 0,
	            path = E,
	            scale;
	        R.is(font, string) && (font = this.getFont(font));
	        if (font) {
	            scale = (size || 16) / font.face["units-per-em"];
	            var bb = font.face.bbox.split(separator),
	                top = +bb[0],
	                height = +bb[1] + (origin == "baseline" ? bb[3] - bb[1] + (+font.face.descent) : (bb[3] - bb[1]) / 2);
	            for (var i = 0, ii = letters[length]; i < ii; i++) {
	                var prev = i && font.glyphs[letters[i - 1]] || {},
	                    curr = font.glyphs[letters[i]];
	                shift += i ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
	                curr && curr.d && out[push](this.path(curr.d).attr({fill: "#000", stroke: "none", translation: [shift, 0]}));
	            }
	            out.scale(scale, scale, top, height).translate(x - top, y - height);
	        }
	        return out;
	    };

	    R.format = function (token, params) {
	        var args = R.is(params, array) ? [0][concat](params) : arguments;
	        token && R.is(token, string) && args[length] - 1 && (token = token[rp](formatrg, function (str, i) {
	            return args[++i] == null ? E : args[i];
	        }));
	        return token || E;
	    };
	    R.ninja = function () {
	        oldRaphael.was ? (win.Raphael = oldRaphael.is) : delete Raphael;
	        return R;
	    };
	    R.el = elproto;
	    R.st = Set[proto];

	    oldRaphael.was ? (win.Raphael = R) : (Raphael = R);
	})();


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	KhanUtil.scale = {
	    orig: {
	        unknown: 1,
	        leftCoef: 1,
	        leftConst: 5,
	        rightCoef: 0,
	        rightConst: 6
	    },
	    unknown: 1,
	    leftCoef: 1,
	    leftConst: 5,
	    rightCoef: 0,
	    rightConst: 6,
	    angle: 0,
	    baseY: -6,
	    image: "/images/avatars/mr-pink.png",
	    equation: {
	        eqLabel: {remove: function() {}},
	        leftCoefLabel: {remove: function() {}},
	        leftLabel: {remove: function() {}},
	        rightLabel: {remove: function() {}},
	        yPos: -10.5,

	        init: function(options) {
	            this.graphie = KhanUtil.scale.graphie;
	            $.extend(this, options);

	            this.graphie.raphael.image(KhanUtil.scale.image,
	                this.graphie.scalePoint([-7.8, this.yPos + 1.2])[0],
	                this.graphie.scalePoint([-7.8, this.yPos + 1.2])[1],
	                40, 40).attr({
	                    opacity: 1
	                });
	        },
	        draw: function(x, n, a, b) {
	            this.eqLabel.remove();
	            this.leftCoefLabel.remove();
	            this.leftLabel.remove();
	            this.rightLabel.remove();

	            if (a + x === b) {
	                this.eqLabel = this.graphie.label([0, this.yPos],
	                    "\\Huge{=}");
	            } else {
	                this.eqLabel = this.graphie.label([0, this.yPos],
	                    "\\Huge{\\ne}");
	            }
	            if (n !== 1) {
	                this.leftCoefLabel = this.graphie.label([-6.8, this.yPos],
	                    "\\Huge{" + n + "(\\qquad\\quad)}");
	            } else {
	                this.leftCoefLabel = {remove: function() {}};
	            }
	            if (a !== 0) {
	                this.leftLabel = this.graphie.label([-3.7, this.yPos],
	                    "\\Huge{{} + " + a + "}");
	            } else {
	                this.leftLabel = {remove: function() {}};
	            }
	            this.rightLabel = this.graphie.label([3.5, this.yPos],
	                "\\Huge{" + b + "}");
	        }
	    },

	    addWeight: function(xOffset, yOffset, num, dish) {
	        var weights = [];
	        _(10).times(function(n) {
	            var weight = {};
	            /*
	            var pos = [
	                [-1.15, 0.05],
	                [0.15, 0.05],
	                [-0.5, 1.05],
	                [-2.45, 0.05],
	                [-1.8, 1.05],
	                [-1.15, 2.05],
	                [1.45, 0.05],
	                [0.8, 1.05],
	                [0.15, 2.05],
	                [-0.5, 3.05]
	            ][n];
	            */
	            var pos = [
	                [-1, 0.0],
	                [0, 0.0],
	                [-0.5, 1.0],
	                [-2, 0.0],
	                [-1.5, 1.0],
	                [-1, 2.0],
	                [1, 0.0],
	                [0.5, 1.0],
	                [0, 2.0],
	                [-0.5, 3.0]
	            ][n];

	            weight.kgMass = KhanUtil.scale.graphie.path([
	                    [pos[0] + xOffset, pos[1] + yOffset],
	                    [pos[0] + xOffset + 1, pos[1] + yOffset],
	                    [pos[0] + xOffset + 1, pos[1] + yOffset + 1],
	                    [pos[0] + xOffset, pos[1] + yOffset + 1], true], {
	                strokeWidth: 1,
	                stroke: "#994499",
	                fill: KhanUtil.PURPLE
	            });

	            weight.lbl = KhanUtil.scale.graphie.raphael.text(
	                KhanUtil.scale.graphie.scalePoint([pos[0] + xOffset + 0.5,
	                            pos[1] + yOffset + 0.5])[0],
	                KhanUtil.scale.graphie.scalePoint([pos[0] + xOffset + 0.5,
	                            pos[1] + yOffset + 0.5])[1], "1");
	            weight.lbl.attr({
	                "font-size": 15,
	                "font-weight": "bold",
	                "font-family": "inherit",
	                "stroke": "#fff",
	                "fill": "#fff"
	            });
	            weights[n] = weight;
	            dish.push(weight.kgMass);
	            dish.push(weight.lbl);
	            if (n >= num) {
	                weight.kgMass.attr({opacity: 0, translation: "0 -40"});
	                weight.lbl.attr({opacity: 0, translation: "0 -40"});
	            }
	            weight.remove = function(speed) {
	                if (speed == null) {
	                    speed = 300;
	                }
	                this.kgMass.animate({
	                    "opacity": 0.0,
	                    "translation": "0 -40"
	                }, speed);
	                this.lbl.animate({
	                    "opacity": 0.0,
	                    "translation": "0 -40"
	                }, speed);
	            };
	            weight.add = function(speed) {
	                if (speed == null) {
	                    speed = 300;
	                }
	                this.kgMass.animate({
	                    "opacity": 1.0,
	                    "translation": "0 40"
	                }, speed);
	                this.lbl.animate({
	                    "opacity": 1.0,
	                    "translation": "0 40"
	                }, speed);
	            };
	        });
	        return weights;
	    },

	    balance: function(speed) {
	        if (speed == null) {
	            speed = 500;
	        }
	        var newAngle = 0;
	        var currentAngle = this.angle;
	        this.equation.draw(this.unknown, this.leftCoef,
	            this.leftConst, this.rightConst);

	        if (this.leftConst + this.unknown < this.rightConst) {
	            newAngle = 8;
	        } else if (this.leftConst + this.unknown > this.rightConst) {
	            newAngle = -8;
	        }
	        $({r: this.angle}).animate({r: newAngle}, {
	            duration: speed,
	            step: function(now, fx) {
	                var dist = 5.5 * Math.sin(now * Math.PI / 180) *
	                        KhanUtil.currentGraph.scale[1];
	                var leftPos = KhanUtil.scale.leftDishItems[0].
	                        attr("translation").y;
	                var rightPos = KhanUtil.scale.rightDishItems[0].
	                        attr("translation").y;
	                KhanUtil.scale.angle = now;
	                KhanUtil.scale.beamItems.rotate(now, [0, 0]);
	                KhanUtil.scale.leftDishItems.translate([0, -dist - leftPos]);
	                KhanUtil.scale.rightDishItems.translate([0, dist - rightPos]);
	            }
	        });
	        if (_.isFunction(this.onChange)) {
	            this.onChange(this.leftCoef, this.leftConst,
	                this.rightCoef, this.rightConst);
	        }
	    },

	    subtractLeftWeight: function() {
	        this.leftConst -= 1;
	        this.leftWeight[this.leftConst].remove();
	        this.balance();
	    },

	    addLeftWeight: function() {
	        this.leftWeight[this.leftConst].add();
	        this.leftConst += 1;
	        this.balance();
	    },

	    setLeftWeight: function(weight) {
	        while (this.leftConst !== weight) {
	            if (this.leftConst < weight) {
	                this.leftWeight[this.leftConst].add(0);
	                this.leftConst += 1;
	            } else {
	                this.leftConst -= 1;
	                this.leftWeight[this.leftConst].remove(0);
	            }
	        }
	        this.balance(0);
	    },

	    subtractRightWeight: function() {
	        this.rightConst -= 1;
	        this.rightWeight[this.rightConst].remove();
	        this.balance();
	    },

	    addRightWeight: function() {
	        this.rightWeight[this.rightConst].add();
	        this.rightConst += 1;
	        this.balance();
	    },

	    setRightWeight: function(weight) {
	        while (this.rightConst !== weight) {
	            if (this.rightConst < weight) {
	                this.rightWeight[this.rightConst].add(0);
	                this.rightConst += 1;
	            } else {
	                this.rightConst -= 1;
	                this.rightWeight[this.rightConst].remove(0);
	            }
	        }
	        this.balance(0);
	    },

	    resetProblem: function() {
	        while (this.leftConst !== this.orig.leftConst) {
	            if (this.leftConst < this.orig.leftConst) {
	                this.leftWeight[this.leftConst].add();
	                this.leftConst += 1;
	            } else {
	                this.leftConst -= 1;
	                this.leftWeight[this.leftConst].remove();
	            }
	        }
	        while (this.rightConst !== this.orig.rightConst) {
	            if (this.rightConst < this.orig.rightConst) {
	                this.rightWeight[this.rightConst].add();
	                this.rightConst += 1;
	            } else {
	                this.rightConst -= 1;
	                this.rightWeight[this.rightConst].remove();
	            }
	        }
	        this.balance();
	    },

	    init: function(options) {
	        this.graphie = KhanUtil.currentGraph;
	        $.extend(this, options);

	        // Save the original problem
	        this.orig.unknown = this.unknown;
	        this.orig.leftCoef = this.leftCoef;
	        this.orig.leftConst = this.leftConst;
	        this.orig.rightCoef = this.rightCoef;
	        this.orig.rightConst = this.rightConst;

	        Khan.scratchpad.disable();
	        this.graphie.init({
	            range: [[-12, 12], [-12, 1.5]],
	            scale: [20, 20]
	        });

	        this.leftWire1 = this.graphie.path(
	            [[-9, this.baseY - 0.1], [-5.5, 0]], {
	                stroke: KhanUtil.BLACK,
	                strokeWidth: 0.5
	            });
	        this.leftWire2 = this.graphie.path(
	            [[-2, this.baseY - 0.1], [-5.5, 0]], {
	                stroke: KhanUtil.BLACK,
	                strokeWidth: 0.5
	            });

	        this.rightWire1 = this.graphie.path(
	            [[9, this.baseY - 0.1], [5.5, 0]], {
	                stroke: KhanUtil.BLACK,
	                strokeWidth: 0.5
	            });
	        this.rightWire2 = this.graphie.path(
	            [[2, this.baseY - 0.1], [5.5, 0]], {
	                stroke: KhanUtil.BLACK,
	                strokeWidth: 0.5
	            });

	        this.leftDish = this.graphie.path(
	            [[-9, this.baseY], [-2, this.baseY], [-2, this.baseY - 0.2], [-9, this.baseY - 0.2], true], {
	                stroke: null,
	                fill: KhanUtil.BLUE
	            });
	        this.rightDish = this.graphie.path(
	            [[9, this.baseY], [2, this.baseY], [2, this.baseY - 0.2], [9, this.baseY - 0.2], true], {
	                stroke: null,
	                fill: KhanUtil.BLUE
	            });

	        this.leftDishItems = this.graphie.raphael.set();
	        this.rightDishItems = this.graphie.raphael.set();
	        this.leftDishItems.push(this.leftWire1);
	        this.leftDishItems.push(this.leftWire2);
	        this.leftDishItems.push(this.leftDish);
	        this.rightDishItems.push(this.rightWire1);
	        this.rightDishItems.push(this.rightWire2);
	        this.rightDishItems.push(this.rightDish);

	        this.leftWeight = this.addWeight(-4.5, this.baseY, this.leftConst, this.leftDishItems);
	        this.rightWeight = this.addWeight(5.5, this.baseY, this.rightConst, this.rightDishItems);

	        this.leftDishItems.push(this.graphie.raphael.image(this.image,
	            this.graphie.scalePoint([-8.9, this.baseY + 2.40])[0],
	            this.graphie.scalePoint([-8.9, this.baseY + 2.40])[1], 50, 50));

	        this.beamItems = this.graphie.raphael.set();
	        this.beam = this.graphie.path(
	            [[-5.8, -0.1], [5.8, -0.1], [5.8, 0.1], [-5.8, 0.1], true], {
	                stroke: null,
	                fill: KhanUtil.BLUE
	            });
	        this.beamPointer = this.graphie.path(
	            [[-0.1, 0], [0.1, 0], [0.1, 1], [-0.1, 1], true], {
	                stroke: null,
	                fill: KhanUtil.BLUE
	            });
	        this.beamItems.push(this.beam);
	        this.beamItems.push(this.beamPointer);

	        this.fulcrumBase = this.graphie.path(
	            [[0, -7], [1.2, -8.5], [-1.2, -8.5], true], {
	                stroke: null,
	                fill: KhanUtil.BLUE
	            });
	        this.fulcrum = this.graphie.path(
	            [[-0.2, -8], [0.2, -8], [0.2, 0], [-0.2, 0], true], {
	                stroke: null,
	                fill: KhanUtil.BLUE
	            });

	        this.fulcrumJoint1 = this.graphie.circle(
	            [0, 0], 0.6, {
	                stroke: null,
	                fill: KhanUtil.BLUE
	            });

	        this.fulcrumJoint2 = this.graphie.circle(
	            [0, 0], 0.4, {
	                stroke: null,
	                fill: '#fff'
	            });

	        this.equation.init();
	        this.balance();
	    }
	};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {
	    commonAngles: [
	        {deg: 15, rad: "\\frac{\\pi}{12}"},
	        {deg: 30, rad: "\\frac{\\pi}{6}"},
	        {deg: 45, rad: "\\frac{\\pi}{4}"},
	        {deg: 60, rad: "\\frac{\\pi}{3}"},
	        {deg: 90, rad: "\\frac{\\pi}{2}"},
	        {deg: 120, rad: "\\frac{2\\pi}{3}"},
	        {deg: 135, rad: "\\frac{3\\pi}{4}"},
	        {deg: 150, rad: "\\frac{5\\pi}{6}"},
	        {deg: 180, rad: "\\pi"},
	        {deg: 210, rad: "\\frac{7\\pi}{6}"},
	        {deg: 225, rad: "\\frac{5\\pi}{4}"},
	        {deg: 240, rad: "\\frac{4\\pi}{3}"},
	        {deg: 270, rad: "\\frac{3\\pi}{2}"},
	        {deg: 300, rad: "\\frac{5\\pi}{3}"},
	        {deg: 315, rad: "\\frac{7\\pi}{4}"},
	        {deg: 330, rad: "\\frac{11\\pi}{6}"},
	        {deg: 360, rad: "2\\pi"}
	    ],

	    // Convert a degree value to a radian value
	    toRadians: function(degrees) {
	        return degrees * Math.PI / 180;
	    },

	    // Convert a radian value to a degree value
	    toDegrees: function(radians) {
	        return radians * 180 / Math.PI;
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(39);

	$.fn["chemistryLoad"] = function() {
	    // TODO(jeresig): i18n: Currently the names of the atomic elements aren't
	    // being used in the UI, but if they are, they will need to be translated.
	    var elements = {
	        "Hydrogen": {
	            "symbol" : "H",
	            "atomic_number" : 1,
	            "atomic_weight" : 1.00794,
	            "density g/cm" : "0.0708 (@ -253°C)",
	            "melting_point K" : 14.01,
	            "boiling_point K" : 20.28,
	            "atomic_radius pm" : 79,
	            "covalent_radius pm" : 32,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 14.1,
	            "specific_heat (@20°C J/g mol)" : "14.267 (H-H)",
	            "fusion_heat (kJ/mol)" : "0.117 (H-H)",
	            "evaporation_heat (kJ/mol)" : "0.904 (H-H)",
	            "thermal_conductivity (@25°C W/m K) " : 0.1815,
	            "pauling_negativity" : 2.20,
	            "first_ionizing kJ/mol" : 1311.3,
	            "oxidation_states" : "1, -1",
	            "electronic_configuration" : "1s¹",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.750
	        },
	        "Helium": {
	            "symbol" : "He",
	            "atomic_number" : 2,
	            "atomic_weight" : 4.002602,
	            "density g/cm" : "0.147 (@ -270°C)",
	            "melting_point K" : 0.95,
	            "boiling_point K" : 4.216,
	            "atomic_radius pm" : 0.0,
	            "covalent_radius pm" : "-",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 31.8,
	            "specific_heat (@20°C J/g mol)" : 5.188,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 0.08,
	            "thermal_conductivity (@25°C W/m K) " : 0.152,
	            "pauling_negativity" : "-",
	            "first_ionizing kJ/mol" : 2361.3,
	            "oxidation_states" : "-",
	            "electronic_configuration" : "1s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.570
	        },
	        "Lithium": {
	            "symbol" : "Li",
	            "atomic_number" : 3,
	            "atomic_weight" : 6.941,
	            "density g/cm" : 0.534,
	            "melting_point K" : 553.69,
	            "boiling_point K" : 1118.15,
	            "atomic_radius pm" : 155,
	            "covalent_radius pm" : 163,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 13.1,
	            "specific_heat (@20°C J/g mol)" : 3.489,
	            "fusion_heat (kJ/mol)" : 2.89,
	            "evaporation_heat (kJ/mol)" : 148,
	            "thermal_conductivity (@25°C W/m K) " : 84.8,
	            "pauling_negativity" : 0.98,
	            "first_ionizing kJ/mol" : 519.9,
	            "oxidation_states" : 1,
	            "electronic_configuration" : "[He]2s¹",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 3.490
	        },
	        "Beryllium": {
	            "symbol" : "Be",
	            "atomic_number" : 4,
	            "atomic_weight" : 9.01218,
	            "density g/cm" : 1.848,
	            "melting_point K" : 1551,
	            "boiling_point K" : 3243,
	            "atomic_radius pm" : 112,
	            "covalent_radius pm" : 90,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 5.0,
	            "specific_heat (@20°C J/g mol)" : 1.824,
	            "fusion_heat (kJ/mol)" : 12.21,
	            "evaporation_heat (kJ/mol)" : 309,
	            "thermal_conductivity (@25°C W/m K) " : 201,
	            "pauling_negativity" : 1.57,
	            "first_ionizing kJ/mol" : 898.8,
	            "oxidation_states" : 2,
	            "electronic_configuration" : "[He]2s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 2.290
	        },
	        "Boron": {
	            "symbol" : "B",
	            "atomic_number" : 5,
	            "atomic_weight" : 10.811,
	            "density g/cm" : 2.34,
	            "melting_point K" : 2573,
	            "boiling_point K" : 3931,
	            "atomic_radius pm" : 98,
	            "covalent_radius pm" : 82,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 4.6,
	            "specific_heat (@20°C J/g mol)" : 1.025,
	            "fusion_heat (kJ/mol)" : 23.60,
	            "evaporation_heat (kJ/mol)" : 504.5,
	            "thermal_conductivity (@25°C W/m K) " : 27.4,
	            "pauling_negativity" : 2.04,
	            "first_ionizing kJ/mol" : 800.2,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[He]2s²2p¹",
	            "lattice_structure" : "TET",
	            "lattice_constant ang" : 8.730
	        },
	        "Carbon": {
	            "symbol" : "C",
	            "atomic_number" : 6,
	            "atomic_weight" : 12.011,
	            "density g/cm" : "2.25 (graphite)",
	            "melting_point K" : 3820,
	            "boiling_point K" : 5100,
	            "atomic_radius pm" : 91,
	            "covalent_radius pm" : 77,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 5.3,
	            "specific_heat (@20°C J/g mol)" : 0.711,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : "-",
	            "thermal_conductivity (@25°C W/m K) " : 1.59,
	            "pauling_negativity" : 2.55,
	            "first_ionizing kJ/mol" : 1085.7,
	            "oxidation_states" : "4, 2, -4",
	            "electronic_configuration" : "[He]2s²2p²",
	            "lattice_structure" : "DIA",
	            "lattice_constant ang" : 3.570
	        },
	        "Nitrogen": {
	            "symbol" : "N",
	            "atomic_number" : 7,
	            "atomic_weight" : 14.00674,
	            "density g/cm" : "0.808 (@ -195.8°C)",
	            "melting_point K" : 63.29,
	            "boiling_point K" : 77.4,
	            "atomic_radius pm" : 92,
	            "covalent_radius pm" : 75,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 17.3,
	            "specific_heat (@20°C J/g mol)" : "1.042 (N-N)",
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : "-",
	            "thermal_conductivity (@25°C W/m K) " : 0.026,
	            "pauling_negativity" : 3.04,
	            "first_ionizing kJ/mol" : 1401.5,
	            "oxidation_states" : "5, 4, 3, 2, -3",
	            "electronic_configuration" : "[He]2s²2p³",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 4.039
	        },
	        "Oxygen": {
	            "symbol" : "O",
	            "atomic_number" : 8,
	            "atomic_weight" : 15.9994,
	            "density g/cm" : "1.149 (@ -183°C)",
	            "melting_point K" : 54.8,
	            "boiling_point K" : 90.19,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : 73,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 14.0,
	            "specific_heat (@20°C J/g mol)" : "0.916 (O-O)",
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : "-",
	            "thermal_conductivity (@25°C W/m K) " : 0.027,
	            "pauling_negativity" : 3.44,
	            "first_ionizing kJ/mol" : 1313.1,
	            "oxidation_states" : "-2, -1",
	            "electronic_configuration" : "[He]2s²2p",
	            "lattice_structure" : "CUB",
	            "lattice_constant ang" : 6.830
	        },
	        "Fluorine": {
	            "symbol" : "F",
	            "atomic_number" : 9,
	            "atomic_weight" : 18.998403,
	            "density g/cm" : "1.108 (@ -189°C)",
	            "melting_point K" : 53.53,
	            "boiling_point K" : 85.01,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : 72,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 17.1,
	            "specific_heat (@20°C J/g mol)" : "0.824 (F-F)",
	            "fusion_heat (kJ/mol)" : "0.51 (F-F)",
	            "evaporation_heat (kJ/mol)" : "6.54 (F-F)",
	            "thermal_conductivity (@25°C W/m K) " : 0.028,
	            "pauling_negativity" : 3.98,
	            "first_ionizing kJ/mol" : 1680.0,
	            "oxidation_states" : -1,
	            "electronic_configuration" : "[He]2s²2p",
	            "lattice_structure" : "MCL",
	            "lattice_constant ang" : "-"
	        },
	        "Neon": {
	            "symbol" : "Ne",
	            "atomic_number" : 10,
	            "atomic_weight" : 20.1797,
	            "density g/cm" : "1.204 (@ -246°C)",
	            "melting_point K" : 48,
	            "boiling_point K" : 27.1,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : 71,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 16.8,
	            "specific_heat (@20°C J/g mol)" : 1.029,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 1.74,
	            "thermal_conductivity (@25°C W/m K) " : "(0.0493)",
	            "pauling_negativity" : 0.0,
	            "first_ionizing kJ/mol" : 2079.4,
	            "oxidation_states" : "-",
	            "electronic_configuration" : "[He]2s²2p",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 4.430
	        },
	        "Sodium": {
	            "symbol" : "Na",
	            "atomic_number" : 11,
	            "atomic_weight" : 22.989768,
	            "density g/cm" : 0.971,
	            "melting_point K" : 370.96,
	            "boiling_point K" : 1156.1,
	            "atomic_radius pm" : 190,
	            "covalent_radius pm" : 154,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 23.7,
	            "specific_heat (@20°C J/g mol)" : 1.222,
	            "fusion_heat (kJ/mol)" : 2.64,
	            "evaporation_heat (kJ/mol)" : 97.9,
	            "thermal_conductivity (@25°C W/m K) " : 142.0,
	            "pauling_negativity" : 0.93,
	            "first_ionizing kJ/mol" : 495.6,
	            "oxidation_states" : 1,
	            "electronic_configuration" : "[Ne]3s¹",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 4.230
	        },
	        "Magnesium": {
	            "symbol" : "Mg",
	            "atomic_number" : 12,
	            "atomic_weight" : 24.305,
	            "density g/cm" : 1.738,
	            "melting_point K" : 922,
	            "boiling_point K" : 1363,
	            "atomic_radius pm" : 160,
	            "covalent_radius pm" : 136,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 14.0,
	            "specific_heat (@20°C J/g mol)" : 1.025,
	            "fusion_heat (kJ/mol)" : 9.20,
	            "evaporation_heat (kJ/mol)" : 131.8,
	            "thermal_conductivity (@25°C W/m K) " : 156,
	            "pauling_negativity" : 1.31,
	            "first_ionizing kJ/mol" : 737.3,
	            "oxidation_states" : 2,
	            "electronic_configuration" : "[Ne]3s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.210
	        },
	        "Aluminum": {
	            "symbol" : "Al",
	            "atomic_number" : 13,
	            "atomic_weight" : 26.981539,
	            "density g/cm" : 2.6989,
	            "melting_point K" : 933.5,
	            "boiling_point K" : 2740,
	            "atomic_radius pm" : 143,
	            "covalent_radius pm" : 118,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 10.0,
	            "specific_heat (@20°C J/g mol)" : 0.900,
	            "fusion_heat (kJ/mol)" : 10.75,
	            "evaporation_heat (kJ/mol)" : 284.1,
	            "thermal_conductivity (@25°C W/m K) " : 237,
	            "pauling_negativity" : 1.61,
	            "first_ionizing kJ/mol" : 577.2,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Ne]3s²3p¹",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 4.050
	        },
	        "Silicon": {
	            "symbol" : "Si",
	            "atomic_number" : 14,
	            "atomic_weight" : 28.0855,
	            "density g/cm" : 2.33,
	            "melting_point K" : 1683,
	            "boiling_point K" : 2628,
	            "atomic_radius pm" : 132,
	            "covalent_radius pm" : 111,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 12.1,
	            "specific_heat (@20°C J/g mol)" : 0.703,
	            "fusion_heat (kJ/mol)" : 50.6,
	            "evaporation_heat (kJ/mol)" : 383,
	            "thermal_conductivity (@25°C W/m K) " : 149,
	            "pauling_negativity" : 1.90,
	            "first_ionizing kJ/mol" : 786.0,
	            "oxidation_states" : "4, -4",
	            "electronic_configuration" : "[Ne]3s²3p²",
	            "lattice_structure" : "DIA",
	            "lattice_constant ang" : 5.430
	        },
	        "Phosphorus": {
	            "symbol" : "P",
	            "atomic_number" : 15,
	            "atomic_weight" : 30.973762,
	            "density g/cm" : "1.82 (white phosphorus)",
	            "melting_point K" : 317.3,
	            "boiling_point K" : 553,
	            "atomic_radius pm" : 128,
	            "covalent_radius pm" : 106,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 17.0,
	            "specific_heat (@20°C J/g mol)" : 0.757,
	            "fusion_heat (kJ/mol)" : 2.51,
	            "evaporation_heat (kJ/mol)" : 49.8,
	            "thermal_conductivity (@25°C W/m K) " : "(0.236)",
	            "pauling_negativity" : 2.19,
	            "first_ionizing kJ/mol" : 1011.2,
	            "oxidation_states" : "5, 3, -3",
	            "electronic_configuration" : "[Ne]3s²3p³",
	            "lattice_structure" : "CUB",
	            "lattice_constant ang" : 7.170
	        },
	        "Sulfur": {
	            "symbol" : "S",
	            "atomic_number" : 16,
	            "atomic_weight" : 32.066,
	            "density g/cm" : 2.070,
	            "melting_point K" : 386,
	            "boiling_point K" : 717.824,
	            "atomic_radius pm" : 127,
	            "covalent_radius pm" : 102,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 15.5,
	            "specific_heat (@20°C J/g mol)" : 0.732,
	            "fusion_heat (kJ/mol)" : 1.23,
	            "evaporation_heat (kJ/mol)" : 10.5,
	            "thermal_conductivity (@25°C W/m K) " : 0.27,
	            "pauling_negativity" : 2.58,
	            "first_ionizing kJ/mol" : 999.0,
	            "oxidation_states" : "6, 4, 2, -2",
	            "electronic_configuration" : "[Ne]3s²3p",
	            "lattice_structure" : "ORC",
	            "lattice_constant ang" : 10.470
	        },
	        "Chlorine": {
	            "symbol" : "Cl",
	            "atomic_number" : 17,
	            "atomic_weight" : 35.4527,
	            "density g/cm" : "1.56 (@ -33.6°C)",
	            "melting_point K" : 172.2,
	            "boiling_point K" : 238.6,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : 99,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 18.7,
	            "specific_heat (@20°C J/g mol)" : "0.477 (Cl-Cl)",
	            "fusion_heat (kJ/mol)" : "6.41 (Cl-Cl)",
	            "evaporation_heat (kJ/mol)" : "20.41 (Cl-Cl)",
	            "thermal_conductivity (@25°C W/m K) " : 0.009,
	            "pauling_negativity" : 3.16,
	            "first_ionizing kJ/mol" : 1254.9,
	            "oxidation_states" : "7, 5, 3, 1, -1",
	            "electronic_configuration" : "[Ne]3s²3p",
	            "lattice_structure" : "ORC",
	            "lattice_constant ang" : 6.240
	        },
	        "Argon": {
	            "symbol" : "Ar",
	            "atomic_number" : 18,
	            "atomic_weight" : 39.948,
	            "density g/cm" : "1.40 (@ -186°C)",
	            "melting_point K" : 83.8,
	            "boiling_point K" : 87.3,
	            "atomic_radius pm" : "2-",
	            "covalent_radius pm" : 98,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 24.2,
	            "specific_heat (@20°C J/g mol)" : 0.138,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 6.52,
	            "thermal_conductivity (@25°C W/m K) " : 0.0177,
	            "pauling_negativity" : 0.0,
	            "first_ionizing kJ/mol" : 1519.6,
	            "oxidation_states" : "-",
	            "electronic_configuration" : "[Ne]3s²3p",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 5.260
	        },
	        "Potassium": {
	            "symbol" : "K",
	            "atomic_number" : 19,
	            "atomic_weight" : 39.0983,
	            "density g/cm" : 0.856,
	            "melting_point K" : 336.8,
	            "boiling_point K" : 1047,
	            "atomic_radius pm" : 235,
	            "covalent_radius pm" : 203,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 45.3,
	            "specific_heat (@20°C J/g mol)" : 0.753,
	            "fusion_heat (kJ/mol)" : 102.5,
	            "evaporation_heat (kJ/mol)" : 2.33,
	            "thermal_conductivity (@25°C W/m K) " : 79.0,
	            "pauling_negativity" : 0.82,
	            "first_ionizing kJ/mol" : 418.5,
	            "oxidation_states" : 1,
	            "electronic_configuration" : "[Ar]4s¹",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 5.230
	        },
	        "Calcium": {
	            "symbol" : "Ca",
	            "atomic_number" : 20,
	            "atomic_weight" : 40.078,
	            "density g/cm" : 1.55,
	            "melting_point K" : 1112,
	            "boiling_point K" : 1757,
	            "atomic_radius pm" : 197,
	            "covalent_radius pm" : 174,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 29.9,
	            "specific_heat (@20°C J/g mol)" : 0.653,
	            "fusion_heat (kJ/mol)" : 9.20,
	            "evaporation_heat (kJ/mol)" : 153.6,
	            "thermal_conductivity (@25°C W/m K) " : "(201)",
	            "pauling_negativity" : 1.00,
	            "first_ionizing kJ/mol" : 589.4,
	            "oxidation_states" : 2,
	            "electronic_configuration" : "[Ar]4s²",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 5.580
	        },
	        "Scandium": {
	            "symbol" : "Sc",
	            "atomic_number" : 21,
	            "atomic_weight" : 44.95591,
	            "density g/cm" : 2.99,
	            "melting_point K" : 1814,
	            "boiling_point K" : 3104,
	            "atomic_radius pm" : 162,
	            "covalent_radius pm" : 144,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 15.0,
	            "specific_heat (@20°C J/g mol)" : 0.556,
	            "fusion_heat (kJ/mol)" : 15.8,
	            "evaporation_heat (kJ/mol)" : 332.7,
	            "thermal_conductivity (@25°C W/m K) " : 15.8,
	            "pauling_negativity" : 1.36,
	            "first_ionizing kJ/mol" : 630.8,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Ar]3d¹4s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.310
	        },
	        "Titanium": {
	            "symbol" : "Ti",
	            "atomic_number" : 22,
	            "atomic_weight" : 47.88,
	            "density g/cm" : 4.54,
	            "melting_point K" : 1933,
	            "boiling_point K" : 3560,
	            "atomic_radius pm" : 147,
	            "covalent_radius pm" : 132,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 10.6,
	            "specific_heat (@20°C J/g mol)" : 0.523,
	            "fusion_heat (kJ/mol)" : 18.8,
	            "evaporation_heat (kJ/mol)" : 422.6,
	            "thermal_conductivity (@25°C W/m K) " : 21.9,
	            "pauling_negativity" : 1.54,
	            "first_ionizing kJ/mol" : 657.8,
	            "oxidation_states" : "4, 3",
	            "electronic_configuration" : "[Ar]3d²4s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 2.950
	        },
	        "Vanadium": {
	            "symbol" : "V",
	            "atomic_number" : 23,
	            "atomic_weight" : 50.9415,
	            "density g/cm" : 6.11,
	            "melting_point K" : 2160,
	            "boiling_point K" : 3650,
	            "atomic_radius pm" : 134,
	            "covalent_radius pm" : 122,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 8.35,
	            "specific_heat (@20°C J/g mol)" : 0.485,
	            "fusion_heat (kJ/mol)" : 17.5,
	            "evaporation_heat (kJ/mol)" : 460,
	            "thermal_conductivity (@25°C W/m K) " : 30.7,
	            "pauling_negativity" : 1.63,
	            "first_ionizing kJ/mol" : 650.1,
	            "oxidation_states" : "5, 4, 3, 2, 0",
	            "electronic_configuration" : "[Ar]3d³4s²",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 3.020
	        },
	        "Chromium": {
	            "symbol" : "Cr",
	            "atomic_number" : 24,
	            "atomic_weight" : 51.9961,
	            "density g/cm" : 7.18,
	            "melting_point K" : 2130,
	            "boiling_point K" : 2945,
	            "atomic_radius pm" : 130,
	            "covalent_radius pm" : 118,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 7.23,
	            "specific_heat (@20°C J/g mol)" : 0.488,
	            "fusion_heat (kJ/mol)" : 21,
	            "evaporation_heat (kJ/mol)" : 342,
	            "thermal_conductivity (@25°C W/m K) " : 93.9,
	            "pauling_negativity" : 1.66,
	            "first_ionizing kJ/mol" : 652.4,
	            "oxidation_states" : "6, 3, 2, 0",
	            "electronic_configuration" : "[Ar]3d4s¹",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 2.880
	        },
	        "Manganese": {
	            "symbol" : "Mn",
	            "atomic_number" : 25,
	            "atomic_weight" : 54.93805,
	            "density g/cm" : 7.21,
	            "melting_point K" : 1517,
	            "boiling_point K" : 2235,
	            "atomic_radius pm" : 135,
	            "covalent_radius pm" : 117,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 7.39,
	            "specific_heat (@20°C J/g mol)" : 0.477,
	            "fusion_heat (kJ/mol)" : "(13.4)",
	            "evaporation_heat (kJ/mol)" : 221,
	            "thermal_conductivity (@25°C W/m K) " : "(7.8)",
	            "pauling_negativity" : 1.55,
	            "first_ionizing kJ/mol" : 716.8,
	            "oxidation_states" : "7, 6, 4, 3, 2, 0, -1",
	            "electronic_configuration" : "[Ar]3d4s²",
	            "lattice_structure" : "CUB",
	            "lattice_constant ang" : 8.890
	        },
	        "Iron": {
	            "symbol" : "Fe",
	            "atomic_number" : 26,
	            "atomic_weight" : 55.847,
	            "density g/cm" : 7.874,
	            "melting_point K" : 1808,
	            "boiling_point K" : 3023,
	            "atomic_radius pm" : 126,
	            "covalent_radius pm" : 117,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 7.1,
	            "specific_heat (@20°C J/g mol)" : 0.443,
	            "fusion_heat (kJ/mol)" : 13.8,
	            "evaporation_heat (kJ/mol)" : "~340",
	            "thermal_conductivity (@25°C W/m K) " : 80.4,
	            "pauling_negativity" : 1.83,
	            "first_ionizing kJ/mol" : 759.1,
	            "oxidation_states" : "6, 3, 2, 0, -2",
	            "electronic_configuration" : "[Ar]3d4s²",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 2.870
	        },
	        "Cobalt": {
	            "symbol" : "Co",
	            "atomic_number" : 27,
	            "atomic_weight" : 58.9332,
	            "density g/cm" : 8.9,
	            "melting_point K" : 1768,
	            "boiling_point K" : 3143,
	            "atomic_radius pm" : 125,
	            "covalent_radius pm" : 116,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 6.7,
	            "specific_heat (@20°C J/g mol)" : 0.456,
	            "fusion_heat (kJ/mol)" : 15.48,
	            "evaporation_heat (kJ/mol)" : 389.1,
	            "thermal_conductivity (@25°C W/m K) " : 100,
	            "pauling_negativity" : 1.88,
	            "first_ionizing kJ/mol" : 758.1,
	            "oxidation_states" : "3, 2, 0, -1",
	            "electronic_configuration" : "[Ar]3d4s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 2.510
	        },
	        "Nickel": {
	            "symbol" : "Ni",
	            "atomic_number" : 28,
	            "atomic_weight" : 58.6934,
	            "density g/cm" : 8.902,
	            "melting_point K" : 1726,
	            "boiling_point K" : 3005,
	            "atomic_radius pm" : 124,
	            "covalent_radius pm" : 115,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 6.6,
	            "specific_heat (@20°C J/g mol)" : 0.443,
	            "fusion_heat (kJ/mol)" : 17.61,
	            "evaporation_heat (kJ/mol)" : 378.6,
	            "thermal_conductivity (@25°C W/m K) " : 90.9,
	            "pauling_negativity" : 1.91,
	            "first_ionizing kJ/mol" : 736.2,
	            "oxidation_states" : "3, 2, 0",
	            "electronic_configuration" : "[Ar]3d4s²",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 3.520
	        },
	        "Copper": {
	            "symbol" : "Cu",
	            "atomic_number" : 29,
	            "atomic_weight" : 63.546,
	            "density g/cm" : 8.96,
	            "melting_point K" : 1356.6,
	            "boiling_point K" : 2840,
	            "atomic_radius pm" : 128,
	            "covalent_radius pm" : 117,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 7.1,
	            "specific_heat (@20°C J/g mol)" : 0.385,
	            "fusion_heat (kJ/mol)" : 13.01,
	            "evaporation_heat (kJ/mol)" : 304.6,
	            "thermal_conductivity (@25°C W/m K) " : 401,
	            "pauling_negativity" : 1.90,
	            "first_ionizing kJ/mol" : 745.0,
	            "oxidation_states" : "2, 1",
	            "electronic_configuration" : "[Ar]3d¹4s¹",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 3.610
	        },
	        "Zinc": {
	            "symbol" : "Zn",
	            "atomic_number" : 30,
	            "atomic_weight" : 65.39,
	            "density g/cm" : 7.133,
	            "melting_point K" : 692.73,
	            "boiling_point K" : 1180,
	            "atomic_radius pm" : 138,
	            "covalent_radius pm" : 125,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 9.2,
	            "specific_heat (@20°C J/g mol)" : 0.388,
	            "fusion_heat (kJ/mol)" : 7.28,
	            "evaporation_heat (kJ/mol)" : 114.8,
	            "thermal_conductivity (@25°C W/m K) " : 116,
	            "pauling_negativity" : 1.65,
	            "first_ionizing kJ/mol" : 905.8,
	            "oxidation_states" : 2,
	            "electronic_configuration" : "[Ar]3d¹4s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 2.660
	        },
	        "Gallium": {
	            "symbol" : "Ga",
	            "atomic_number" : 31,
	            "atomic_weight" : 69.723,
	            "density g/cm" : 5.91,
	            "melting_point K" : 302.93,
	            "boiling_point K" : 2676,
	            "atomic_radius pm" : 141,
	            "covalent_radius pm" : 126,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 11.8,
	            "specific_heat (@20°C J/g mol)" : 0.372,
	            "fusion_heat (kJ/mol)" : 5.59,
	            "evaporation_heat (kJ/mol)" : 270.3,
	            "thermal_conductivity (@25°C W/m K) " : 28.1,
	            "pauling_negativity" : 1.81,
	            "first_ionizing kJ/mol" : 578.7,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Ar]3d¹4s²4p¹",
	            "lattice_structure" : "ORC",
	            "lattice_constant ang" : 4.510
	        },
	        "Germanium": {
	            "symbol" : "Ge",
	            "atomic_number" : 32,
	            "atomic_weight" : 72.61,
	            "density g/cm" : 5.323,
	            "melting_point K" : 1210.6,
	            "boiling_point K" : 3103,
	            "atomic_radius pm" : 137,
	            "covalent_radius pm" : 122,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 13.6,
	            "specific_heat (@20°C J/g mol)" : 0.322,
	            "fusion_heat (kJ/mol)" : 36.8,
	            "evaporation_heat (kJ/mol)" : 328,
	            "thermal_conductivity (@25°C W/m K) " : 60.2,
	            "pauling_negativity" : 2.01,
	            "first_ionizing kJ/mol" : 760.0,
	            "oxidation_states" : 4,
	            "electronic_configuration" : "[Ar]3d¹4s²4p²",
	            "lattice_structure" : "DIA",
	            "lattice_constant ang" : 5.660
	        },
	        "Arsenic": {
	            "symbol" : "As",
	            "atomic_number" : 33,
	            "atomic_weight" : 74.92159,
	            "density g/cm" : "5.73 (grey arsenic)",
	            "melting_point K" : 1090,
	            "boiling_point K" : 876,
	            "atomic_radius pm" : 139,
	            "covalent_radius pm" : 120,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 13.1,
	            "specific_heat (@20°C J/g mol)" : 0.328,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 32.4,
	            "thermal_conductivity (@25°C W/m K) " : "(50.2)",
	            "pauling_negativity" : 2.18,
	            "first_ionizing kJ/mol" : 946.2,
	            "oxidation_states" : "5, 3, -2",
	            "electronic_configuration" : "[Ar]3d¹4s²4p³",
	            "lattice_structure" : "RHL",
	            "lattice_constant ang" : 4.130
	        },
	        "Selenium": {
	            "symbol" : "Se",
	            "atomic_number" : 34,
	            "atomic_weight" : 78.96,
	            "density g/cm" : 4.79,
	            "melting_point K" : 490,
	            "boiling_point K" : 958.1,
	            "atomic_radius pm" : 140,
	            "covalent_radius pm" : 116,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 16.5,
	            "specific_heat (@20°C J/g mol)" : "0.321 (Se-Se)",
	            "fusion_heat (kJ/mol)" : 5.23,
	            "evaporation_heat (kJ/mol)" : 59.7,
	            "thermal_conductivity (@25°C W/m K) " : 0.52,
	            "pauling_negativity" : 2.55,
	            "first_ionizing kJ/mol" : 940.4,
	            "oxidation_states" : "6, 4, -2",
	            "electronic_configuration" : "[Ar]3d¹4s²4p",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 4.360
	        },
	        "Bromine": {
	            "symbol" : "Br",
	            "atomic_number" : 35,
	            "atomic_weight" : 79.904,
	            "density g/cm" : 3.12,
	            "melting_point K" : 265.9,
	            "boiling_point K" : 331.9,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : 114,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 23.5,
	            "specific_heat (@20°C J/g mol)" : "0.473 (Br-Br)",
	            "fusion_heat (kJ/mol)" : "10.57 (Br-Br)",
	            "evaporation_heat (kJ/mol)" : "29.56 (Br-Br)",
	            "thermal_conductivity (@25°C W/m K) " : 0.005,
	            "pauling_negativity" : 2.96,
	            "first_ionizing kJ/mol" : 1142.0,
	            "oxidation_states" : "7, 5, 3, 1, -1",
	            "electronic_configuration" : "[Ar]3d¹4s²4p",
	            "lattice_structure" : "ORC",
	            "lattice_constant ang" : 6.670
	        },
	        "Krypton": {
	            "symbol" : "Kr",
	            "atomic_number" : 36,
	            "atomic_weight" : 83.8,
	            "density g/cm" : "2.155 (@ -153°C)",
	            "melting_point K" : 116.6,
	            "boiling_point K" : 120.85,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : 112,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 32.2,
	            "specific_heat (@20°C J/g mol)" : 0.247,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 9.05,
	            "thermal_conductivity (@25°C W/m K) " : 0.0095,
	            "pauling_negativity" : 0.0,
	            "first_ionizing kJ/mol" : 1350.0,
	            "oxidation_states" : 2,
	            "electronic_configuration" : "[Ar]3d¹4s²4p",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 5.720
	        },
	        "Rubidium": {
	            "symbol" : "Rb",
	            "atomic_number" : 37,
	            "atomic_weight" : 85.4678,
	            "density g/cm" : 1.532,
	            "melting_point K" : 312.2,
	            "boiling_point K" : 961,
	            "atomic_radius pm" : 248,
	            "covalent_radius pm" : 216,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 55.9,
	            "specific_heat (@20°C J/g mol)" : 0.360,
	            "fusion_heat (kJ/mol)" : 2.20,
	            "evaporation_heat (kJ/mol)" : 75.8,
	            "thermal_conductivity (@25°C W/m K) " : 58.2,
	            "pauling_negativity" : 0.82,
	            "first_ionizing kJ/mol" : 402.8,
	            "oxidation_states" : 1,
	            "electronic_configuration" : "[Kr]5s¹",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 5.590
	        },
	        "Strontium": {
	            "symbol" : "Sr",
	            "atomic_number" : 38,
	            "atomic_weight" : 87.62,
	            "density g/cm" : 2.54,
	            "melting_point K" : 1042,
	            "boiling_point K" : 1657,
	            "atomic_radius pm" : 215,
	            "covalent_radius pm" : 191,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 33.7,
	            "specific_heat (@20°C J/g mol)" : 0.301,
	            "fusion_heat (kJ/mol)" : 9.20,
	            "evaporation_heat (kJ/mol)" : 144,
	            "thermal_conductivity (@25°C W/m K) " : "(35.4)",
	            "pauling_negativity" : 0.95,
	            "first_ionizing kJ/mol" : 549.0,
	            "oxidation_states" : 2,
	            "electronic_configuration" : "[Kr]5s²",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 6.080
	        },
	        "Yttrium": {
	            "symbol" : "Y",
	            "atomic_number" : 39,
	            "atomic_weight" : 88.90585,
	            "density g/cm" : 4.47,
	            "melting_point K" : 1795,
	            "boiling_point K" : 3611,
	            "atomic_radius pm" : 178,
	            "covalent_radius pm" : 162,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 19.8,
	            "specific_heat (@20°C J/g mol)" : 0.284,
	            "fusion_heat (kJ/mol)" : 11.5,
	            "evaporation_heat (kJ/mol)" : 367,
	            "thermal_conductivity (@25°C W/m K) " : "(17.2)",
	            "pauling_negativity" : 1.22,
	            "first_ionizing kJ/mol" : 615.4,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Kr]4d¹5s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.650
	        },
	        "Zirconium": {
	            "symbol" : "Zr",
	            "atomic_number" : 40,
	            "atomic_weight" : 91.224,
	            "density g/cm" : 6.506,
	            "melting_point K" : 2125,
	            "boiling_point K" : 4650,
	            "atomic_radius pm" : 160,
	            "covalent_radius pm" : 145,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 14.1,
	            "specific_heat (@20°C J/g mol)" : 0.281,
	            "fusion_heat (kJ/mol)" : 19.2,
	            "evaporation_heat (kJ/mol)" : 567,
	            "thermal_conductivity (@25°C W/m K) " : 22.7,
	            "pauling_negativity" : 1.33,
	            "first_ionizing kJ/mol" : 659.7,
	            "oxidation_states" : 4,
	            "electronic_configuration" : "[Kr]4d²5s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.230
	        },
	        "Niobium": {
	            "symbol" : "Nb",
	            "atomic_number" : 41,
	            "atomic_weight" : 92.90638,
	            "density g/cm" : 8.57,
	            "melting_point K" : 2741,
	            "boiling_point K" : 5015,
	            "atomic_radius pm" : 146,
	            "covalent_radius pm" : 134,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 10.8,
	            "specific_heat (@20°C J/g mol)" : 0.268,
	            "fusion_heat (kJ/mol)" : 26.8,
	            "evaporation_heat (kJ/mol)" : 680,
	            "thermal_conductivity (@25°C W/m K) " : 53.7,
	            "pauling_negativity" : 1.6,
	            "first_ionizing kJ/mol" : 663.6,
	            "oxidation_states" : "5, 3",
	            "electronic_configuration" : "[Kr]4d5s¹",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 3.300
	        },
	        "Molybdenum": {
	            "symbol" : "Mo",
	            "atomic_number" : 42,
	            "atomic_weight" : 95.94,
	            "density g/cm" : 10.22,
	            "melting_point K" : 2890,
	            "boiling_point K" : 4885,
	            "atomic_radius pm" : 139,
	            "covalent_radius pm" : 130,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 9.4,
	            "specific_heat (@20°C J/g mol)" : 0.251,
	            "fusion_heat (kJ/mol)" : 28,
	            "evaporation_heat (kJ/mol)" : "~590",
	            "thermal_conductivity (@25°C W/m K) " : "(138)",
	            "pauling_negativity" : 2.16,
	            "first_ionizing kJ/mol" : 684.8,
	            "oxidation_states" : "6, 5, 4, 3, 2, 0",
	            "electronic_configuration" : "[Kr]4d5s¹",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 3.150
	        },
	        "Technetium": {
	            "symbol" : "Tc",
	            "atomic_number" : 43,
	            "atomic_weight" : 97.9072,
	            "density g/cm" : 11.5,
	            "melting_point K" : 2445,
	            "boiling_point K" : 5150,
	            "atomic_radius pm" : 136,
	            "covalent_radius pm" : 127,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 8.5,
	            "specific_heat (@20°C J/g mol)" : 0.243,
	            "fusion_heat (kJ/mol)" : 23.8,
	            "evaporation_heat (kJ/mol)" : 585,
	            "thermal_conductivity (@25°C W/m K) " : 50.6,
	            "pauling_negativity" : 1.9,
	            "first_ionizing kJ/mol" : 702.2,
	            "oxidation_states" : 7,
	            "electronic_configuration" : "[Kr]4d5s¹",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 2.740
	        },
	        "Ruthenium": {
	            "symbol" : "Ru",
	            "atomic_number" : 44,
	            "atomic_weight" : 101.07,
	            "density g/cm" : 12.41,
	            "melting_point K" : 2583,
	            "boiling_point K" : 4173,
	            "atomic_radius pm" : 134,
	            "covalent_radius pm" : 125,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 8.3,
	            "specific_heat (@20°C J/g mol)" : 0.238,
	            "fusion_heat (kJ/mol)" : "(25.5)",
	            "evaporation_heat (kJ/mol)" : "-",
	            "thermal_conductivity (@25°C W/m K) " : 117.0,
	            "pauling_negativity" : 2.2,
	            "first_ionizing kJ/mol" : 710.3,
	            "oxidation_states" : "8, 6, 4, 3, 2, 0, -2",
	            "electronic_configuration" : "[Kr]4d5s¹",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 2.700
	        },
	        "Rhodium": {
	            "symbol" : "Rh",
	            "atomic_number" : 45,
	            "atomic_weight" : 102.9055,
	            "density g/cm" : 12.41,
	            "melting_point K" : 2239,
	            "boiling_point K" : 4000,
	            "atomic_radius pm" : 134,
	            "covalent_radius pm" : 125,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 8.3,
	            "specific_heat (@20°C J/g mol)" : 0.244,
	            "fusion_heat (kJ/mol)" : 21.8,
	            "evaporation_heat (kJ/mol)" : 494,
	            "thermal_conductivity (@25°C W/m K) " : 150,
	            "pauling_negativity" : 2.28,
	            "first_ionizing kJ/mol" : 719.5,
	            "oxidation_states" : "5, 4, 3, 2, 1, 0",
	            "electronic_configuration" : "[Kr]4d5s¹",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 3.800
	        },
	        "Palladium": {
	            "symbol" : "Pd",
	            "atomic_number" : 46,
	            "atomic_weight" : 106.42,
	            "density g/cm" : 12.02,
	            "melting_point K" : 1825,
	            "boiling_point K" : 3413,
	            "atomic_radius pm" : 137,
	            "covalent_radius pm" : 128,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 8.9,
	            "specific_heat (@20°C J/g mol)" : 0.244,
	            "fusion_heat (kJ/mol)" : 17.24,
	            "evaporation_heat (kJ/mol)" : 372.4,
	            "thermal_conductivity (@25°C W/m K) " : 71.8,
	            "pauling_negativity" : 2.20,
	            "first_ionizing kJ/mol" : 803.5,
	            "oxidation_states" : "4, 2, 0",
	            "electronic_configuration" : "[Kr]4d5s",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 3.890
	        },
	        "Silver": {
	            "symbol" : "Ag",
	            "atomic_number" : 47,
	            "atomic_weight" : 107.8682,
	            "density g/cm" : 10.5,
	            "melting_point K" : 1235.1,
	            "boiling_point K" : 2485,
	            "atomic_radius pm" : 144,
	            "covalent_radius pm" : 134,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 10.3,
	            "specific_heat (@20°C J/g mol)" : 0.237,
	            "fusion_heat (kJ/mol)" : 11.95,
	            "evaporation_heat (kJ/mol)" : 254.1,
	            "thermal_conductivity (@25°C W/m K) " : 429,
	            "pauling_negativity" : 1.93,
	            "first_ionizing kJ/mol" : 730.5,
	            "oxidation_states" : "2, 1",
	            "electronic_configuration" : "[Kr]4d5s¹",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 4.090
	        },
	        "Cadmium": {
	            "symbol" : "Cd",
	            "atomic_number" : 48,
	            "atomic_weight" : 112.411,
	            "density g/cm" : 8.65,
	            "melting_point K" : 594.1,
	            "boiling_point K" : 1038,
	            "atomic_radius pm" : 154,
	            "covalent_radius pm" : 148,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 13.1,
	            "specific_heat (@20°C J/g mol)" : 0.232,
	            "fusion_heat (kJ/mol)" : 6.11,
	            "evaporation_heat (kJ/mol)" : 59.1,
	            "thermal_conductivity (@25°C W/m K) " : 96.9,
	            "pauling_negativity" : 1.69,
	            "first_ionizing kJ/mol" : 867.2,
	            "oxidation_states" : 2,
	            "electronic_configuration" : "[Kr]4d5s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 2.980
	        },
	        "Indium": {
	            "symbol" : "In",
	            "atomic_number" : 49,
	            "atomic_weight" : 114.818,
	            "density g/cm" : 7.31,
	            "melting_point K" : 429.32,
	            "boiling_point K" : 2353,
	            "atomic_radius pm" : 166,
	            "covalent_radius pm" : 144,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 15.7,
	            "specific_heat (@20°C J/g mol)" : 0.234,
	            "fusion_heat (kJ/mol)" : 3.24,
	            "evaporation_heat (kJ/mol)" : 225.1,
	            "thermal_conductivity (@25°C W/m K) " : 81.8,
	            "pauling_negativity" : 1.78,
	            "first_ionizing kJ/mol" : 558.0,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Kr]4d5s²5p¹",
	            "lattice_structure" : "TET",
	            "lattice_constant ang" : 4.590
	        },
	        "Tin": {
	            "symbol" : "Sn",
	            "atomic_number" : 50,
	            "atomic_weight" : 118.71,
	            "density g/cm" : 7.31,
	            "melting_point K" : 505.1,
	            "boiling_point K" : 2543,
	            "atomic_radius pm" : 162,
	            "covalent_radius pm" : 141,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 16.3,
	            "specific_heat (@20°C J/g mol)" : 0.222,
	            "fusion_heat (kJ/mol)" : 7.07,
	            "evaporation_heat (kJ/mol)" : 296,
	            "thermal_conductivity (@25°C W/m K) " : 66.8,
	            "pauling_negativity" : 1.96,
	            "first_ionizing kJ/mol" : 708.2,
	            "oxidation_states" : "4, 2",
	            "electronic_configuration" : "[Kr]4d5s²5p²",
	            "lattice_structure" : "TET",
	            "lattice_constant ang" : 5.820
	        },
	        "Antimony": {
	            "symbol" : "Sb",
	            "atomic_number" : 51,
	            "atomic_weight" : 121.760,
	            "density g/cm" : 6.691,
	            "melting_point K" : 903.9,
	            "boiling_point K" : 1908,
	            "atomic_radius pm" : 159,
	            "covalent_radius pm" : 140,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 18.4,
	            "specific_heat (@20°C J/g mol)" : 0.205,
	            "fusion_heat (kJ/mol)" : 20.08,
	            "evaporation_heat (kJ/mol)" : 195.2,
	            "thermal_conductivity (@25°C W/m K) " : 24.43,
	            "pauling_negativity" : 2.05,
	            "first_ionizing kJ/mol" : 833.3,
	            "oxidation_states" : "5, 3, -2",
	            "electronic_configuration" : "[Kr]4d5s²5p³",
	            "lattice_structure" : "RHL",
	            "lattice_constant ang" : 4.510
	        },
	        "Tellurium": {
	            "symbol" : "Te",
	            "atomic_number" : 52,
	            "atomic_weight" : 127.6,
	            "density g/cm" : 6.24,
	            "melting_point K" : 722.7,
	            "boiling_point K" : 1263,
	            "atomic_radius pm" : 160,
	            "covalent_radius pm" : 136,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 20.5,
	            "specific_heat (@20°C J/g mol)" : 0.201,
	            "fusion_heat (kJ/mol)" : 17.91,
	            "evaporation_heat (kJ/mol)" : 49.8,
	            "thermal_conductivity (@25°C W/m K) " : 14.3,
	            "pauling_negativity" : 2.1,
	            "first_ionizing kJ/mol" : 869.0,
	            "oxidation_states" : "6, 4, 2",
	            "electronic_configuration" : "[Kr]4d5s²5p",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 4.450
	        },
	        "Iodine": {
	            "symbol" : "I",
	            "atomic_number" : 53,
	            "atomic_weight" : 126.90447,
	            "density g/cm" : 4.93,
	            "melting_point K" : 386.7,
	            "boiling_point K" : 457.5,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : 133,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 25.7,
	            "specific_heat (@20°C J/g mol)" : "0.427 (I-I)",
	            "fusion_heat (kJ/mol)" : "15.52 (I-I)",
	            "evaporation_heat (kJ/mol)" : "41.95 (I-I)",
	            "thermal_conductivity (@25°C W/m K) " : "(0.45)",
	            "pauling_negativity" : 2.66,
	            "first_ionizing kJ/mol" : 1008.3,
	            "oxidation_states" : "7, 5, 1, -1",
	            "electronic_configuration" : "[Kr]4d5s²5p",
	            "lattice_structure" : "ORC",
	            "lattice_constant ang" : 7.720
	        },
	        "Xenon": {
	            "symbol" : "Xe",
	            "atomic_number" : 54,
	            "atomic_weight" : 131.29,
	            "density g/cm" : "3.52 (@ -109°C)",
	            "melting_point K" : 161.3,
	            "boiling_point K" : 166.1,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : 131,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 42.9,
	            "specific_heat (@20°C J/g mol)" : 0.158,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 12.65,
	            "thermal_conductivity (@25°C W/m K) " : 0.0057,
	            "pauling_negativity" : 0.0,
	            "first_ionizing kJ/mol" : 1170.0,
	            "oxidation_states" : 7,
	            "electronic_configuration" : "[Kr]4d5s²5p",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 6.200
	        },
	        "Cesium": {
	            "symbol" : "Cs",
	            "atomic_number" : 55,
	            "atomic_weight" : 132.90543,
	            "density g/cm" : 1.873,
	            "melting_point K" : 301.6,
	            "boiling_point K" : 951.6,
	            "atomic_radius pm" : 267,
	            "covalent_radius pm" : 235,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 70.0,
	            "specific_heat (@20°C J/g mol)" : 0.241,
	            "fusion_heat (kJ/mol)" : 2.09,
	            "evaporation_heat (kJ/mol)" : 68.3,
	            "thermal_conductivity (@25°C W/m K) " : 35.9,
	            "pauling_negativity" : 0.79,
	            "first_ionizing kJ/mol" : 375.5,
	            "oxidation_states" : 1,
	            "electronic_configuration" : "[Xe]6s¹",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 6.050
	        },
	        "Barium": {
	            "symbol" : "Ba",
	            "atomic_number" : 56,
	            "atomic_weight" : 137.327,
	            "density g/cm" : 3.5,
	            "melting_point K" : 1002,
	            "boiling_point K" : 1910,
	            "atomic_radius pm" : 222,
	            "covalent_radius pm" : 198,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 39.0,
	            "specific_heat (@20°C J/g mol)" : 0.192,
	            "fusion_heat (kJ/mol)" : 7.66,
	            "evaporation_heat (kJ/mol)" : 142.0,
	            "thermal_conductivity (@25°C W/m K) " : "(18.4)",
	            "pauling_negativity" : 0.89,
	            "first_ionizing kJ/mol" : 502.5,
	            "oxidation_states" : 2,
	            "electronic_configuration" : "[Xe]6s²",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 5.020
	        },
	        "Lanthanum": {
	            "symbol" : "La",
	            "atomic_number" : 57,
	            "atomic_weight" : 138.9055,
	            "density g/cm" : 6.15,
	            "melting_point K" : 1194,
	            "boiling_point K" : 3730,
	            "atomic_radius pm" : 187,
	            "covalent_radius pm" : 169,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 22.5,
	            "specific_heat (@20°C J/g mol)" : 0.197,
	            "fusion_heat (kJ/mol)" : 8.5,
	            "evaporation_heat (kJ/mol)" : 402,
	            "thermal_conductivity (@25°C W/m K) " : 13.4,
	            "pauling_negativity" : 1.10,
	            "first_ionizing kJ/mol" : 541.1,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Xe]6d¹6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.750
	        },
	        "Cerium": {
	            "symbol" : "Ce",
	            "atomic_number" : 58,
	            "atomic_weight" : 140.115,
	            "density g/cm" : 6.757,
	            "melting_point K" : 1072,
	            "boiling_point K" : 3699,
	            "atomic_radius pm" : 181,
	            "covalent_radius pm" : 165,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 21.0,
	            "specific_heat (@20°C J/g mol)" : 0.205,
	            "fusion_heat (kJ/mol)" : 5.2,
	            "evaporation_heat (kJ/mol)" : 398,
	            "thermal_conductivity (@25°C W/m K) " : 11.3,
	            "pauling_negativity" : 1.12,
	            "first_ionizing kJ/mol" : 540.1,
	            "oxidation_states" : "4, 3",
	            "electronic_configuration" : "[Xe]4f¹5d¹6s²",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 5.160
	        },
	        "Praseodymium": {
	            "symbol" : "Pr",
	            "atomic_number" : 59,
	            "atomic_weight" : 140.90765,
	            "density g/cm" : 6.773,
	            "melting_point K" : 1204,
	            "boiling_point K" : 3785,
	            "atomic_radius pm" : 182,
	            "covalent_radius pm" : 165,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 20.8,
	            "specific_heat (@20°C J/g mol)" : 0.192,
	            "fusion_heat (kJ/mol)" : 11.3,
	            "evaporation_heat (kJ/mol)" : 331,
	            "thermal_conductivity (@25°C W/m K) " : 12.5,
	            "pauling_negativity" : 1.13,
	            "first_ionizing kJ/mol" : 526.6,
	            "oxidation_states" : "4, 3",
	            "electronic_configuration" : "[Xe]4f³5d6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.670
	        },
	        "Neodymium": {
	            "symbol" : "Nd",
	            "atomic_number" : 60,
	            "atomic_weight" : 144.24,
	            "density g/cm" : 7.007,
	            "melting_point K" : 1294,
	            "boiling_point K" : 3341,
	            "atomic_radius pm" : 182,
	            "covalent_radius pm" : 184,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 20.6,
	            "specific_heat (@20°C J/g mol)" : 0.205,
	            "fusion_heat (kJ/mol)" : 7.1,
	            "evaporation_heat (kJ/mol)" : 289,
	            "thermal_conductivity (@25°C W/m K) " : "(16.5)",
	            "pauling_negativity" : 1.14,
	            "first_ionizing kJ/mol" : 531.5,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Xe]4f5d6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.660
	        },
	        "Promethium": {
	            "symbol" : "Pm",
	            "atomic_number" : 61,
	            "atomic_weight" : 144.9127,
	            "density g/cm" : 7.2,
	            "melting_point K" : 1441,
	            "boiling_point K" : 3000,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : 163,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "-",
	            "specific_heat (@20°C J/g mol)" : 0.185,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : "-",
	            "thermal_conductivity (@25°C W/m K) " : 17.9,
	            "pauling_negativity" : 0.0,
	            "first_ionizing kJ/mol" : 536,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Xe]4f5d6s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Samarium": {
	            "symbol" : "Sm",
	            "atomic_number" : 62,
	            "atomic_weight" : 150.36,
	            "density g/cm" : 7.520,
	            "melting_point K" : 1350,
	            "boiling_point K" : 2064,
	            "atomic_radius pm" : 181,
	            "covalent_radius pm" : 162,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 19.9,
	            "specific_heat (@20°C J/g mol)" : 0.180,
	            "fusion_heat (kJ/mol)" : 8.9,
	            "evaporation_heat (kJ/mol)" : 165,
	            "thermal_conductivity (@25°C W/m K) " : "(13.3)",
	            "pauling_negativity" : 1.17,
	            "first_ionizing kJ/mol" : 540.1,
	            "oxidation_states" : "3, 2",
	            "electronic_configuration" : "[Xe]4f5d6s²",
	            "lattice_structure" : "RHL",
	            "lattice_constant ang" : 9.000
	        },
	        "Europium": {
	            "symbol" : "Eu",
	            "atomic_number" : 63,
	            "atomic_weight" : 151.965,
	            "density g/cm" : 5.243,
	            "melting_point K" : 1095,
	            "boiling_point K" : 1870,
	            "atomic_radius pm" : 199,
	            "covalent_radius pm" : 185,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 28.9,
	            "specific_heat (@20°C J/g mol)" : 0.176,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 176,
	            "thermal_conductivity (@25°C W/m K) " : 13.9,
	            "pauling_negativity" : 0.0,
	            "first_ionizing kJ/mol" : 546.9,
	            "oxidation_states" : "3, 2",
	            "electronic_configuration" : "[Xe]4f5d6s²",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 4.610
	        },
	        "Gadolinium": {
	            "symbol" : "Gd",
	            "atomic_number" : 64,
	            "atomic_weight" : 157.25,
	            "density g/cm" : 7.900,
	            "melting_point K" : 1586,
	            "boiling_point K" : 3539,
	            "atomic_radius pm" : 179,
	            "covalent_radius pm" : 161,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 19.9,
	            "specific_heat (@20°C J/g mol)" : 0.230,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 398,
	            "thermal_conductivity (@25°C W/m K) " : "(10.5)",
	            "pauling_negativity" : 1.20,
	            "first_ionizing kJ/mol" : 594.2,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Xe]4f5d¹6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.640
	        },
	        "Terbium": {
	            "symbol" : "Tb",
	            "atomic_number" : 65,
	            "atomic_weight" : 158.92534,
	            "density g/cm" : 8.229,
	            "melting_point K" : 1629,
	            "boiling_point K" : 3296,
	            "atomic_radius pm" : 180,
	            "covalent_radius pm" : 159,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 19.2,
	            "specific_heat (@20°C J/g mol)" : 0.183,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 389,
	            "thermal_conductivity (@25°C W/m K) " : 11.1,
	            "pauling_negativity" : 1.2,
	            "first_ionizing kJ/mol" : 569,
	            "oxidation_states" : "4, 3",
	            "electronic_configuration" : "[Xe]4f5d6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.600
	        },
	        "Dysprosium": {
	            "symbol" : "Dy",
	            "atomic_number" : 66,
	            "atomic_weight" : 162.50,
	            "density g/cm" : 8.55,
	            "melting_point K" : 1685,
	            "boiling_point K" : 2835,
	            "atomic_radius pm" : 180,
	            "covalent_radius pm" : 159,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 19.0,
	            "specific_heat (@20°C J/g mol)" : 0.173,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 291,
	            "thermal_conductivity (@25°C W/m K) " : 10.7,
	            "pauling_negativity" : "-",
	            "first_ionizing kJ/mol" : 567,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Xe]4f5d6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.590
	        },
	        "Holmium": {
	            "symbol" : "Ho",
	            "atomic_number" : 67,
	            "atomic_weight" : 164.93032,
	            "density g/cm" : 8.795,
	            "melting_point K" : 1747,
	            "boiling_point K" : 2968,
	            "atomic_radius pm" : 179,
	            "covalent_radius pm" : 158,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 18.7,
	            "specific_heat (@20°C J/g mol)" : 0.164,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 301,
	            "thermal_conductivity (@25°C W/m K) " : "(16.2)",
	            "pauling_negativity" : 1.23,
	            "first_ionizing kJ/mol" : 574,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Xe]4f¹¹5d6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.580
	        },
	        "Erbium": {
	            "symbol" : "Er",
	            "atomic_number" : 68,
	            "atomic_weight" : 167.26,
	            "density g/cm" : 9.06,
	            "melting_point K" : 1802,
	            "boiling_point K" : 3136,
	            "atomic_radius pm" : 178,
	            "covalent_radius pm" : 157,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 18.4,
	            "specific_heat (@20°C J/g mol)" : 0.168,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 317,
	            "thermal_conductivity (@25°C W/m K) " : "(14.5)",
	            "pauling_negativity" : 1.24,
	            "first_ionizing kJ/mol" : 581,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Xe]4f¹²5d6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.560
	        },
	        "Thulium": {
	            "symbol" : "Tm",
	            "atomic_number" : 69,
	            "atomic_weight" : 168.93421,
	            "density g/cm" : 9.321,
	            "melting_point K" : 1818,
	            "boiling_point K" : 2220,
	            "atomic_radius pm" : 177,
	            "covalent_radius pm" : 156,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 18.1,
	            "specific_heat (@20°C J/g mol)" : 0.160,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 232,
	            "thermal_conductivity (@25°C W/m K) " : "(16.9)",
	            "pauling_negativity" : 1.25,
	            "first_ionizing kJ/mol" : 589,
	            "oxidation_states" : "3, 2",
	            "electronic_configuration" : "[Xe]4f¹³5d6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.540
	        },
	        "Ytterbium": {
	            "symbol" : "Yb",
	            "atomic_number" : 70,
	            "atomic_weight" : 173.04,
	            "density g/cm" : 6.9654,
	            "melting_point K" : 1097,
	            "boiling_point K" : 1466,
	            "atomic_radius pm" : 194,
	            "covalent_radius pm" : "-",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 24.8,
	            "specific_heat (@20°C J/g mol)" : 0.145,
	            "fusion_heat (kJ/mol)" : 3.35,
	            "evaporation_heat (kJ/mol)" : 159,
	            "thermal_conductivity (@25°C W/m K) " : "(34.9)",
	            "pauling_negativity" : 1.1,
	            "first_ionizing kJ/mol" : 603,
	            "oxidation_states" : "3, 2",
	            "electronic_configuration" : "[Xe]4f¹5d¹6s²",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 5.490
	        },
	        "Lutetium": {
	            "symbol" : "Lu",
	            "atomic_number" : 71,
	            "atomic_weight" : 174.967,
	            "density g/cm" : 9.8404,
	            "melting_point K" : 1936,
	            "boiling_point K" : 3668,
	            "atomic_radius pm" : 175,
	            "covalent_radius pm" : 156,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 17.8,
	            "specific_heat (@20°C J/g mol)" : 0.155,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 414,
	            "thermal_conductivity (@25°C W/m K) " : "(16.4)",
	            "pauling_negativity" : 1.27,
	            "first_ionizing kJ/mol" : 513,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Xe]4f¹5d¹6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.510
	        },
	        "Hafnium": {
	            "symbol" : "Hf",
	            "atomic_number" : 72,
	            "atomic_weight" : 178.49,
	            "density g/cm" : 13.31,
	            "melting_point K" : 2503,
	            "boiling_point K" : 5470,
	            "atomic_radius pm" : 167,
	            "covalent_radius pm" : 144,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 13.6,
	            "specific_heat (@20°C J/g mol)" : 0.146,
	            "fusion_heat (kJ/mol)" : "(25.1)",
	            "evaporation_heat (kJ/mol)" : 575,
	            "thermal_conductivity (@25°C W/m K) " : 23.0,
	            "pauling_negativity" : 1.3,
	            "first_ionizing kJ/mol" : 575.2,
	            "oxidation_states" : 4,
	            "electronic_configuration" : "[Xe]4f¹5d²6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.200
	        },
	        "Tantalum": {
	            "symbol" : "Ta",
	            "atomic_number" : 73,
	            "atomic_weight" : 180.9479,
	            "density g/cm" : 16.654,
	            "melting_point K" : 3269,
	            "boiling_point K" : 5698,
	            "atomic_radius pm" : 149,
	            "covalent_radius pm" : 134,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 10.9,
	            "specific_heat (@20°C J/g mol)" : 0.140,
	            "fusion_heat (kJ/mol)" : 24.7,
	            "evaporation_heat (kJ/mol)" : 758,
	            "thermal_conductivity (@25°C W/m K) " : 57.5,
	            "pauling_negativity" : 1.5,
	            "first_ionizing kJ/mol" : 760.1,
	            "oxidation_states" : 5,
	            "electronic_configuration" : "[Xe]4f¹5d³6s²",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 3.310
	        },
	        "Tungsten": {
	            "symbol" : "W",
	            "atomic_number" : 74,
	            "atomic_weight" : 183.84,
	            "density g/cm" : 19.3,
	            "melting_point K" : 3680,
	            "boiling_point K" : 5930,
	            "atomic_radius pm" : 141,
	            "covalent_radius pm" : 130,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 9.53,
	            "specific_heat (@20°C J/g mol)" : 0.133,
	            "fusion_heat (kJ/mol)" : "(35)",
	            "evaporation_heat (kJ/mol)" : 824,
	            "thermal_conductivity (@25°C W/m K) " : 173,
	            "pauling_negativity" : 1.7,
	            "first_ionizing kJ/mol" : 769.7,
	            "oxidation_states" : "6, 5, 4, 3, 2, 0",
	            "electronic_configuration" : "[Xe]4f¹5d6s²",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : 3.160
	        },
	        "Rhenium": {
	            "symbol" : "Re",
	            "atomic_number" : 75,
	            "atomic_weight" : 186.207,
	            "density g/cm" : 21.02,
	            "melting_point K" : 3453,
	            "boiling_point K" : 5900,
	            "atomic_radius pm" : 137,
	            "covalent_radius pm" : 128,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 8.85,
	            "specific_heat (@20°C J/g mol)" : 0.138,
	            "fusion_heat (kJ/mol)" : 34,
	            "evaporation_heat (kJ/mol)" : 704,
	            "thermal_conductivity (@25°C W/m K) " : 48.0,
	            "pauling_negativity" : 1.9,
	            "first_ionizing kJ/mol" : 759.1,
	            "oxidation_states" : "5, 4, 3, 2, -1",
	            "electronic_configuration" : "[Xe]4f¹5d6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 2.760
	        },
	        "Osmium": {
	            "symbol" : "Os",
	            "atomic_number" : 76,
	            "atomic_weight" : 190.23,
	            "density g/cm" : 22.57,
	            "melting_point K" : 3327,
	            "boiling_point K" : 5300,
	            "atomic_radius pm" : 135,
	            "covalent_radius pm" : 126,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 8.43,
	            "specific_heat (@20°C J/g mol)" : 0.131,
	            "fusion_heat (kJ/mol)" : 31.7,
	            "evaporation_heat (kJ/mol)" : 738,
	            "thermal_conductivity (@25°C W/m K) " : "(87.6)",
	            "pauling_negativity" : 2.2,
	            "first_ionizing kJ/mol" : 819.8,
	            "oxidation_states" : "8, 6, 4, 3, 2, 0, -2",
	            "electronic_configuration" : "[Xe]4f¹5d6s²",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 2.740
	        },
	        "Iridium": {
	            "symbol" : "Ir",
	            "atomic_number" : 77,
	            "atomic_weight" : 192.22,
	            "density g/cm" : 22.42,
	            "melting_point K" : 2683,
	            "boiling_point K" : 4403,
	            "atomic_radius pm" : 136,
	            "covalent_radius pm" : 127,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 8.54,
	            "specific_heat (@20°C J/g mol)" : 0.133,
	            "fusion_heat (kJ/mol)" : 27.61,
	            "evaporation_heat (kJ/mol)" : 604,
	            "thermal_conductivity (@25°C W/m K) " : 147,
	            "pauling_negativity" : 2.20,
	            "first_ionizing kJ/mol" : 868.1,
	            "oxidation_states" : "6, 4, 3, 2, 1, 0, -1",
	            "electronic_configuration" : "[Xe]4f¹5d6s²",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 3.840
	        },
	        "Platinum": {
	            "symbol" : "Pt",
	            "atomic_number" : 78,
	            "atomic_weight" : 195.08,
	            "density g/cm" : 21.45,
	            "melting_point K" : 2045,
	            "boiling_point K" : 4100,
	            "atomic_radius pm" : 139,
	            "covalent_radius pm" : 130,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 9.10,
	            "specific_heat (@20°C J/g mol)" : 0.133,
	            "fusion_heat (kJ/mol)" : 21.76,
	            "evaporation_heat (kJ/mol)" : "~470",
	            "thermal_conductivity (@25°C W/m K) " : 71.6,
	            "pauling_negativity" : 2.28,
	            "first_ionizing kJ/mol" : 868.1,
	            "oxidation_states" : "4, 2, 0",
	            "electronic_configuration" : "[Xe]4f¹5d6s²",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 3.920
	        },
	        "Gold": {
	            "symbol" : "Au",
	            "atomic_number" : 79,
	            "atomic_weight" : 196.96654,
	            "density g/cm" : 19.3,
	            "melting_point K" : 1337.58,
	            "boiling_point K" : 3080,
	            "atomic_radius pm" : 146,
	            "covalent_radius pm" : 134,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 10.2,
	            "specific_heat (@20°C J/g mol)" : 0.129,
	            "fusion_heat (kJ/mol)" : 12.68,
	            "evaporation_heat (kJ/mol)" : "~340",
	            "thermal_conductivity (@25°C W/m K) " : 318,
	            "pauling_negativity" : 2.54,
	            "first_ionizing kJ/mol" : 889.3,
	            "oxidation_states" : "3, 1",
	            "electronic_configuration" : "[Xe]4f¹5d¹6s²",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 4.080
	        },
	        "Mercury": {
	            "symbol" : "Hg",
	            "atomic_number" : 80,
	            "atomic_weight" : 200.59,
	            "density g/cm" : "13.546 (@ +20°C)",
	            "melting_point K" : 234.28,
	            "boiling_point K" : 629.73,
	            "atomic_radius pm" : 157,
	            "covalent_radius pm" : 149,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 14.8,
	            "specific_heat (@20°C J/g mol)" : 0.138,
	            "fusion_heat (kJ/mol)" : 2.295,
	            "evaporation_heat (kJ/mol)" : 58.5,
	            "thermal_conductivity (@25°C W/m K) " : 8.3,
	            "pauling_negativity" : 2.00,
	            "first_ionizing kJ/mol" : 1006.0,
	            "oxidation_states" : "2, 1",
	            "electronic_configuration" : "[Xe]4f¹5d¹6s²",
	            "lattice_structure" : "RHL",
	            "lattice_constant ang" : 2.990
	        },
	        "Thallium": {
	            "symbol" : "Tl",
	            "atomic_number" : 81,
	            "atomic_weight" : 204.3833,
	            "density g/cm" : 11.85,
	            "melting_point K" : 576.6,
	            "boiling_point K" : 1730,
	            "atomic_radius pm" : 171,
	            "covalent_radius pm" : 148,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 17.2,
	            "specific_heat (@20°C J/g mol)" : 0.128,
	            "fusion_heat (kJ/mol)" : 4.31,
	            "evaporation_heat (kJ/mol)" : 162.4,
	            "thermal_conductivity (@25°C W/m K) " : 46.1,
	            "pauling_negativity" : 1.62,
	            "first_ionizing kJ/mol" : 588.9,
	            "oxidation_states" : "3, 1",
	            "electronic_configuration" : "[Xe]4f¹5d¹6s²6p¹",
	            "lattice_structure" : "HEX",
	            "lattice_constant ang" : 3.460
	        },
	        "Lead": {
	            "symbol" : "Pb",
	            "atomic_number" : 82,
	            "atomic_weight" : 207.2,
	            "density g/cm" : 11.35,
	            "melting_point K" : 600.65,
	            "boiling_point K" : 2013,
	            "atomic_radius pm" : 175,
	            "covalent_radius pm" : 147,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 18.3,
	            "specific_heat (@20°C J/g mol)" : 0.159,
	            "fusion_heat (kJ/mol)" : 4.77,
	            "evaporation_heat (kJ/mol)" : 177.8,
	            "thermal_conductivity (@25°C W/m K) " : 35.3,
	            "pauling_negativity" : 1.8,
	            "first_ionizing kJ/mol" : 715.2,
	            "oxidation_states" : "4, 2",
	            "electronic_configuration" : "[Xe]4f¹5d¹6s²6p²",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 4.950
	        },
	        "Bismuth": {
	            "symbol" : "Bi",
	            "atomic_number" : 83,
	            "atomic_weight" : 208.98037,
	            "density g/cm" : 9.747,
	            "melting_point K" : 544.5,
	            "boiling_point K" : 1883,
	            "atomic_radius pm" : 170,
	            "covalent_radius pm" : 146,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 21.3,
	            "specific_heat (@20°C J/g mol)" : 0.124,
	            "fusion_heat (kJ/mol)" : 11.00,
	            "evaporation_heat (kJ/mol)" : 172.0,
	            "thermal_conductivity (@25°C W/m K) " : 7.9,
	            "pauling_negativity" : 2.02,
	            "first_ionizing kJ/mol" : 702.9,
	            "oxidation_states" : "5, 3",
	            "electronic_configuration" : "[Xe]4f¹5d¹6s²6p³",
	            "lattice_structure" : "RHL",
	            "lattice_constant ang" : 4.750
	        },
	        "Polonium": {
	            "symbol" : "Po",
	            "atomic_number" : 84,
	            "atomic_weight" : 208.9824,
	            "density g/cm" : 9.32,
	            "melting_point K" : 527,
	            "boiling_point K" : 1235,
	            "atomic_radius pm" : 176,
	            "covalent_radius pm" : 146,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 22.7,
	            "specific_heat (@20°C J/g mol)" : 0.125,
	            "fusion_heat (kJ/mol)" : "(10)",
	            "evaporation_heat (kJ/mol)" : "(102.9)",
	            "thermal_conductivity (@25°C W/m K) " : "-",
	            "pauling_negativity" : 2.0,
	            "first_ionizing kJ/mol" : 813.1,
	            "oxidation_states" : "6, 4, 2",
	            "electronic_configuration" : "[Xe]4f¹5d¹6s²6p",
	            "lattice_structure" : "SC",
	            "lattice_constant ang" : 3.350
	        },
	        "Astatine": {
	            "symbol" : "At",
	            "atomic_number" : 85,
	            "atomic_weight" : 209.9871,
	            "density g/cm" : "n/a",
	            "melting_point K" : 575,
	            "boiling_point K" : 610,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : "(145)",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "-",
	            "specific_heat (@20°C J/g mol)" : "-",
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : "-",
	            "thermal_conductivity (@25°C W/m K) " : "-",
	            "pauling_negativity" : 2.2,
	            "first_ionizing kJ/mol" : 916.3,
	            "oxidation_states" : "7, 5, 3, 1, -1",
	            "electronic_configuration" : "[Xe]4f¹5d¹6s²6p",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Radon": {
	            "symbol" : "Rn",
	            "atomic_number" : 86,
	            "atomic_weight" : 222.0176,
	            "density g/cm" : "4.4 (@ -62°C)",
	            "melting_point K" : 202,
	            "boiling_point K" : 211.4,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : "-",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "-",
	            "specific_heat (@20°C J/g mol)" : 0.094,
	            "fusion_heat (kJ/mol)" : "-",
	            "evaporation_heat (kJ/mol)" : 18.1,
	            "thermal_conductivity (@25°C W/m K) " : 0.0036,
	            "pauling_negativity" : "-",
	            "first_ionizing kJ/mol" : 1036.5,
	            "oxidation_states" : "-",
	            "electronic_configuration" : "[Xe]4f¹5d¹6s²6p",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : "n/a"
	        },
	        "Francium": {
	            "symbol" : "Fr",
	            "atomic_number" : 87,
	            "atomic_weight" : 223.0197,
	            "density g/cm" : "n/a",
	            "melting_point K" : 300,
	            "boiling_point K" : 950,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : "-",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "-",
	            "specific_heat (@20°C J/g mol)" : "-",
	            "fusion_heat (kJ/mol)" : 15,
	            "evaporation_heat (kJ/mol)" : "-",
	            "thermal_conductivity (@25°C W/m K) " : "-",
	            "pauling_negativity" : 0.7,
	            "first_ionizing kJ/mol" : "~375",
	            "oxidation_states" : 2,
	            "electronic_configuration" : "[Rn]7s¹",
	            "lattice_structure" : "BCC",
	            "lattice_constant ang" : "n/a"
	        },
	        "Radium": {
	            "symbol" : "Ra",
	            "atomic_number" : 88,
	            "atomic_weight" : 226.0254,
	            "density g/cm" : "(5.5)",
	            "melting_point K" : 973,
	            "boiling_point K" : 1413,
	            "atomic_radius pm" : "-",
	            "covalent_radius pm" : "-",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 45.0,
	            "specific_heat (@20°C J/g mol)" : 0.120,
	            "fusion_heat (kJ/mol)" : "(9.6)",
	            "evaporation_heat (kJ/mol)" : "(113)",
	            "thermal_conductivity (@25°C W/m K) " : "(18.6)",
	            "pauling_negativity" : 0.9,
	            "first_ionizing kJ/mol" : 509.0,
	            "oxidation_states" : 2,
	            "electronic_configuration" : "[Rn]7s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Actinium": {
	            "symbol" : "Ac",
	            "atomic_number" : 89,
	            "atomic_weight" : 227.0278,
	            "density g/cm" : "n/a",
	            "melting_point K" : 1320,
	            "boiling_point K" : 3470,
	            "atomic_radius pm" : 188,
	            "covalent_radius pm" : "-",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 22.54,
	            "specific_heat (@20°C J/g mol)" : "-",
	            "fusion_heat (kJ/mol)" : "(10.5)",
	            "evaporation_heat (kJ/mol)" : "(292.9)",
	            "thermal_conductivity (@25°C W/m K) " : "-",
	            "pauling_negativity" : 1.1,
	            "first_ionizing kJ/mol" : 665.5,
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Rn]6d¹7s²",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 5.310
	        },
	        "Thorium": {
	            "symbol" : "Th",
	            "atomic_number" : 90,
	            "atomic_weight" : 232.0381,
	            "density g/cm" : 11.78,
	            "melting_point K" : 2028,
	            "boiling_point K" : 5060,
	            "atomic_radius pm" : 180,
	            "covalent_radius pm" : 165,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 19.8,
	            "specific_heat (@20°C J/g mol)" : 0.113,
	            "fusion_heat (kJ/mol)" : 16.11,
	            "evaporation_heat (kJ/mol)" : 513.7,
	            "thermal_conductivity (@25°C W/m K) " : "(54.0)",
	            "pauling_negativity" : 1.3,
	            "first_ionizing kJ/mol" : 670.4,
	            "oxidation_states" : 4,
	            "electronic_configuration" : "[Rn]5f6d¹7s²",
	            "lattice_structure" : "FCC",
	            "lattice_constant ang" : 5.080
	        },
	        "Protactinium": {
	            "symbol" : "Pa",
	            "atomic_number" : 91,
	            "atomic_weight" : 231.03588,
	            "density g/cm" : 15.37,
	            "melting_point K" : 2113,
	            "boiling_point K" : 4300,
	            "atomic_radius pm" : 161,
	            "covalent_radius pm" : "-",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 15.0,
	            "specific_heat (@20°C J/g mol)" : 0.121,
	            "fusion_heat (kJ/mol)" : 16.7,
	            "evaporation_heat (kJ/mol)" : 481.2,
	            "thermal_conductivity (@25°C W/m K) " : "-",
	            "pauling_negativity" : 1.5,
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "5, 4",
	            "electronic_configuration" : "[Rn]5f²6d¹7s²",
	            "lattice_structure" : "TET",
	            "lattice_constant ang" : 3.920
	        },
	        "Uranium": {
	            "symbol" : "U",
	            "atomic_number" : 92,
	            "atomic_weight" : 238.0289,
	            "density g/cm" : 19.05,
	            "melting_point K" : 1405.5,
	            "boiling_point K" : 4018,
	            "atomic_radius pm" : 138,
	            "covalent_radius pm" : 142,
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 12.5,
	            "specific_heat (@20°C J/g mol)" : 0.115,
	            "fusion_heat (kJ/mol)" : 12.6,
	            "evaporation_heat (kJ/mol)" : 417,
	            "thermal_conductivity (@25°C W/m K) " : 27.5,
	            "pauling_negativity" : 1.38,
	            "first_ionizing kJ/mol" : 686.4,
	            "oxidation_states" : "6, 5, 4, 3",
	            "electronic_configuration" : "[Rn]5f³6d¹7s²",
	            "lattice_structure" : "ORC",
	            "lattice_constant ang" : 2.850
	        },
	        "Neptunium": {
	            "symbol" : "Np",
	            "atomic_number" : 93,
	            "atomic_weight" : 237.048,
	            "density g/cm" : 20.25,
	            "melting_point K" : 913,
	            "boiling_point K" : 4175,
	            "atomic_radius pm" : 130,
	            "covalent_radius pm" : "-",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 21.1,
	            "specific_heat (@20°C J/g mol)" : "-",
	            "fusion_heat (kJ/mol)" : "(9.6)",
	            "evaporation_heat (kJ/mol)" : 336,
	            "thermal_conductivity (@25°C W/m K) " : "(6.3)",
	            "pauling_negativity" : 1.36,
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "6, 5, 4, 3",
	            "electronic_configuration" : "[Rn]5f6d¹7s²",
	            "lattice_structure" : "ORC",
	            "lattice_constant ang" : 4.720
	        },
	        "Plutonium": {
	            "symbol" : "Pu",
	            "atomic_number" : 94,
	            "atomic_weight" : 244.0642,
	            "density g/cm" : 19.84,
	            "melting_point K" : 914,
	            "boiling_point K" : 3505,
	            "atomic_radius pm" : 151,
	            "covalent_radius pm" : "-",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "-",
	            "specific_heat (@20°C J/g mol)" : "-",
	            "fusion_heat (kJ/mol)" : 2.8,
	            "evaporation_heat (kJ/mol)" : 343.5,
	            "thermal_conductivity (@25°C W/m K) " : "(6.7)",
	            "pauling_negativity" : 1.28,
	            "first_ionizing kJ/mol" : 491.9,
	            "oxidation_states" : "6, 5, 4, 3",
	            "electronic_configuration" : "[Rn]5f6d7s²",
	            "lattice_structure" : "MCL",
	            "lattice_constant ang" : "n/a"
	        },
	        "Americium": {
	            "symbol" : "Am",
	            "atomic_number" : 95,
	            "atomic_weight" : 243.0614,
	            "density g/cm" : 13.67,
	            "melting_point K" : 1267,
	            "boiling_point K" : 2880,
	            "atomic_radius pm" : 173,
	            "covalent_radius pm" : "-",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 20.8,
	            "specific_heat (@20°C J/g mol)" : "-",
	            "fusion_heat (kJ/mol)" : "(10.0)",
	            "evaporation_heat (kJ/mol)" : 238.5,
	            "thermal_conductivity (@25°C W/m K) " : "-",
	            "pauling_negativity" : 1.3,
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "6, 5, 4, 3",
	            "electronic_configuration" : "[Rn]5f6d7s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Curium": {
	            "symbol" : "Cm",
	            "atomic_number" : 96,
	            "atomic_weight" : 247.0703,
	            "density g/cm" : 13.51,
	            "melting_point K" : 1340,
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : 299,
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : 18.28,
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : 1.3,
	            "first_ionizing kJ/mol" : "(580)",
	            "oxidation_states" : "4, 3",
	            "electronic_configuration" : "[Rn]5f6d¹7s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/A"
	        },
	        "Berkelium": {
	            "symbol" : "Bk",
	            "atomic_number" : 97,
	            "atomic_weight" : 247.0703,
	            "density g/cm" : 13.25,
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : 297,
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : 1.3,
	            "first_ionizing kJ/mol" : "(600)",
	            "oxidation_states" : "4, 3",
	            "electronic_configuration" : "[Rn]5f6d7s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Californium": {
	            "symbol" : "Cf",
	            "atomic_number" : 98,
	            "atomic_weight" : 251.0796,
	            "density g/cm" : 15.1,
	            "melting_point K" : 900,
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : 295,
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : 1.3,
	            "first_ionizing kJ/mol" : "(610)",
	            "oxidation_states" : "4, 3",
	            "electronic_configuration" : "[Rn]5f¹6d7s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Einsteinium": {
	            "symbol" : "Es",
	            "atomic_number" : 99,
	            "atomic_weight" : 252.083,
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : 1130,
	            "atomic_radius pm" : 292,
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : 1.3,
	            "first_ionizing kJ/mol" : "(620)",
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Rn]5f¹¹6d7s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Fermium": {
	            "symbol" : "Fm",
	            "atomic_number" : 100,
	            "atomic_weight" : 257.0951,
	            "density g/cm" : "n/a",
	            "melting_point K" : 1800,
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : 290,
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : 1.3,
	            "first_ionizing kJ/mol" : "(630)",
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Rn]5f¹²6d7s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Mendelevium": {
	            "symbol" : "Md",
	            "atomic_number" : 101,
	            "atomic_weight" : 258.1,
	            "density g/cm" : "n/a",
	            "melting_point K" : 1100,
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : 287,
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : 1.3,
	            "first_ionizing kJ/mol" : "(635)",
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Rn]5f¹³6d7s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Nobelium": {
	            "symbol" : "No",
	            "atomic_number" : 102,
	            "atomic_weight" : 259.1009,
	            "density g/cm" : "n/a",
	            "melting_point K" : 1100,
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : 285,
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : 1.3,
	            "first_ionizing kJ/mol" : "(640)",
	            "oxidation_states" : "3,2",
	            "electronic_configuration" : "[Rn]5f¹6d7s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Lawrencium": {
	            "symbol" : "Lr",
	            "atomic_number" : 103,
	            "atomic_weight" : 262.11,
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : 282,
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : 3,
	            "electronic_configuration" : "[Rn]5f¹6d¹7s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Rutherfordium": {
	            "symbol" : "Rf",
	            "atomic_number" : 104,
	            "atomic_weight" : "[261]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "-",
	            "electronic_configuration" : "[Rn]5f¹6d²7s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Dubnium": {
	            "symbol" : "Db",
	            "atomic_number" : 105,
	            "atomic_weight" : "[262]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "-",
	            "electronic_configuration" : "[Rn]5f¹6d³6s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Seaborgium": {
	            "symbol" : "Sg",
	            "atomic_number" : 106,
	            "atomic_weight" : "[266]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "-",
	            "electronic_configuration" : "[Rn]5f¹6d¹7s²",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Bohrium": {
	            "symbol" : "Bh",
	            "atomic_number" : 107,
	            "atomic_weight" : "[264]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "n/a",
	            "electronic_configuration" : "n/a",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Hassium": {
	            "symbol" : "Hs",
	            "atomic_number" : 108,
	            "atomic_weight" : "[269]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "n/a",
	            "electronic_configuration" : "n/a",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Meitnerium": {
	            "symbol" : "Mt",
	            "atomic_number" : 109,
	            "atomic_weight" : "[278]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "n/a",
	            "electronic_configuration" : "n/a",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Darmstadtium": {
	            "symbol" : "Ds",
	            "atomic_number" : 110,
	            "atomic_weight" : "[281]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "n/a",
	            "electronic_configuration" : "n/a",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Roentgenium": {
	            "symbol" : "Rg",
	            "atomic_number" : 111,
	            "atomic_weight" : "[281]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "n/a",
	            "electronic_configuration" : "n/a",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Copernicium": {
	            "symbol" : "Cn",
	            "atomic_number" : 112,
	            "atomic_weight" : "[285]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "n/a",
	            "electronic_configuration" : "n/a",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Ununtrium": {
	            "symbol" : "Uut",
	            "atomic_number" : 113,
	            "atomic_weight" : "[286]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "n/a",
	            "electronic_configuration" : "n/a",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Flerovium": {
	            "symbol" : "Fl",
	            "atomic_number" : 114,
	            "atomic_weight" : "[289]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "n/a",
	            "electronic_configuration" : "n/a",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Ununpentium": {
	            "symbol" : "Uup",
	            "atomic_number" : 115,
	            "atomic_weight" : "[289]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "n/a",
	            "electronic_configuration" : "n/a",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Livermorium": {
	            "symbol" : "Lv",
	            "atomic_number" : 116,
	            "atomic_weight" : "[293]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "n/a",
	            "electronic_configuration" : "n/a",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Ununseptium": {
	            "symbol" : "Uus",
	            "atomic_number" : 117,
	            "atomic_weight" : "[294]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "n/a",
	            "electronic_configuration" : "n/a",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        },
	        "Ununoctium": {
	            "symbol" : "Uuo",
	            "atomic_number" : 118,
	            "atomic_weight" : "[294]",
	            "density g/cm" : "n/a",
	            "melting_point K" : "n/a",
	            "boiling_point K" : "n/a",
	            "atomic_radius pm" : "n/a",
	            "covalent_radius pm" : "n/a",
	            "ionic_radius pm" : "",
	            "atomic_volume cm3/mol" : "n/a",
	            "specific_heat (@20°C J/g mol)" : "n/a",
	            "fusion_heat (kJ/mol)" : "n/a",
	            "evaporation_heat (kJ/mol)" : "n/a",
	            "thermal_conductivity (@25°C W/m K) " : "n/a",
	            "pauling_negativity" : "n/a",
	            "first_ionizing kJ/mol" : "n/a",
	            "oxidation_states" : "n/a",
	            "electronic_configuration" : "n/a",
	            "lattice_structure" : "n/a",
	            "lattice_constant ang" : "n/a"
	        }
	    };

	    var periodicTable = $("<div>").appendTo("body");
	    periodicTable.attr("title", $._("Periodic table of the elements"));
	    periodicTable.dialog({
	        autoOpen: false,
	        show: "fade",
	        hide: "fade",
	        modal: "true",
	        width: 900
	    });
	    // Disable the scratchpad so people don't try drawing on top of the "show
	    // periodic table" button instead of clicking it.
	    Khan.scratchpad.disable();
	    $("#show-periodic-table").on("click", function() {
	        periodicTable.dialog("open");
	        return false;
	    });


	    var table = $("<table>").appendTo(periodicTable);
	    table.addClass("periodic-table");

	    var layout = [
	        [ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2],
	        [ 3,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  6,  7,  8,  9, 10],
	        [11, 12,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 13, 14, 15, 16, 17, 18],
	        [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
	        [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54],
	        [55, 56, 57, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86],
	        [87, 88, 89, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118],
	        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
	        [ 0,  0,  0, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,  0],
	        [ 0,  0,  0, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 0]];

	    _.each(layout, function(row) {
	        var tr = $("<tr>").appendTo(table);
	        _.each(row, function(atomicNum) {
	            var td = $("<td>").appendTo(tr);
	            if (atomicNum !== 0) {
	                td.addClass("element");
	                var element = _.find(elements, function(element) { return element.atomic_number === atomicNum; });
	                var weight = isNaN(element.atomic_weight) ? element.atomic_weight : KhanUtil.localeToFixed(element.atomic_weight, 2);
	                $("<div>").appendTo(td).text(atomicNum).addClass("atomic-num");
	                $("<div>").appendTo(td).text(element.symbol).addClass("symbol");
	                $("<div>").appendTo(td).text(weight).addClass("weight");
	            }
	        });
	    });

	    $.extend(KhanUtil, {
	        molarMass: function(symbol) {
	            var element = _.find(elements, function(element) { return element.symbol === symbol; });
	            return KhanUtil.roundTo(2, element.atomic_weight);
	        }
	    });
	};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {

	    /* A set of cipher messages to diversify exercises */
	    getCipherMessage: function(num) {
	        return [
	            $._("I have learned all kinds of different things from using Khan Academy"),
	            $._("The world is filled with secrets and mysteries just waiting to be discovered"),
	            $._("When a message contains a single character by itself, it is most likely either the letter i or a"),
	            $._("Words which have repeating letters like too and all can also give a hint to what the secret message is"),
	            $._("You have just cracked a Caesar cipher and obtained the title of code breaker")
	        ][num - 1];
	    },

	    /* Apply caesar shift to a string, and returns the encoded message */
	    applyCaesar: function(msg, shift) {

	        var cipher = "",
	            lc = "abcdefghijklmnopqrstuvwxyz",
	            uc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

	        for (var i = 0, len = msg.length; i < len; i++) {
	            if (msg[i] >= "a" && msg[i] <= "z") {
	                cipher = cipher + lc[(lc.indexOf(msg[i]) + shift) % 26];
	            }
	            else if (msg[i] >= "A" && msg[i] <= "Z") {
	                cipher = cipher + uc[(uc.indexOf(msg[i]) + shift) % 26];
	            }
	            else {
	                cipher = cipher + msg[i];
	            }
	        }

	        return cipher;
	    },

	    /* Apply Vigenere cipher shift to a string, and returns the encoded message */
	    applyVigenere: function(msg, key) {

	        var cipher = "",
	            shift = 0,
	            count = 0,  // Don't count spaces when iterating the key word
	            lc = "abcdefghijklmnopqrstuvwxyz",
	            uc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
	            k = key.toLowerCase();

	        for (var i = 0, len = msg.length, keyLen = k.length; i < len; i++) {
	            // Grab shift for the current sequence of the key word
	            shift = lc.indexOf(k[count % keyLen]);

	            if (msg[i] >= "a" && msg[i] <= "z") {
	                cipher = cipher + lc[(lc.indexOf(msg[i]) + shift) % 26];
	                count++;
	            }
	            else if (msg[i] >= "A" && msg[i] <= "Z") {
	                cipher = cipher + uc[(uc.indexOf(msg[i]) + shift) % 26];
	                count++;
	            }
	            else {
	                cipher = cipher + msg[i];
	            }
	        }

	        return cipher;
	    },

	    /* Returns array of English letter frequenciy, normalized and then scaled */
	    normEnglishLetterFreq: function(scale) {

	        var freq = [.08167, .01492, .02782, .04253, .12702, .02228, .02015,  // a,b,c,d,e,f,g
	                    .06094, .06966, .00154, .00772, .04024, .02406, .06749,  // h,i,j,k,l,m,n
	                    .07507, .01929, .00095, .05987, .06327, .09056, .02758,  // o,p,q,r,s,t,u
	                    .00978, .02360, .00150, .01974, .00074];               // v,w,x,y,z

	        for (var i = 0, len = freq.length; i < len; i++) {
	            freq[i] = freq[i] * scale;
	        }

	        return freq;
	    },

	    /* returns array of Cipher letter frequenciy, normalized and then scaled */
	    normCipherLetterFreq: function(cipher, scale) {
	        var msg = cipher.toLowerCase(),
	            freq = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], //a-z @Nolint
	            count = 0,  //letter count
	            lc = "abcdefghijklmnopqrstuvwxyz";

	        // Count up aplha charecters in cipher
	        for (var i = 0, len = msg.length; i < len; i++) {
	            if (msg[i] >= "a" && msg[i] <= "z") {
	                freq[lc.indexOf(msg[i])]++;
	                count++;
	            }
	        }

	        // Normalize the cipher letter frequency, then scale it
	        for (var i = 0, len = freq.length; i < len; i++) {
	            freq[i] = (freq[i] / count) * scale;
	        }

	        return freq;
	    }

	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(19);
	__webpack_require__(4);
	__webpack_require__(34);

	$.extend(KhanUtil, {
	    // Add a "congruency" object that stores data about the
	    // points, lines, and angles that you added to the congruency
	    // figure
	    //
	    // options that can be added to modify:
	    //
	    // - x1, y1, x2, y2: the bounds of the object, which controls
	    //      where an extended line gets extended to
	    addCongruency: function(options) {
	        var congruency = $.extend(true, {
	            x1: 0,
	            x2: 10,
	            y1: 0,
	            y2: 3
	        }, options);

	        // ensure that x1 < x2, y1 < y2
	        if (congruency.x1 > congruency.x2) {
	            var hold = congruency.x1;
	            congruency.x1 = congruency.x2;
	            congruency.x2 = hold;
	        }
	        if (congruency.y1 > congruency.y2) {
	            var hold = congruency.y1;
	            congruency.y1 = congruency.y2;
	            congruency.y2 = hold;
	        }

	        // store the current graph
	        var graph = KhanUtil.currentGraph;

	        // where the lines, angles, and points are stored
	        congruency.lines = {};
	        congruency.angles = {};
	        congruency.points = {};

	        congruency.getPoint = function(pt) {
	            if (typeof pt === "string") {
	                return congruency.points[pt];
	            } else {
	                return pt;
	            }
	        };

	        // Add a point to the congruency figure
	        //
	        // - name is a one-character string
	        // - position is a two-element array
	        congruency.addPoint = function(name, position) {
	            var point = {
	                name: name,
	                pos: position,
	                connected: [],
	                arcs: []
	            };

	            // calculate the angle of the point to another point
	            point.angleTo = function(p) {
	                p = congruency.getPoint(p);

	                return Math.atan2(p.pos[1] - point.pos[1],
	                                  p.pos[0] - point.pos[0]);
	            };

	            // store the point in the congruency variable
	            congruency.points[name] = point;

	            return point;
	        };

	        // add a line to the congruency diagram
	        //
	        // there are two ways to specify the line:
	        //
	        // - provide a start point and an angle
	        //
	        //      This creates a line starting at the start
	        //      point and extending in the direction of the
	        //      given angle for one unit
	        //
	        // - provide a start and end point
	        //
	        //      This creates a line starting at the start
	        //      point and ending at the end point
	        //
	        // other options:
	        //
	        // - extend:
	        //      makes the line extend in both directions
	        //      until it hits the congruency boundary
	        //
	        // - clickable:
	        //      makes the line able to be clicked on to change
	        //      the number of ticks on it
	        //
	        // - state:
	        //      the starting number of ticks on the line
	        //
	        // - maxState:
	        //      the maximum number of ticks that can be added
	        //      by clicking
	        //
	        // - tickDiff:
	        //      the distance between the ticks on the line
	        //
	        // - tickLength:
	        //      the length of each tick mark
	        //
	        // - placeAtStart:
	        //      A string name of a point to be placed at the
	        //      beginning of the line, after extending
	        //
	        // - placeAtEnd:
	        //      A string name of a point to be placed at the
	        //      end of the line, after extending
	        congruency.addLine = function(options) {
	            var line = $.extend(true, {
	                start: [0, 0],
	                extend: false,
	                clickable: false,
	                state: 0,
	                maxState: 1,
	                tickDiff: 0.15,
	                tickLength: 0.2,
	                highlighted: false
	            }, options);

	            // look up the start and end points, if they are
	            // given as strings
	            if (typeof line.start === "string") {
	                line.startPt = congruency.points[line.start];
	                line.start = line.startPt.pos;
	            }
	            if (typeof line.end === "string") {
	                line.endPt = congruency.points[line.end];
	                line.end = line.endPt.pos;
	            }

	            // check how the line is defined, and calculate the other
	            // variables based on those
	            if (line.end != null) {
	                line.radAngle = Math.atan2(line.end[1] - line.start[1],
	                                           line.end[0] - line.start[0]);
	                line.angle = KhanUtil.toDegrees(line.radAngle);
	            } else if (line.angle != null) {
	                line.radAngle = KhanUtil.toRadians(line.angle);
	                line.end = [Math.cos(line.radAngle) + line.start[0],
	                            Math.sin(line.radAngle) + line.start[1]];
	            }

	            // calculate and bound the slope;
	            line.slope = (line.end[1] - line.start[1]) /
	                         (line.end[0] - line.start[0]);
	            line.slope = Math.max(-999999, Math.min(999999, line.slope));

	            // a function which represents the line
	            line.func = function(x) {
	                return line.start[1] + line.slope * (x - line.start[0]);
	            };

	            // the inverse function of the line
	            line.invfunc = function(y) {
	                var slope = (line.slope === 0) ? 0.00001 : line.slope;
	                return line.start[0] + (y - line.start[1]) / slope;
	            };

	            // extend the line if specified
	            if (line.extend) {
	                // check which orientation the points are currently in
	                var order = (line.start[0] < line.end[0]);

	                // the new 'left' and 'right' points
	                var left, right;

	                // check to see where the 'left' side of
	                // the line intersects
	                var y1int = line.func(congruency.x1);

	                if (y1int >= congruency.y1 && y1int <= congruency.y2) {
	                    left = [congruency.x1, y1int];
	                } else if (y1int > congruency.y2) {
	                    left = [line.invfunc(congruency.y2), congruency.y2];
	                } else {
	                    left = [line.invfunc(congruency.y1), congruency.y1];
	                }

	                // check to see where the 'right' side of
	                // the line intersects
	                var y2int = line.func(congruency.x2);

	                if (y2int >= congruency.y1 && y2int <= congruency.y2) {
	                    right = [congruency.x2, y2int];
	                } else if (y2int > congruency.y2) {
	                    right = [line.invfunc(congruency.y2), congruency.y2];
	                } else {
	                    right = [line.invfunc(congruency.y1), congruency.y1];
	                }

	                // re-store the points in the correct positions
	                if (order) {
	                    line.start = left;
	                    line.end = right;
	                } else {
	                    line.end = left;
	                    line.start = right;
	                }
	            }

	            // do placeAtStart and placeAtEnd
	            if (line.placeAtStart != null) {
	                line.startPt = congruency.addPoint(line.placeAtStart,
	                                                   line.start);
	            }
	            if (line.placeAtEnd != null) {
	                line.endPt = congruency.addPoint(line.placeAtEnd, line.end);
	            }

	            // if startPt and endPt exist (i.e. they are both named
	            // points) add the name of our line to the congruency
	            if (line.startPt != null &&
	                line.endPt != null) {
	                congruency.lines[line.startPt.name + line.endPt.name] = line;
	                congruency.lines[line.endPt.name + line.startPt.name] = line;
	            }

	            // if the points are named, add the other end of the line
	            // to the connected points, so they can calculate what angles
	            // they create
	            if (line.startPt != null && line.endPt != null) {
	                line.startPt.connected.push(line.endPt);
	                line.endPt.connected.push(line.startPt);
	            }

	            // actually draw the line with the current styles
	            line.draw = function() {
	                if (this.line != null) {
	                    this.line.remove();
	                }

	                // create a set
	                this.line = graph.raphael.set();

	                // do a bunch of tick calculations
	                var startDiff = this.tickDiff * (this.state - 1) / 2;

	                var direction = [Math.cos(this.radAngle), Math.sin(this.radAngle)];
	                var normalDir = [-direction[1] * this.tickLength,
	                                  direction[0] * this.tickLength];

	                var midpoint = [(this.start[0] + this.end[0]) / 2,
	                                (this.start[1] + this.end[1]) / 2];

	                var startPos = [midpoint[0] - startDiff * direction[0],
	                                midpoint[1] - startDiff * direction[1]];

	                // add each of the ticks
	                for (var curr = 0; curr < this.state; curr += 1) {
	                    var currPos = [startPos[0] + curr * direction[0] * this.tickDiff,
	                                   startPos[1] + curr * direction[1] * this.tickDiff];
	                    var start = [currPos[0] + normalDir[0],
	                                 currPos[1] + normalDir[1]];
	                    var end = [currPos[0] - normalDir[0],
	                               currPos[1] - normalDir[1]];

	                    this.line.push(graph.line(start, end));
	                }

	                // add our line
	                this.line.push(graph.line(this.start, this.end));

	                // add parallel line marker to horizontal line
	                if (direction[1] === 0) {
	                    ParallelLineMarkers(this.end[0] - 0.5, this.end[1]);
	                }

	                // set the attributes
	                this.line.attr(this.point.normalStyle);
	                this.point.visibleShape = this.line;
	            };

	            // calculate our midpoint, for where the clickable
	            // point should go
	            var pointPos = [(line.start[0] + line.end[0]) / 2,
	                            (line.start[1] + line.end[1]) / 2];

	            // add a movable point
	            line.point = graph.addMovablePoint({
	                coord: pointPos
	            });
	            // Make it not move
	            line.point.onMove = function(x, y) {
	                return false;
	            };

	            // make the mouse target pretty big
	            line.point.mouseTarget.attr({ r: graph.scale[0] * 0.7 });

	            // remove the original visible shape
	            line.point.visibleShape.remove();

	            // the original styles
	            line.normal = {
	                stroke: "black",
	                "stroke-width": 2
	            };
	            line.hover = {
	                stroke: "black",
	                "stroke-width": 3
	            };
	            line.highlight = {};

	            // set the styles depending on the state
	            line.setStyles = function() {
	                if (this.highlighted) {
	                    this.point.normalStyle = this.highlight;
	                    this.point.highlightStyle = this.highlight;
	                } else {
	                    this.point.normalStyle = this.normal;
	                    this.point.highlightStyle = this.hover;
	                }
	            };

	            // functions to change the styling of the line
	            line.setSelectedStyle = function(style) {
	                $.extend(true, this.hover, style);
	                this.draw();
	            };
	            line.setUnselectedStyle = function(style) {
	                $.extend(true, this.normal, style);
	                this.draw();
	            };

	            // change and set highlight
	            line.setHighlighted = function(style) {
	                $.extend(true, this.highlight, style);
	                this.highlighted = true;
	                this.setStyles();
	                this.draw();
	            };
	            line.unsetHighlighted = function() {
	                this.highlighted = false;
	                this.setStyles();
	                this.draw();
	            };

	            // set the default styles
	            line.setStyles();

	            // draw the line
	            line.draw();

	            // function to change the current state
	            line.setState = function(state) {
	                this.state = state;

	                this.draw();
	            };

	            // make the clickable point change the state
	            $(line.point.mouseTarget[0]).bind("vmouseup", function(event) {
	                line.setState((line.state === line.maxState) ? 0 : line.state + 1);
	            });

	            // make the line stick in the state it is in currently,
	            // and remove the clickable part
	            line.stick = function() {
	                line.point.mouseTarget.remove();
	            };

	            // if we shouldn't be clickable, stick right now
	            if (!line.clickable) {
	                line.stick();
	            }

	            return line;
	        };

	        congruency.addAngle = function(name, options) {
	            var angle = $.extend({
	                radius: 0.7,
	                state: 0,
	                maxState: 1,
	                shown: false,
	                clickable: true,
	                arcDiff: 0.15,
	                highlighted: false
	            }, options);

	            angle.center = name[1];
	            angle.left = name[0];
	            angle.right = name[2];

	            angle.centerPt = congruency.getPoint(angle.center);
	            angle.leftPt = congruency.getPoint(angle.left);
	            angle.rightPt = congruency.getPoint(angle.right);

	            angle.pos = angle.centerPt.pos;
	            angle.start = KhanUtil.toDegrees(angle.centerPt.angleTo(angle.leftPt));
	            angle.end = KhanUtil.toDegrees(angle.centerPt.angleTo(angle.rightPt));

	            while (angle.start > angle.end) {
	                angle.start -= 360;
	            }

	            angle.angle = angle.end - angle.start;

	            // Add a movable point for clicking
	            var aveAngle = KhanUtil.toRadians((angle.start + angle.end) / 2);

	            var pointPos = angle.pos.slice();
	            pointPos[0] += Math.cos(aveAngle) * angle.radius;
	            pointPos[1] += Math.sin(aveAngle) * angle.radius;

	            angle.point = graph.addMovablePoint({
	                coord: pointPos
	            });
	            // Make it not move
	            angle.point.onMove = function(x, y) {
	                return false;
	            };

	            // Make a clicky pointer
	            $(angle.point.mouseTarget[0]).css("cursor", "pointer");

	            // Increase the point's size
	            var pointRadius = Math.sin(KhanUtil.toRadians(angle.angle) / 2) *
	                angle.radius * graph.scale[0];
	            angle.point.mouseTarget.attr({ r: pointRadius });

	            // Replace the shape with our angle
	            angle.point.visibleShape.remove();

	            // Styles for different mouse-over states
	            angle.unselected = {
	                stroke: KhanUtil.GRAY,
	                "stroke-width": 2,
	                opacity: 0.1
	            };
	            angle.unselectedHover = {
	                stroke: KhanUtil.GRAY,
	                "stroke-width": 2,
	                opacity: 0.4
	            };
	            angle.selected = {
	                stroke: KhanUtil.BLUE,
	                "stroke-width": 3,
	                opacity: 0.9
	            };
	            angle.selectedHover = {
	                stroke: KhanUtil.BLUE,
	                "stroke-width": 3,
	                opacity: 1.0
	            };
	            angle.highlight = {};

	            // Draw the arc(s)
	            angle.draw = function() {
	                // Remove any left over arcs
	                if (this.arc != null) {
	                    this.arc.remove();
	                }

	                // Count how many arcs there should be
	                var arcs = (this.state === 0) ? 1 : this.state;
	                var startRad = this.radius - this.arcDiff * (arcs - 1) / 2;

	                // Create a raphael set
	                this.arc = graph.raphael.set();

	                // Put all the arcs in the set
	                for (var curr = 0; curr < arcs; curr += 1) {
	                    var currRad = startRad + this.arcDiff * curr;
	                    this.arc.push(graph.arc(this.pos, currRad,
	                                            this.start, this.end));
	                }
	                // Attach it and style correctly
	                this.point.visibleShape = this.arc;
	                this.arc.attr(this.point.normalStyle);
	            };

	            // Set the styles according to the current state
	            angle.setStyles = function() {
	                if (this.highlighted) {
	                    this.point.normalStyle = this.highlight;
	                    this.point.highlightStyle = this.highlight;
	                } else if (this.state === 0) {
	                    this.point.normalStyle = this.unselected;
	                    this.point.highlightStyle = this.unselectedHover;
	                } else {
	                    this.point.normalStyle = this.selected;
	                    this.point.highlightStyle = this.selectedHover;
	                }
	            };

	            // Set the state of an angle
	            angle.setState = function(state) {
	                this.state = state;

	                this.setStyles();

	                this.draw();
	            };

	            // setup the original styles
	            angle.setStyles();

	            // Ensure the angle gets drawn on creation
	            angle.draw();

	            // Bind mouseclick
	            $(angle.point.mouseTarget[0]).bind("vmouseup", function(event) {
	                angle.setState((angle.state === angle.maxState) ? 0 : angle.state + 1);
	            });

	            // Make an angle stick in its current state
	            // by removing the clicky part
	            angle.stick = function() {
	                $(this.point.mouseTarget[0]).unbind();
	                this.point.mouseTarget.remove();
	            };

	            if (!angle.clickable) {
	                angle.stick();
	            }

	            // Set the style of angles when state == 0
	            angle.setUnselectedStyle = function(style) {
	                $.extend(true, this.unselected, style);
	                $.extend(true, this.unselectedHover, style);
	                this.draw();
	            };

	            // Set the style of angles when state > 0
	            angle.setSelectedStyle = function(style) {
	                $.extend(true, this.selected, style);
	                $.extend(true, this.selectedHover, style);
	                this.draw();
	            };

	            // Add a highlighting style and highlight an angle
	            angle.setHighlighted = function(style) {
	                $.extend(true, this.highlight, style);
	                this.highlighted = true;
	                this.setStyles();
	                this.draw();
	            };

	            // Unhighlight an angle
	            angle.unsetHighlighted = function() {
	                this.highlighted = false;
	                this.setStyles();
	                this.draw();
	            };

	            // add the angle to the angles hash
	            var name = angle.left + angle.center + angle.right;
	            congruency.angles[name] = angle;

	            name = angle.right + angle.center + angle.left;
	            congruency.angles[name] = angle;

	            return angle;
	        };

	        // add all of the angles at a specific point
	        congruency.addAngles = function(point, options) {
	            var pt = congruency.getPoint(point);

	            // sort the angles that are coming out of
	            // the given point by the angle they make to the point
	            var sortConnected = _.sortBy(pt.connected, function(cpt) {
	                return pt.angleTo(cpt);
	            });

	            var numAngs = sortConnected.length;

	            // go through the connected points in order and add
	            // the angles between them
	            for (var i = 0; i < numAngs; i += 1) {
	                var pt1 = sortConnected[i];
	                var pt2 = sortConnected[(i + 1) % numAngs];

	                var ang1 = pt.angleTo(pt1);
	                var ang2 = pt.angleTo(pt2);

	                // make sure the last angle is correct
	                if (i + 1 === numAngs) {
	                    ang2 += Math.PI * 2;
	                }

	                // don't make angles that are more than 180
	                if (ang2 - ang1 >= Math.PI) {
	                    continue;
	                }

	                // add the angle
	                congruency.addAngle(pt1.name + pt.name + pt2.name, options);
	            }
	        };

	        // intersect two lines, and add a point at the intersection
	        // of those two
	        congruency.intersect = function(line1, line2, pointName, addAngles) {
	            if (line1.slope === line2.slope) {
	                return false;
	            }

	            var point = null;

	            var coord = [];

	            coord[0] = (line1.slope * line1.start[0] -
	                        line2.slope * line2.start[0] +
	                        line2.start[1] - line1.start[1]) /
	                        (line1.slope - line2.slope);
	            coord[1] = line1.func(coord[0]);

	            point = congruency.addPoint(pointName, coord);

	            point.connected.push(line1.startPt);
	            point.connected.push(line1.endPt);
	            point.connected.push(line2.startPt);
	            point.connected.push(line2.endPt);

	            if (addAngles) {
	                congruency.addAngles(point.name);
	            }
	        };

	        // add a label next to a point, in the given direction
	        congruency.addLabel = function(point, position) {
	            var p = congruency.getPoint(point);
	            graph.label(p.pos, point, position);
	        };

	        // get a hash of all states of the arcs and lines,
	        // for storage in guesses and lookup
	        congruency.getGuess = function() {
	            var guess = {};

	            // store all the lines' states
	            _.each(congruency.lines, function(line, name) {
	                guess[name] = line.state;
	            });

	            // store all the angles' states
	            _.each(congruency.angles, function(angle, name) {
	                guess[name] = angle.state;
	            });

	            return guess;
	        };

	        // take a guess, and reset all of the angles and
	        // lines to their states
	        congruency.showGuess = function(guess) {
	            _.each(guess, function(t, g) {
	                if (g.length === 2) {
	                    congruency.lines[g].setState(t);
	                } else {
	                    congruency.angles[g].setState(t);
	                }
	            });
	        };

	        return congruency;
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var kmatrix = __webpack_require__(38);

	$.extend(KhanUtil, {
	    drawHintLine: function(pt1, pt2, ticks) {
	        var graphie = KhanUtil.currentGraph;

	        var length = KhanUtil.eDist(pt1, pt2);
	        var midpoint = [(pt1[0] + pt2[0]) / 2, (pt1[1] + pt2[1]) / 2];
	        var angle = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
	        var transform = function(point) {
	            var matrix = kmatrix.makeMatrix([
	                [Math.cos(angle), -Math.sin(angle), midpoint[0]],
	                [Math.sin(angle), Math.cos(angle), midpoint[1]],
	                [0, 0, 1]
	            ]);
	            var vector = kmatrix.makeMatrix([[point[0]], [point[1]], [1]]);
	            var prod = kmatrix.matrixMult(matrix, vector);
	            return [prod[0], prod[1]];
	        };

	        var hintLine = graphie.raphael.set();

	        hintLine.push(graphie.line(transform([-length / 2, 0]),
	            transform([length / 2, 0]), {
	                stroke: KhanUtil.BLUE,
	                strokeWidth: 1,
	                strokeDasharray: "- "
	            }));
	        graphie.style({
	            stroke: KhanUtil.BLUE,
	            strokeWidth: 1
	        }, function() {
	            if (ticks === 1) {
	                hintLine.push(graphie.line(
	                    transform(graphie.unscaleVector([0, 6])),
	                    transform(graphie.unscaleVector([0, -6]))));
	            } else if (ticks === 2) {
	                hintLine.push(graphie.line(
	                    transform(graphie.unscaleVector([-3, 6])),
	                    transform(graphie.unscaleVector([-3, -6]))));
	                hintLine.push(graphie.line(
	                    transform(graphie.unscaleVector([3, 6])),
	                    transform(graphie.unscaleVector([3, -6]))));
	            } else if (ticks === 3) {
	                hintLine.push(graphie.line(
	                    transform(graphie.unscaleVector([-6, 6])),
	                    transform(graphie.unscaleVector([-6, -6]))));
	                hintLine.push(graphie.line(
	                    transform(graphie.unscaleVector([0, 6])),
	                    transform(graphie.unscaleVector([0, -6]))));
	                hintLine.push(graphie.line(
	                    transform(graphie.unscaleVector([6, 6])),
	                    transform(graphie.unscaleVector([6, -6]))));
	            }
	        });
	        return hintLine;
	    },

	    construction: {},

	    // Useful for diagnostics: type "KhanUtil.showSnapPts()" in the console
	    showSnapPts: function() {
	        var graphie = KhanUtil.currentGraph;
	        var set = graphie.raphael.set();
	        _.each(KhanUtil.construction.interPoints, function(pt) {
	            set.push(graphie.circle(pt, 0.1, {
	                stroke: KhanUtil.PINK,
	                fill: KhanUtil.PINK
	            }));
	        });
	        _.each(KhanUtil.construction.snapPoints, function(pt) {
	            set.push(graphie.circle(pt.coord, 0.1, {
	                stroke: KhanUtil.RED,
	                fill: KhanUtil.RED
	            }));
	        });
	        _.delay(function() { set.remove(); }, 500);
	    },

	    // initialize the construction object, giving it a reference to the
	    // graphie it should refer to (so that the KhanUtil.currentGraph
	    // pointer can change without screwing everything up)
	    addConstruction: function(graphieId) {
	        var graphie = $("#" + graphieId).data("graphie");
	        var construction = KhanUtil.construction = {
	            tools: [], // a list of all compasses/straightedges on the graph
	            tool: {}, // the latest tool added
	            snapPoints: [], // "special" points all other points should snap to
	            interPoints: [], // "special" points all other points should snap to
	            snapLines: [] // points should also snap to lines
	        };

	        // add a compass tool to the graph
	        // the compass has the following fields:
	        // center: movable point
	        // radius: int
	        // circ: graphie circle
	        // perim: invisible mouse target for dragging/changing radius
	        construction.addCompass = function() {
	            var start = [Math.random() * 4 - 2, Math.random() * 4 - 2];
	            var startRadius = Math.random() + 1.5;
	            construction.tool = {
	                interType: "circle",
	                center: graphie.addMovablePoint({
	                        graph: graphie,
	                        coord: start,
	                        normalStyle: {
	                            stroke: KhanUtil.BLUE,
	                            fill: KhanUtil.BLUE
	                        }
	                    }),
	                radius: startRadius,
	                circ: graphie.circle(start, startRadius, {
	                        stroke: KhanUtil.BLUE,
	                        strokeDasharray: "- ",
	                        fill: KhanUtil.ORANGE,
	                        fillOpacity: 0
	                    }),
	                perim: graphie.mouselayer.circle(
	                        graphie.scalePoint(start)[0],
	                        graphie.scalePoint(start)[1],
	                        graphie.scaleVector(startRadius)[0]).attr({
	                            "stroke-width": 20,
	                            "opacity": 0.0
	                        })
	            };

	            var t = construction.tool;

	            $(t.center.mouseTarget[0]).bind(
	                "vmouseover vmouseout", function(event) {
	                    if (t.center.highlight) {
	                        t.circ.animate({
	                            stroke: KhanUtil.ORANGE,
	                            "fill-opacity": 0.05
	                        }, 50);
	                    } else {
	                        t.circ.animate({
	                            stroke: KhanUtil.BLUE,
	                            "fill-opacity": 0
	                        }, 50);
	                    }
	                });

	            // add this tool to the graph's set
	            construction.tools.push(t);

	            // add new points that all other points should snap to
	            construction.snapPoints.push(t.center);



	            t.center.onMove = function(x, y) {
	                t.circ.toFront();
	                t.perim.toFront();
	                t.center.visibleShape.toFront();
	                t.center.mouseTarget.toFront();
	                t.circ.attr({
	                    cx: graphie.scalePoint(x)[0],
	                    cy: graphie.scalePoint(y)[1]
	                });
	                t.perim.attr({
	                    cx: graphie.scalePoint(x)[0],
	                    cy: graphie.scalePoint(y)[1]
	                });
	            };

	            t.center.onMoveEnd = function(x, y) {
	                _.each(construction.snapLines, function(line) {
	                    var distIntersect = KhanUtil.lDist(t.center.coord, line);
	                    if (distIntersect[0] < 0.25) {
	                        t.center.onMove(distIntersect[1][0],
	                            distIntersect[1][1]);
	                        t.center.setCoord(distIntersect[1]);
	                    }
	                });

	                // keep track of all the possible snap points,
	                // and snap to the closest one
	                var myPossibleSnaps = [];
	                _.each(construction.snapPoints, function(point) {
	                    if (KhanUtil.eDist(t.center.coord, point.coord) < 0.25 &&
	                            t.center.coord !== point.coord) {
	                        myPossibleSnaps.push(point.coord);
	                    }
	                });

	                // before checking to see if we've moved onto an
	                // intersection of lines/circles, update these
	                // intersections
	                construction.updateIntersections();
	                _.each(construction.interPoints, function(point) {
	                    if (KhanUtil.eDist(t.center.coord, point) < 0.3 &&
	                            t.center.coord !== point) {
	                        myPossibleSnaps.push(point);
	                    }
	                });

	                // Now, snap to closest possible snap Point
	                var mySnapPoint = [];
	                var mySnapDist = null;
	                _.each(myPossibleSnaps, function(sCoord) {
	                    if (mySnapDist == null ||
	                            KhanUtil.eDist(sCoord, t.center.coord) <
	                            mySnapDist) {
	                        mySnapPoint = sCoord;
	                        mySnapDist = KhanUtil.eDist(sCoord, t.center.coord);
	                    }
	                });

	                if (mySnapPoint.length > 0) {
	                    t.center.onMove(mySnapPoint[0], mySnapPoint[1]);
	                    t.center.setCoord(mySnapPoint);
	                }
	            };

	            t.center.mouseTarget.dblclick(function() {
	                construction.removeTool(t, true);
	            });

	            $(t.perim[0]).css("cursor", "move");
	            $(t.perim[0]).bind(
	                "vmouseover vmouseout vmousedown", function(event) {
	                    if (event.type === "vmouseover") {
	                        t.highlight = true;
	                        if (!KhanUtil.dragging) {
	                            t.circ.animate({
	                                stroke: KhanUtil.ORANGE,
	                                "fill-opacity": 0.05
	                            }, 50);
	                            t.center.visibleShape.animate({
	                                stroke: KhanUtil.ORANGE,
	                                fill: KhanUtil.ORANGE
	                            }, 50);
	                        }

	                    } else if (event.type === "vmouseout") {
	                        t.highlight = false;
	                        if (!t.dragging) {
	                            t.circ.animate({
	                                stroke: KhanUtil.BLUE,
	                                "fill-opacity": 0
	                            }, 50);
	                            t.center.visibleShape.animate({
	                                stroke: KhanUtil.BLUE,
	                                fill: KhanUtil.BLUE
	                            }, 50);
	                        }

	                    } else if (event.type === "vmousedown" &&
	                            (event.which === 1 || event.which === 0)) {
	                        event.preventDefault();
	                        var data = t;
	                        data.circ.toFront();
	                        data.perim.toFront();
	                        data.center.visibleShape.toFront();
	                        data.center.mouseTarget.toFront();

	                        $(document).bind("vmousemove vmouseup", function(event) {
	                            event.preventDefault();
	                            data.dragging = true;
	                            KhanUtil.dragging = true;

	                            if (event.type === "vmousemove") {
	                                var mouseX = event.pageX -
	                                    $(graphie.raphael.canvas.parentNode).offset().left;
	                                var mouseY = event.pageY -
	                                    $(graphie.raphael.canvas.parentNode).offset().top;

	                                data.radius = KhanUtil.eDist(data.center.coord,
	                                    graphie.unscalePoint([mouseX, mouseY]));
	                                data.perim.attr({
	                                    r: graphie.scaleVector(data.radius)[0]
	                                });
	                                data.circ.attr({
	                                    rx: graphie.scaleVector(data.radius)[0],
	                                    ry: graphie.scaleVector(data.radius)[1]
	                                });

	                            } else if (event.type === "vmouseup") {
	                                $(document).unbind("vmousemove vmouseup");
	                                data.dragging = false;
	                                KhanUtil.dragging = false;
	                                construction.updateIntersections();
	                            }
	                        });
	                    }
	            });
	            construction.updateIntersections();
	        };


	        construction.mark = function() {
	            var x = -1;
	            var y = Math.random() * 2;

	            construction.tool = {
	                interType: "line",
	                center: graphie.addMovablePoint({
	                        graph: graphie,
	                        coordX: x,
	                        coordY: y,
	                        normalStyle: {
	                            stroke: KhanUtil.BLUE,
	                            fill: KhanUtil.BLUE
	                        }
	                    })
	            };

	            // this is a bit confusing: "graph: graphie" refers
	            // to the movableLineSegment's graph field, whereas
	            // "construction.tool.etc" refers to the KhanUtil.construction
	            // object being built in this util
	            construction.tool.line1 = graphie.addMovableLineSegment({
	                    graph: graphie,
	                    pointA: [x + 0.2, y + 0.2],
	                    pointZ: [x - 0.2, y - 0.2],
	                    normalStyle: {
	                        stroke: KhanUtil.BLUE,
	                        "stroke-width": 2
	                    },
	                    highlightStyle: {
	                        stroke: KhanUtil.ORANGE,
	                        "stroke-width": 3
	                    },
	                    movePointsWithLine: true
	                });

	            construction.tool.line2 = graphie.addMovableLineSegment({
	                    graph: graphie,
	                    pointA: [x + 0.2, y - 0.2],
	                    pointZ: [x - 0.2, y + 0.2],
	                    normalStyle: {
	                        stroke: KhanUtil.BLUE,
	                        "stroke-width": 2
	                    },
	                    highlightStyle: {
	                        stroke: KhanUtil.ORANGE,
	                        "stroke-width": 3
	                    },
	                    movePointsWithLine: true
	                });

	            $(construction.tool.center.mouseTarget[0]).bind(
	                "vmouseover vmouseout", construction.tool, function(event) {
	                    if (event.data.center.highlight) {
	                        event.data.line1.visibleLine.animate({
	                            stroke: KhanUtil.ORANGE
	                        }, 50);
	                        event.data.line2.visibleLine.animate({
	                            stroke: KhanUtil.ORANGE
	                        }, 50);
	                    } else {
	                        event.data.line1.visibleLine.animate({
	                            stroke: KhanUtil.BLUE
	                        }, 50);
	                        event.data.line2.visibleShape.animate({
	                            stroke: KhanUtil.BLUE
	                        }, 50);
	                    }
	                });

	            // add new tool object to graph's collection
	            construction.tools.push(construction.tool);

	            // keep track of all the points/lines that points should snap to
	            construction.snapPoints.push(construction.tool.center);

	            var t = construction.tool;

	            t.center.onMoveEnd = function(dX, dY) {
	                t.line1.visibleLine.toFront();
	                t.line1.mouseTarget.toFront();
	                t.line2.visibleLine.toFront();
	                t.line2.mouseTarget.toFront();
	                t.center.visibleShape.toFront();
	                t.center.mouseTarget.toFront();
	                //t.first.onMoveEnd(t.first.coord[0], t.first.coord[1]);
	                //t.second.onMoveEnd(t.second.coord[0], t.second.coord[1]);
	            };
	            
	            $(t.center.mouseTarget[0]).bind("dblclick", function() {
	                construction.removeTool(t, true);
	            });

	            construction.updateIntersections();
	        };

	        // add a straightedge object
	        // the straightedge object has the following fields
	        // first, second: movable endpoints
	        // edge: movable line segment
	        construction.addStraightedge = function(extend) {
	            extend = extend == null ? true : extend;

	            construction.tool = {
	                interType: "line",
	                first: graphie.addMovablePoint({
	                        graph: graphie,
	                        coordX: -1, coordY: Math.random() * 2,
	                        normalStyle: {
	                            stroke: KhanUtil.BLUE,
	                            fill: KhanUtil.BLUE
	                        }
	                    }),
	                second: graphie.addMovablePoint({
	                        graph: graphie,
	                        coordX: 1, coordY: Math.random() * 2,
	                        normalStyle: {
	                            stroke: KhanUtil.BLUE,
	                            fill: KhanUtil.BLUE
	                        }
	                    })
	            };

	            // this is a bit confusing: "graph: graphie" refers
	            // to the movableLineSegment's graph field, whereas
	            // "construction.tool.etc" refers to the KhanUtil.construction
	            // object being built in this util
	            construction.tool.edge = graphie.addMovableLineSegment({
	                    graph: graphie,
	                    pointA: construction.tool.first,
	                    pointZ: construction.tool.second,
	                    normalStyle: {
	                        stroke: KhanUtil.BLUE,
	                        "stroke-width": 2
	                    },
	                    highlightStyle: {
	                        stroke: KhanUtil.ORANGE,
	                        "stroke-width": 3
	                    },
	                    extendLine: extend,
	                    movePointsWithLine: true
	                });

	            $(construction.tool.first.mouseTarget[0]).bind(
	                "vmouseover vmouseout", construction.tool, function(event) {
	                    if (event.data.first.highlight) {
	                        event.data.edge.visibleLine.animate({
	                            stroke: KhanUtil.ORANGE
	                        }, 50);
	                        event.data.second.visibleShape.animate({
	                            stroke: KhanUtil.ORANGE,
	                            fill: KhanUtil.ORANGE
	                        }, 50);
	                    } else {
	                        event.data.edge.visibleLine.animate({
	                            stroke: KhanUtil.BLUE
	                        }, 50);
	                        event.data.second.visibleShape.animate({
	                            stroke: KhanUtil.BLUE,
	                            fill: KhanUtil.BLUE
	                        }, 50);
	                    }
	                });
	            $(construction.tool.second.mouseTarget[0]).bind(
	                "vmouseover vmouseout", construction.tool, function(event) {
	                    if (event.data.second.highlight) {
	                        event.data.edge.visibleLine.animate({
	                            stroke: KhanUtil.ORANGE
	                        }, 50);
	                        event.data.first.visibleShape.animate({
	                            stroke: KhanUtil.ORANGE,
	                            fill: KhanUtil.ORANGE
	                        }, 50);
	                    } else {
	                        event.data.edge.visibleLine.animate({
	                            stroke: KhanUtil.BLUE
	                        }, 50);
	                        event.data.first.visibleShape.animate({
	                            stroke: KhanUtil.BLUE,
	                            fill: KhanUtil.BLUE
	                        }, 50);
	                    }
	                });
	            $(construction.tool.edge.mouseTarget[0]).bind(
	                "vmouseover vmouseout", construction.tool, function(event) {
	                    if (event.data.edge.highlight) {
	                        event.data.first.visibleShape.animate({
	                            stroke: KhanUtil.ORANGE,
	                            fill: KhanUtil.ORANGE
	                        }, 50);
	                        event.data.second.visibleShape.animate({
	                            stroke: KhanUtil.ORANGE,
	                            fill: KhanUtil.ORANGE
	                        }, 50);
	                    } else {
	                        event.data.first.visibleShape.animate({
	                            stroke: KhanUtil.BLUE,
	                            fill: KhanUtil.BLUE
	                        }, 50);
	                        event.data.second.visibleShape.animate({
	                            stroke: KhanUtil.BLUE,
	                            fill: KhanUtil.BLUE
	                        }, 50);
	                    }
	                });

	            // add new tool object to graph's collection
	            construction.tools.push(construction.tool);

	            // keep track of all the points/lines that points
	            // should snap to
	            construction.snapPoints.push(construction.tool.first);
	            construction.snapPoints.push(construction.tool.second);

	            construction.snapLines.push(construction.tool.edge);

	            var t = construction.tool;

	            //t.edge.toBack();

	            t.edge.onMoveEnd = function(dX, dY) {
	                t.edge.visibleLine.toFront();
	                t.edge.mouseTarget.toFront();
	                t.first.visibleShape.toFront();
	                t.first.mouseTarget.toFront();
	                t.second.visibleShape.toFront();
	                t.second.mouseTarget.toFront();
	                t.first.onMoveEnd(t.first.coord[0], t.first.coord[1]);
	                t.second.onMoveEnd(t.second.coord[0], t.second.coord[1]);
	            };

	            var endpointMoveEnd = function(x, y, end) {
	                _.each(construction.snapLines, function(line) {
	                    var distIntersect = KhanUtil.lDist(end.coord, line);
	                    if (distIntersect[0] < 0.25) {
	                        end.setCoord(distIntersect[1]);
	                        end.updateLineEnds();
	                    }
	                });

	                // keep track of all the possible snap points,
	                // and snap to the closest one
	                var myPossibleSnaps = [];
	                _.each(construction.snapPoints, function(point) {
	                    if (KhanUtil.eDist(end.coord, point.coord) < 0.25 &&
	                            end.coord !== point.coord) {
	                        myPossibleSnaps.push(point.coord);
	                    }
	                });

	                // before checking to see if we've moved onto an
	                // intersection of lines/circles, update these
	                // intersections
	                construction.updateIntersections();
	                _.each(construction.interPoints, function(point) {
	                    if (KhanUtil.eDist(end.coord, point) < 0.3 &&
	                            end.coord !== point) {
	                        myPossibleSnaps.push(point);
	                    }
	                });

	                // Now, snap to closest possible snap Point
	                var mySnapPoint = [];
	                var mySnapDist = null;
	                _.each(myPossibleSnaps, function(sCoord) {
	                    if (mySnapDist == null ||
	                            KhanUtil.eDist(sCoord, end.coord) < mySnapDist) {
	                        mySnapPoint = sCoord;
	                        mySnapDist = KhanUtil.eDist(sCoord, end.coord);
	                    }
	                });

	                if (mySnapPoint.length > 0) {
	                    end.setCoord(mySnapPoint);
	                    end.updateLineEnds();
	                }
	                t.edge.visibleLine.toFront();
	                t.edge.mouseTarget.toFront();
	                t.first.visibleShape.toFront();
	                t.first.mouseTarget.toFront();
	                t.second.visibleShape.toFront();
	                t.second.mouseTarget.toFront();
	            };

	            t.first.onMoveEnd = function(x, y) {
	                endpointMoveEnd(x, y, t.first);
	            };
	            t.second.onMoveEnd = function(x, y) {
	                endpointMoveEnd(x, y, t.second);
	            };

	            $(t.first.mouseTarget[0]).bind("dblclick", function() {
	                construction.removeTool(t, true);
	            });

	            $(t.second.mouseTarget[0]).bind("dblclick", function() {
	                construction.removeTool(t, true);
	            });

	            $(t.edge.mouseTarget[0]).bind("dblclick", function() {
	                construction.removeTool(t, true);
	            });
	            construction.updateIntersections();
	        };


	        construction.removeTool = function(tool, updateTools) {
	            _.each(_.keys(tool), function(key) {
	                if (key === "center" || key === "perimeter" ||
	                        key === "first" || key === "second") {
	                    tool[key].visibleShape.remove();
	                    tool[key].visible = false;
	                    $(tool[key].mouseTarget[0]).remove();
	                } else if (key === "circ") {
	                    tool[key].remove();
	                } else if (key === "edge") {
	                    tool[key].remove();
	                }
	            });

	            if (updateTools) {
	                construction.tools.splice(_.indexOf(construction.tools, tool), 1);
	            }
	        };


	        // remove ALL the tools
	        construction.removeAllTools = function() {
	            var staticTools = [];
	            _.each(construction.tools, function(tool) {
	                if (tool.dummy) {
	                    staticTools.push(tool);
	                } else {
	                    construction.removeTool(tool, false);
	                }
	            });

	            construction.tools = staticTools;
	            construction.snapPoints = [];
	            construction.interPoints = [];
	            construction.snapLines = [];
	        };

	        // detect intersections between existing circles,
	        // lines, so that new points can snap to these intersections
	        construction.updateIntersections = function() {
	            construction.interPoints = [];
	            _.each(construction.tools, function(tool1) {
	                _.each(construction.tools, function(tool2) {
	                    if (tool1 !== tool2) {
	                        // two lines
	                        if (tool1.interType === "line" &&
	                            tool2.interType === "line") {
	                            construction.interPoints.push(
	                                findIntersection([tool1.first.coord,
	                                    tool1.second.coord],
	                                [tool2.first.coord, tool2.second.coord])
	                                .slice(0, 2));
	                        }
	                        // a line and a circle
	                        else if (tool1.interType === "line" &&
	                                tool2.interType === "circle") {

	                            var m = (tool1.second.coord[1] -
	                                    tool1.first.coord[1]) /
	                                    (tool1.second.coord[0] -
	                                    tool1.first.coord[0]);
	                            var yint = tool1.first.coord[1] -
	                                    m * tool1.first.coord[0];


	                            // solve for x-values of intersections
	                            // (x - cX)^2 + (y - cY)^2 = radius
	                            var cX = tool2.center.coord[0];
	                            var cY = tool2.center.coord[1];
	                            var rad = tool2.radius;

	                            // baby why you gotta play me like that
	                            var a = 1 + Math.pow(m, 2);
	                            var b = (-2 * cX + 2 * m * yint - 2 * cY * m);
	                            var c = (Math.pow(yint, 2) - 2 * yint * cY +
	                                Math.pow(cY, 2) + Math.pow(cX, 2) -
	                                Math.pow(rad, 2));

	                            var x1 = (-b + Math.sqrt(Math.pow(b, 2) -
	                                4 * a * c)) / (2 * a);
	                            var x2 = (-b - Math.sqrt(Math.pow(b, 2) -
	                                4 * a * c)) / (2 * a);


	                            if (!isNaN(x1)) {
	                                var y1 = m * x1 + yint;
	                                construction.interPoints.push([x1, y1]);
	                            }
	                            if (!isNaN(x2)) {
	                                var y2 = m * x2 + yint;
	                                construction.interPoints.push([x2, y2]);
	                            }
	                        }
							// two circles
	                        else if (tool1.center != null && tool2.center != null) {
	                            var a = tool1.center.coord[0];
	                            var b = tool1.center.coord[1];
	                            var c = tool2.center.coord[0];
	                            var d = tool2.center.coord[1];
	                            var r = tool1.radius;
	                            var s = tool2.radius;

	                            var e = c - a;
	                            var f = d - b;
	                            var p = Math.sqrt(Math.pow(e, 2) + Math.pow(f, 2));
	                            var k = (Math.pow(p, 2) + Math.pow(r, 2) -
	                                    Math.pow(s, 2)) / (2 * p);

	                            var x1 = a + e * k / p + (f / p) *
	                                Math.sqrt(Math.pow(r, 2) - Math.pow(k, 2));
	                            var y1 = b + f * k / p - (e / p) *
	                                Math.sqrt(Math.pow(r, 2) - Math.pow(k, 2));

	                            var x2 = a + e * k / p - (f / p) *
	                                Math.sqrt(Math.pow(r, 2) - Math.pow(k, 2));
	                            var y2 = b + f * k / p + (e / p) *
	                                Math.sqrt(Math.pow(r, 2) - Math.pow(k, 2));

	                            if (!isNaN(x1)) {
	                                construction.interPoints.push([x1, y1]);
	                            }
	                            if (!isNaN(x2)) {
	                                construction.interPoints.push([x2, y2]);
	                            }
	                        }
	                    }
	                });
	            });
	        };

	    },

	    // add non-interactive straightedge
	    addDummyStraightedge: function(coord1, coord2, extend) {
	        var construction = KhanUtil.construction;
	        extend = extend == null ? true : extend;
	        construction.tool = {
	            interType: "line",
	            dummy: true,
	            first: {coord: [coord1, coord2]},
	            second: {coord: [coord1, coord2]},
	            edge: KhanUtil.currentGraph.addMovableLineSegment({
	                coordA: coord1,
	                coordZ: coord2,
	                normalStyle: {stroke: "black", "stroke-width": 2},
	                highlightStyle: {stroke: KhanUtil.BLUE, "stroke-width": 3},
	                extendLine: extend,
	                fixed: true
	            })
	        };
	        // not sure about execution order here (vis-a-vis addConstruction),
	        // so be careful
	        if (construction.tools == null) {
	            construction.tools = [construction.tool];
	        } else {
	            construction.tools.push(construction.tool);
	        }
	        if (construction.snapLines == null) {
	            construction.snapLines = [construction.tool.edge];
	        } else {
	            construction.snapLines.push(construction.tool.edge);
	        }
	        KhanUtil.construction.updateIntersections();
	    },

	    // add non-interactive circle
	    addDummyCircle: function(center, radius) {
	        var construction = KhanUtil.construction;
	        var dummy = {coord: center};

	        KhanUtil.currentGraph.circle(center, {
	            r: radius,
	            fill: "none",
	            stroke: "black",
	            "stroke-width": 2
	        });

	        if (construction.snapPoints == null) {
	            construction.snapPoints = [dummy];
	        } else {
	            construction.snapPoints.push(dummy);
	        }
	        KhanUtil.construction.updateIntersections();
	    },

	    // add non-interactive point (can't just use circle or snapping
	    // won't work)
	    addDummyPoint: function(coordinates) {
	        var dummy = {coord: coordinates};
	        KhanUtil.currentGraph.circle(coordinates,
	                                {r: 0.08, fill: "black", stroke: "none"});

	        var construction = KhanUtil.construction;
	        if (construction.snapPoints == null) {
	            construction.snapPoints = [dummy];
	        } else {
	            construction.snapPoints.push(dummy);
	        }
	        KhanUtil.construction.updateIntersections();
	    },

	    // add non-interactive ray
	    addDummyRay: function(end, other) {
	        var construction = KhanUtil.construction;
	        construction.tool = {interType: "line", dummy: true,
	                      first: {coord: end},
	                      second: {coord: other},
	                      edge: {coordA: end, coordZ: other}};

	        KhanUtil.currentGraph.line(end, other,
	            {stroke: "black", "stroke-width": 2, arrows: "->"});

	        KhanUtil.addDummyPoint(end);

	        // not sure about execution order here (vis-a-vis addConstruction),
	        // so be careful
	        if (construction.tools == null) {
	            construction.tools = [construction.tool];
	        } else {
	            construction.tools.push(construction.tool);
	        }
	        if (construction.snapLines == null) {
	            construction.snapLines = [construction.tool.edge];
	        } else {
	            construction.snapLines.push(construction.tool.edge);
	        }
	        KhanUtil.construction.updateIntersections();
	    },

	    constructionGuess: null,

	    // show guess, given pruned tools which
	    // only store coordinates of important
	    // points
	    showConstructionGuess: function(guessTools) {
	        var graph = KhanUtil.currentGraph;
	        if (KhanUtil.constructionGuess != null) {
	            KhanUtil.constructionGuess.remove();
	        }
	        KhanUtil.constructionGuess = graph.raphael.set();
	        _.each(guessTools, function(tool) {
	            if (tool.first != null) {
	                KhanUtil.constructionGuess.push(graph.addMovableLineSegment({
	                    coordA: tool.first.coord,
	                    coordZ: tool.second.coord,
	                    normalStyle: {
	                        stroke: KhanUtil.BLUE,
	                        "stroke-width": 2
	                    },
	                    extendLine: true,
	                    fixed: true
	                }).visibleLine);
	                KhanUtil.constructionGuess.push(graph.circle(
	                    tool.first.coord, 0.1, {
	                        fill: KhanUtil.BLUE,
	                        stroke: null
	                    }));
	                KhanUtil.constructionGuess.push(graph.circle(
	                    tool.second.coord, 0.1, {
	                        fill: KhanUtil.BLUE,
	                        stroke: null
	                    }));
	            } else if (tool.center != null) {
	                KhanUtil.constructionGuess.push(graph.circle(
	                    tool.center.coord, 0.1, {
	                        fill: KhanUtil.BLUE,
	                        stroke: null
	                    }));
	                KhanUtil.constructionGuess.push(graph.circle(
	                    tool.center.coord, tool.radius, {
	                        fill: "none",
	                        stroke: KhanUtil.BLUE,
	                        strokeDasharray: "- "
	                    }));
	            }
	        });
	    },

	    // shorthand for euclidean distance
	    // maybe I value brevity too much?
	    eDist: function(coords1, coords2) {
	        return Math.sqrt(Math.pow(coords1[0] - coords2[0], 2) +
	                Math.pow(coords1[1] - coords2[1], 2));
	    },

	    // distance from a point to a line, measured
	    // as the distance along a perpendicular
	    lDist: function(coord, line) {
	        var slope = (line.coordZ[1] - line.coordA[1]) /
	                (line.coordZ[0] - line.coordA[0]);
	        var perpSlope = slope === 0 ? "vert" : -1 / slope;
	        var coord2;
	        if (perpSlope === "vert") {
	            coord2 = [coord[0], coord[1] + 1];
	        } else {
	            coord2 = [coord[0] + 1, coord[1] + perpSlope];
	        }

	        var intersect = findIntersection([coord, coord2],
	                                     [line.coordA, line.coordZ]);

	        return [KhanUtil.eDist(intersect, coord), intersect];
	    },

	    // Find whether two points are a given distance apart
	    // given a certain precision
	    distEqual: function(p1, p2, distance, precision) {
	        precision = precision || 0.5;
	        return Math.abs(KhanUtil.eDist(p1, p2) - distance) < precision;

	    },

	    // Find whether a line has a given angle
	    // to a certain precision (in degrees)
	    angleEqual: function(line, angle, precision) {
	        var ang = Math.atan2(line.second.coord[1] - line.first.coord[1],
	                             line.second.coord[0] - line.first.coord[0]);

	        ang *= 180 / Math.PI;
	        if (ang < 0) {
	            ang += 180;
	        }
	        return Math.abs(angle - ang) < precision;
	    },

	    // Given an array of construction tools, return an array
	    // with either coordinates of a line and the center and
	    // radius of a circle.
	    // Submitted as the guess for a construction problem
	    getToolProperties: function (construction) {
	        return _.map(_.filter(construction.tools, function(tool) {
	            return tool.dummy !== true;
	        }), function(tool) {
	            if (tool.first != null) {
	                return {
	                    first: {
	                        coord: [
	                            tool.first.coord[0],
	                            tool.first.coord[1]
	                        ]
	                    },
	                    second: {
	                        coord: [
	                            tool.second.coord[0],
	                            tool.second.coord[1]
	                        ]
	                    }
	                };
	            } else if (tool.center != null) {
	                return {
	                    center: {
	                        coord: [
	                            tool.center.coord[0],
	                            tool.center.coord[1]
	                        ]
	                    },
	                    radius: tool.radius
	                };
	            }
	        });
	    },

	    findCompass: function (guess, properties) {
	        var testFunctions = [];

	        if (properties.radius != null) {
	            testFunctions.push(function (tool) {
	                return Math.abs(tool.radius - properties.radius) < 0.5;
	            });
	        }

	        if (properties.cx != null) {
	            testFunctions.push(function (tool) {
	                return Math.abs(tool.center.coord[0] - properties.cx) < 0.5;
	            });
	        }

	        if (properties.cy != null) {
	            testFunctions.push(function (tool) {
	                return Math.abs(tool.center.coord[1] - properties.cy) < 0.5;
	            });
	        }

	        if (properties.center != null) {
	            testFunctions.push(function (tool) {
	                return Math.abs(tool.center.coord[0] - properties.center[0]) < 0.5 &&
	                    Math.abs(tool.center.coord[1] - properties.center[1]) < 0.5;
	            });
	        }

	        return _.filter(guess, function(tool) {
	            if (tool.center != null) {
	                for (var i = 0; i < testFunctions.length; i++) {
	                    if (!testFunctions[i](tool)) {
	                        return false;
	                    }
	                }
	                return true;
	            }
	        });
	    },

	    // Given a set of tools (guess), a circle and a number of sides
	    // return the lines that form an inscribed shape with n sides
	    findInscribedPolygon: function (guess, center, radius, n) {
	        var interiorAngle = 2 * Math.PI / n;
	        var sideLength = 2 * radius * Math.sin(interiorAngle / 2);

	        // Get array of line of the correct length and with end points on the circle
	        var lines = _.filter(guess, function(tool) {
	            return tool.first != null &&
	                KhanUtil.distEqual(tool.first.coord, tool.second.coord, sideLength, 0.3) &&
	                KhanUtil.distEqual(tool.first.coord, center, radius, 0.3) &&
	                KhanUtil.distEqual(tool.second.coord, center, radius, 0.3);
	        });

	        if (lines.length < n) {
	            return false;
	        }

	        // Find one angle so we can find the offset
	        var offsetAngle = 180 + Math.atan2(lines[0].first.coord[1], lines[0].first.coord[0]) * 180 / Math.PI;

	        // Find angles to line points
	        var angles = [];
	        _.map(lines, function(tool) {
	            var angle1 = Math.atan2(tool.first.coord[1], tool.first.coord[0]) * 180 / Math.PI; 
	            var angle2 = Math.atan2(tool.second.coord[1], tool.second.coord[0]) * 180 / Math.PI; 
	            angles.push((angle1 - offsetAngle + 540 + 180 / n) % 360);
	            angles.push((angle2 - offsetAngle + 540 + 180 / n) % 360);
	        });

	        // Get an object of the angles we expect vertices to be at
	        // Plus half the base angle so it's easier to compare differences from angles
	        // e.g. [0 + 45, 90 + 45, 180 + 45, 270 + 45] for a square
	        // Mean we can count them - there should be two each
	        var targetAngles = {};
	        for (var i = 0; i < n; i++) {
	            targetAngles[(i + 0.5) * 360 / n] = 0;
	        }

	        // Go through all angles and see if they are with +/-4 degrees of the target angles
	        var threshold = 4;
	        _.map(angles, function(angle) {
	            for (var i = 0; i < n; i++) {
	                var targetAngle = (i + 0.5) * 360 / n;
	                if (Math.abs(angle - targetAngle) < threshold) {
	                    targetAngles[targetAngle]++;
	                    break;
	                }
	            }
	        });

	        //console.log(targetAngles);

	        // Check that each angles occurs twice
	        for (var angle in targetAngles) {
	            if (targetAngles[angle] !== 2) {
	                return false;
	            }
	        }

	        return lines;
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {
	    trigFunc: {
	        csc: {name: "csc", print: function(angle) {
	            return KhanUtil.trigFunc.sec.print(90 - angle);
	        },
	        convertsTo: ["sin"],
	        convertTo: function(type, angle) {
	            if (type.name === "sin") {
	                var cscv = KhanUtil.trigFunc.csc.print(angle);
	                var sinv = KhanUtil.trigFunc.sin.print(angle);
	                var toReturn = [];
	                toReturn.push("\\csc x = \\frac{1}{\\sin x}");
	                toReturn.push("\\csc x = " + cscv);
	                toReturn.push("\\frac{1}{\\sin x} = " + cscv);
	                toReturn.push("\\sin x = " + sinv);
	                return toReturn;
	            }

	        }
	    },
	    sec: {name: "sec", print: function(angle) {
	        if (angle === 0) {
	            return 1;
	        }
	        else if (angle === 30) {
	            return "\\frac{2 \\sqrt 3}{3}";
	        }
	        else if (angle === 45) {
	            return "\\sqrt 2";
	        }
	        else if (angle === 60) {
	            return "2";
	        }
	        else if (angle === 90) {
	            return "undefined";
	        }
	        return "undef";
	    },
	    convertsTo: ["cos", "tan"],
	    convertTo: function(type, angle) {
	        if (type.name === "cos") {
	            var cosv = KhanUtil.trigFunc.cos.print(angle);
	            var secv = KhanUtil.trigFunc.sec.print(angle);
	            var toReturn = [];
	            toReturn.push("\\sec x = \\frac{1}{\\cos x}");
	            toReturn.push("\\sec x = " + secv);
	            toReturn.push("\\frac{1}{\\cos x} = " + secv);
	            toReturn.push("\\cos x = " + cosv);
	            return toReturn;
	        }
	        else if (type.name === "tan") {
	            var tanv = KhanUtil.trigFunc.tan.print(angle);
	            var secv = KhanUtil.trigFunc.sec.print(angle);
	            var toReturn = [];
	            toReturn.push("\\sin^2 x + \\cos^2 x = 1");
	            toReturn.push("\\frac{\\sin^2 x}{\\cos^2 x} + \\frac{\\cos^2 x}{\\cos^2 x} = \\frac{1}{\\cos^2 x}");
	            toReturn.push("\\tan^2 x + 1 = \\sec^2 x");
	            toReturn.push("\\tan^2 x + 1 = (" + secv + ")^2");
	            toReturn.push("\\tan^2 x = (" + secv + ")^2 - 1");
	            toReturn.push("\\tan x = \\sqrt { " + secv + "  ^2 - 1 }");
	            toReturn.push("\\tan x = " + tanv);
	            return toReturn;
	        }
	    }
	},
	tan: {name: "tan", print: function(angle) {
	    if (angle === 0) {
	        return 0;
	    }
	    else if (angle === 30) {
	        return "\\frac{\\sqrt 3}{3}";
	    }
	    else if (angle === 45) {
	        return "1";
	    }
	    else if (angle === 60) {
	        return "\\sqrt 3";
	    }
	    else if (angle === 90) {
	        return "undefined";
	    }
	    return "undef";

	},
	convertsTo: ["sec"],
	convertTo: function(type, angle) {
	    if (type.name === "sec") {

	        var tanv = KhanUtil.trigFunc.tan.print(angle);
	        var secv = KhanUtil.trigFunc.sec.print(angle);
	        var toReturn = [];
	        toReturn.push("\\sin^2 x + \\cos^2 x = 1");
	        toReturn.push("\\frac{\\sin^2 x}{\\cos^2 x} + \\frac{\\cos^2 x}{\\cos^2 x} = \\frac{1}{\\cos^2 x}");
	        toReturn.push("\\tan^2 x + 1 = \\sec^2 x");
	        toReturn.push("(" + tanv + ")^2 + 1 = \\sec^2 x");
	        toReturn.push("\\sqrt{(" + tanv + ")^2 + 1} = \\sec x");
	        toReturn.push(secv + " = \\sec x");
	        return toReturn;
	    }
	}
	},
	cos: {name: "cos", print: function(angle) {
	    return KhanUtil.trigFunc.sin.print(90 - angle);
	},
	convertsTo: ["sin", "sec"],
	convertTo: function(type, angle) {
	    var toReturn = [];
	    var cosv;
	    var sinv;
	    var secv;
	    if (type.name === "sin") {
	        cosv = KhanUtil.trigFunc.cos.print(angle);
	        sinv = KhanUtil.trigFunc.sin.print(angle);
	        toReturn.push("\\sin^2 x + \\cos^2 x = 1");
	        toReturn.push("\\sin^2 x + (" + cosv + ")^2 = 1");
	        toReturn.push("(" + cosv + ")^2 = 1 - \\sin^2 x");
	        toReturn.push("(" + cosv + ")^2 - 1 = - \\sin^2 x");
	        toReturn.push("-(" + cosv + ")^2 + 1 = \\sin^2 x");
	        toReturn.push(sinv + " = \\sin x");
	        return toReturn;
	    }
	    else if (type.name === "sec") {
	        cosv = KhanUtil.trigFunc.cos.print(angle);
	        secv = KhanUtil.trigFunc.sec.print(angle);
	        toReturn.push(cosv + " = \\cos x");
	        toReturn.push(secv + " = \\frac{1}{\\cos x}");
	        toReturn.push(secv + " = \\sec x");
	        return toReturn;
	    }
	}
	},
	sin: {name: "sin", print: function(angle) {
	    if (angle === 0) {
	        return 0;
	    }
	    else if (angle === 30) {
	        return "\\frac{1}{2}";
	    }
	    else if (angle === 45) {
	        return "\\frac{\\sqrt 2}{2}";
	    }
	    else if (angle === 60) {
	        return "\\frac{\\sqrt 3}{2}";
	    }
	    else if (angle === 90) {
	        return "1";
	    }
	    return "undefined";
	},
	convertsTo: ["cos", "csc"],
	convertTo: function(type, angle) {
	    if (type.name === "cos") {
	        var sinv = KhanUtil.trigFunc.sin.print(angle);
	        var cosv = KhanUtil.trigFunc.cos.print(angle);
	        var toReturn = [];
	        toReturn.push("\\sin^2 x + \\cos^2 x = 1");
	        toReturn.push("(" + sinv + ")^2 + \\cos^2 x = 1");
	        toReturn.push("(" + sinv + ")^2 = 1- \\cos^2 x ");
	        toReturn.push("(" + sinv + ")^2 - 1 = - \\cos^2 x ");
	        toReturn.push("-(" + sinv + ")^2 + 1 = \\cos^2 x ");
	        toReturn.push(cosv + " =  \\cos x");
	        return toReturn;

	    }
	    else if (type.name === "csc") {
	        var sinv = KhanUtil.trigFunc.sin.print(angle);
	        var cscv = KhanUtil.trigFunc.csc.print(angle);
	        var toReturn = [];
	        toReturn.push(sinv + " = \\sin x");
	        toReturn.push(cscv + " = \\frac{1}{\\sin x}");
	        toReturn.push(cscv + " = \\csc x");
	        return toReturn;
	    }
	}

	}
	}});

	$.extend(KhanUtil, {
	    trigTypes: [KhanUtil.trigFunc.sin, KhanUtil.trigFunc.cos, KhanUtil.trigFunc.tan, KhanUtil.trigFunc.csc, KhanUtil.trigFunc.sec],

	    findSteps: function(start, end, value) {
	        var visited = {};
	        var queue = [];
	        var next = start;
	        while (next.name !== end.name) {
	            if (next.convertsTo) {
	                $.each(next.convertsTo, function(i, str) {
	                    if (! (str in visited)) {
	                        var move = KhanUtil.trigFunc[str];
	                        move.parent = next;
	                        queue.push(move);
	                    }
	                    visited[str] = true;
	                });
	            }
	            next = queue.shift();
	        }
	        var prev = next;
	        var steps = [];
	        while (prev.name !== start.name) {
	            steps.unshift(prev.name);
	            prev = prev.parent;

	        }
	        steps.unshift(prev.name);
	        var toReturn = [];
	        for (var x = 0; x < steps.length - 1; x++) {
	            // Vars cannot have circular references, so delete .parent before returning
	            var step = KhanUtil.trigFunc[steps[x]].convertTo(KhanUtil.trigFunc[steps[x + 1]], value);
	            delete step.parent;

	            toReturn.push(step);
	        }
	        for (x = 0; x < KhanUtil.trigTypes.length - 1; x++) {
	            delete KhanUtil.trigTypes[x].parent;
	        }
	        return toReturn;
	    }
	});

	// I would love to hear a better way of doing this than this mess
	$.extend(KhanUtil, {
	    trig: {
	        // given the simplification of a trig identity and an operation,
	        // finds a pair (function, result) such that that simplification
	        // operation'd with function equals result, and result is not a 
	        // horrible mess of trig functions with sin^4 everywhere and all that
	        getOptionsResult: function(firstPart, operation) {
	            var options;
	            var func;
	            if(firstPart === "\\cos^2\\theta") {
	                options = ["1", "\\cot^2\\theta", 
	                "\\cos^2\\theta \\cdot \\sin^2\\theta"];
	            }
	            else if(firstPart === "\\sin^2\\theta") {
	                options = ["1", "\\tan^2\\theta", 
	                "\\cos^2\\theta \\cdot \\sin^2\\theta"];
	            }
	            else if(firstPart === "\\tan^2\\theta") {
	                options = ["1", "\\sin^2\\theta",
	                "\\sec^2\\theta"];
	            }
	            else if(firstPart === "\\sec^2\\theta") {
	                options = ["1", "\\tan^2\\theta", "\\csc^2\\theta"];
	            }
	            else if(firstPart === "\\cot^2\\theta") {
	                options = ["1", "\\cos^2\\theta", "\\csc^2\\theta"];
	            }
	            else if(firstPart === "\\csc^2\\theta") {
	                options = ["1", "\\cot^2\\theta", "\\sec^2\\theta"];
	            }

	            var result = KhanUtil.randFromArray(options);
	            if(operation === "*") {
	                if(result === "1") {
	                    if(firstPart === "\\cos^2\\theta") {
	                        func = "\\sec^2\\theta";
	                    }
	                    else if(firstPart === "\\sin^2\\theta") {
	                        func = "\\csc^2\\theta";
	                    }
	                    else if(firstPart === "\\tan^2\\theta") {
	                        func = "\\cot^2\\theta";
	                    }
	                    else if(firstPart === "\\sec^2\\theta") {
	                        func = "\\cos^2\\theta";
	                    }
	                    else if(firstPart === "\\cot^2\\theta") {
	                        func = "\\tan^2\\theta";
	                    }
	                    else if(firstPart === "\\csc^2\\theta") {
	                        func = "\\sin^2\\theta";
	                    }
	                }
	                else if(result === "\\tan^2\\theta") {
	                    if(firstPart === "\\sin^2\\theta") {
	                        func = "\\sec^2\\theta";
	                    }
	                    else if(firstPart === "\\sec^2\\theta") {
	                        func = "\\sin^2\\theta";
	                    }
	                }
	                else if(result === "\\cot^2\\theta") {
	                    if(firstPart === "\\cos^2\\theta") {
	                        func = "\\csc^2\\theta";
	                    }
	                    else if(firstPart === "\\csc^2\\theta") {
	                        func = "\\cos^2\\theta";
	                    }
	                }
	                else if(result === "\\cos^2\\theta \\cdot \\sin^2\\theta") {
	                    if(firstPart === "\\cos^2\\theta") {
	                        func = "\\sin^2\\theta";
	                    }
	                    else if(firstPart === "\\sin^2\\theta") {
	                        func = "\\cos^2\\theta";
	                    }
	                }
	                else if(result === "\\sin^2\\theta") {
	                    if(firstPart === "\\tan^2\\theta") {
	                        func = "\\cos^2\\theta";
	                    }
	                }
	                else if(result === "\\cos^2\\theta") {
	                    if(firstPart === "\\cot^2\\theta") {
	                        func = "\\sin^2\\theta";
	                    }
	                }
	                else if(result === "\\sec^2\\theta") {
	                    if(firstPart === "\\tan^2\\theta") {
	                        func = "\\csc^2\\theta";
	                    }
	                    else if(firstPart === "\\csc^2\\theta") {
	                        func = "\\tan^2\\theta";
	                    }
	                }
	                else if(result === "\\csc^2\\theta") {
	                    if(firstPart === "\\sec^2\\theta") {
	                        func = "\\cot^2\\theta";
	                    }
	                    else if(firstPart === "\\cot^2\\theta") {
	                        func = "\\sec^2\\theta";
	                    }
	                }
	            }

	            else if(operation === "/") {
	                if(result === "1") {
	                    func = firstPart;
	                }
	                else if(result === "\\tan^2\\theta") {
	                    if(firstPart === "\\sin^2\\theta") {
	                        func = "\\cos^2\\theta";
	                    }
	                    else if(firstPart === "\\sec^2\\theta") {
	                        func = "\\csc^2\\theta";
	                    }
	                }
	                else if(result === "\\cot^2\\theta") {
	                    if(firstPart === "\\cos^2\\theta") {
	                        func = "\\sin^2\\theta";
	                    }
	                    else if(firstPart === "\\csc^2\\theta") {
	                        func = "\\sec^2\\theta";
	                    }
	                }
	                else if (result === "\\cos^2\\theta \\cdot \\sin^2\\theta") {
	                    if(firstPart === "\\cos^2\\theta") {
	                        func = "\\csc^2\\theta";
	                    }
	                    else if(firstPart === "\\sin^2\\theta") {
	                        func = "\\sec^2\\theta";
	                    }
	                }
	                else if (result === "\\sin^2\\theta") {
	                    if(firstPart === "\\tan^2\\theta") {
	                        func = "\\sec^2\\theta";
	                    }
	                }
	                else if(result === "\\cos^2\\theta") {
	                    if(firstPart === "\\cot^2\\theta") {
	                        func = "\\csc^2\\theta";
	                    }
	                }
	                else if (result === "\\sec^2\\theta") {
	                    if(firstPart === "\\tan^2\\theta") {
	                        func = "\\sin^2\\theta";
	                    }
	                    else if(firstPart === "\\csc^2\\theta") {
	                        func = "\\cot^2\\theta";
	                    }
	                }
	                else if (result === "\\csc^2\\theta") {
	                    if(firstPart === "\\sec^2\\theta") {
	                        func = "\\tan^2\\theta";
	                    }
	                    else if(firstPart === "\\cot^2\\theta") {
	                        func = "\\cos^2\\theta";
	                    }
	                }
	            }
	            return [options, func, result];
	        },

	        // expresses the given trig^2 function in terms of sin and cosine
	        showSimplified: function(func, small) {
	            var d = small ? "\\frac" : "\\dfrac";
	            switch(func) {
	                case "\\sin^2\\theta" :
	                    return func;
	                case "\\cos^2\\theta" :
	                    return func;
	                case "\\csc^2\\theta" :
	                    return d + "{1}{\\sin^2\\theta}";
	                case "\\sec^2\\theta" :
	                    return d + "{1}{\\cos^2\\theta}";
	                case "\\tan^2\\theta" :
	                    return d + "{\\sin^2\\theta}{\\cos^2\\theta}";
	                case "\\cot^2\\theta" :
	                    return d + "{\\cos^2\\theta}{\\sin^2\\theta}";
	            }
	        }
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(16);

	$.extend(KhanUtil, {
	    FN_COLOR: "#6495ED",
	    DDX_COLOR: "#FFA500",
	    TANGENT_COLOR: "#AAA",
	    TANGENT_LINE_LENGTH: 200,
	    TANGENT_GROWTH_FACTOR: 3,
	    TANGENT_SHIFT: 5,

	    // Wrap graphInit to create a 600x600px graph properly scaled to the given range
	    initAutoscaledGraph: function(range, options) {
	        var graph = KhanUtil.currentGraph;
	        options = $.extend({
	            xpixels: 500,
	            ypixels: 500,
	            xdivisions: 20,
	            ydivisions: 20,
	            labels: true,
	            unityLabels: true,
	            range: (typeof range === "undefined" ? [[-10, 10], [-10, 10]] : range)
	        }, options);

	        options.scale = [options.xpixels / (options.range[0][1] - options.range[0][0]),
	                          options.ypixels / (options.range[1][1] - options.range[1][0])];
	        options.gridStep = [(options.range[0][1] - options.range[0][0]) / options.xdivisions,
	                             (options.range[1][1] - options.range[1][0]) / options.ydivisions];

	        // Attach the resulting metrics to the graph for later reference
	        graph.xpixels = options.xpixels;
	        graph.ypixels = options.ypixels;
	        graph.range = options.range;
	        graph.scale = options.scale;

	        graph.graphInit(options);
	    },


	    // start the magic
	    initDerivativeIntuition: function(fnx, ddx, points) {
	        var graph = KhanUtil.currentGraph;

	        KhanUtil.fnx = fnx;
	        KhanUtil.ddx = ddx;
	        KhanUtil.points = points;
	        KhanUtil.highlight = false;
	        KhanUtil.dragging = false;
	        KhanUtil.ddxShown = false;

	        // to store the SVG paths
	        graph.tangentLines = [];
	        graph.tangentPoints = [];
	        graph.slopePoints = [];
	        graph.mouseTargets = [];

	        // graphie puts text spans on top of the SVG, which looks good, but gets
	        // in the way of mouse events. So we add another SVG element on top
	        // of everything else where we can add invisible shapes with mouse
	        // handlers wherever we want. Is there a better way?
	        graph.mouselayer = Raphael("ddxplot", graph.xpixels, graph.ypixels);
	        $(graph.mouselayer.canvas).css("z-index", 1);
	        Khan.scratchpad.disable();

	        // plot all the tangent lines first so they're underneath the tangent/slope points
	        $(points).each(function(index, xval) {
	            KhanUtil.plotTangentLine(index);
	        });

	        $(points).each(function(index, xval) {
	            // blue points
	            KhanUtil.plotTangentPoint(index);
	            // orange points and mouse magic
	            KhanUtil.plotSlopePoint(index);
	        });

	        // Once the problem loads, call setSlope() for each point to set the
	        // slopes to 0. This replicates the action of the user placing each point
	        // at zero and applies the same "close enough" test so very small slopes
	        // aren't graded wrong even if they look almost right.
	        $(Exercises).one("newProblem", function() {
	            $(points).each(function(index, xval) {
	                KhanUtil.setSlope(index, 0);
	            });
	        });
	    },


	    plotTangentLine: function(index) {
	        var graph = KhanUtil.currentGraph;
	        var xval = KhanUtil.points[index];
	        var yval = KhanUtil.fnx(xval);

	        // Now the fun bit: To make it clear that the tangent line only
	        // touches at a single point, it's shifted a little bit above or
	        // below the curve.

	        // The shifted pivot point; defaults to unshifted xval/yval in
	        // case we're dealing with an inflection point.
	        var xshift = xval;
	        var yshift = yval;

	        // The slope of a line perpendicular to the tangent line. It is
	        // along this direction that we shift the tangent line.
	        var perpslope = 0;

	        // First and second derivative at the point we're dealing with.
	        var ddx1 = KhanUtil.ddx(xval);
	        var ddx2 = (KhanUtil.ddx(xval - 0.001) - KhanUtil.ddx(xval + 0.001)) / 0.002;

	        if (ddx1 !== 0) {
	            // We want to shift *visually* perpendicular to the tangent line,
	            // so if the graph has different x and y scales, perpslope isn't
	            // quite as simple as (-1/slope)
	            perpslope = (-1 / (ddx1 * (graph.scale[1] / graph.scale[0]))) / (graph.scale[1] / graph.scale[0]);

	            // Second derivative tells us if the curve is concave up or down, thus which way to
	            // shift the tangent line to "get away" from the curve. If perpslope is negative,
	            // everything is reversed.
	            if ((ddx2 > 0 && perpslope > 0) || (ddx2 < 0 && perpslope < 0)) {
	                // atan(perpslope) is the direction to shift; cos() of that gives the x component; the rest of the mess normalizes for different x- and y-scales
	                xshift = xval + Math.cos(Math.atan(perpslope * (graph.scale[1] / graph.scale[0]))) * KhanUtil.TANGENT_SHIFT / (2 * graph.scale[0]);
	                yshift = perpslope * (xshift - xval) + yval;
	            } else if ((ddx2 < 0 && perpslope > 0) || (ddx2 > 0 && perpslope < 0)) {
	                xshift = xval - Math.cos(Math.atan(perpslope * (graph.scale[1] / graph.scale[0]))) * KhanUtil.TANGENT_SHIFT / (2 * graph.scale[0]);
	                yshift = perpslope * (xshift - xval) + yval;
	            }
	        } else {
	            // Slope is 0, so perpslope is undefined. Just shift up or down based on concavity
	            if (ddx2 < 0) {
	                yshift = yval - (KhanUtil.TANGENT_SHIFT / (2 * graph.scale[1]));
	            } else if (ddx2 > 0) {
	                yshift = yval + (KhanUtil.TANGENT_SHIFT / (2 * graph.scale[1]));
	            }
	        }

	        // at last the slightly nudged line is ready to draw
	        graph.style({
	            stroke: KhanUtil.TANGENT_COLOR,
	            strokeWidth: 2
	        }, function() {
	            graph.tangentLines[index] = graph.line(
	                    [xshift - KhanUtil.TANGENT_LINE_LENGTH / (2 * graph.scale[0]), yshift],
	                    [xshift + KhanUtil.TANGENT_LINE_LENGTH / (2 * graph.scale[0]), yshift]);
	        });
	    },


	    plotTangentPoint: function(index) {
	        var graph = KhanUtil.currentGraph;
	        var xval = KhanUtil.points[index];

	        graph.style({
	            fill: KhanUtil.FN_COLOR,
	            stroke: KhanUtil.FN_COLOR
	        }, function() {
	            graph.tangentPoints[index] = graph.ellipse([xval, KhanUtil.fnx(xval)], [4 / graph.scale[0], 4 / graph.scale[1]]);
	        });
	    },


	    plotSlopePoint: function(index) {
	        var graph = KhanUtil.currentGraph;
	        var xval = KhanUtil.points[index];

	        graph.style({
	            fill: KhanUtil.DDX_COLOR,
	            stroke: KhanUtil.DDX_COLOR
	        }, function() {
	            graph.slopePoints[index] = graph.ellipse([xval, 0], [4 / graph.scale[0], 4 / graph.scale[1]]);
	        });

	        var $ddxplot = $("#ddxplot");
	        var $solutionAreaText = $("div#solutionarea :text").eq(index);
	        var $solutionAreaLabel = $("div#solutionarea .answer-label").eq(index);

	        // the invisible shape in front of each point that gets mouse events
	        graph.mouseTargets[index] = graph.mouselayer.circle(
	                (xval - graph.range[0][0]) * graph.scale[0],
	                (graph.range[1][1] - 0) * graph.scale[1], 22);
	        graph.mouseTargets[index].attr({fill: "#000", "opacity": 0.0});

	        $(graph.mouseTargets[index][0]).css("cursor", "move");
	        $(graph.mouseTargets[index][0]).bind("vmousedown vmouseover vmouseout", function(event) {
	            event.preventDefault();
	            var graph = KhanUtil.currentGraph;
	            if (event.type === "vmouseover") {
	                KhanUtil.highlight = true;
	                if (!KhanUtil.dragging) {
	                    graph.slopePoints[index].animate({ scale: 2 }, 50);
	                    graph.tangentLines[index].animate({ "stroke": KhanUtil.DDX_COLOR }, 100);
	                }

	            } else if (event.type === "vmouseout") {
	                KhanUtil.highlight = false;
	                if (!KhanUtil.dragging) {
	                    graph.slopePoints[index].animate({ scale: 1 }, 50);
	                    graph.tangentLines[index].animate({ "stroke": KhanUtil.TANGENT_COLOR }, 100);
	                }

	            } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
	                event.preventDefault();
	                graph.tangentLines[index].toFront();
	                graph.tangentPoints[index].toFront();
	                graph.slopePoints[index].toFront();
	                graph.tangentLines[index].animate({ scale: KhanUtil.TANGENT_GROWTH_FACTOR }, 200);
	                KhanUtil.dragging = true;

	                var ddxplotTop = $ddxplot.offset().top;

	                $(document).bind("vmousemove vmouseup", function(event) {
	                    event.preventDefault();

	                    // mouseY is in pixels relative to the SVG; coordY is the scaled y-coordinate value
	                    var mouseY = event.pageY - ddxplotTop;
	                    mouseY = Math.max(10, Math.min(graph.ypixels - 10, mouseY));
	                    var coordY = graph.range[1][1] - mouseY / graph.scale[1];

	                    if (event.type === "vmousemove") {
	                        $solutionAreaText.val(KhanUtil.roundTo(2, coordY));
	                        $solutionAreaLabel.text(KhanUtil.roundTo(2, coordY));
	                        graph.tangentLines[index].rotate(-Math.atan(coordY * (graph.scale[1] / graph.scale[0])) * (180 / Math.PI), true);
	                        graph.slopePoints[index].attr("cy", mouseY);
	                        graph.mouseTargets[index].attr("cy", mouseY);

	                    } else if (event.type === "vmouseup") {
	                        $(document).unbind("vmousemove vmouseup");

	                        KhanUtil.setSlope(index, coordY);

	                        KhanUtil.dragging = false;

	                        graph.tangentLines[index].animate({ scale: 1 }, 200);
	                        if (!KhanUtil.highlight) {
	                            graph.slopePoints[index].animate({ scale: 1 }, 200);
	                            graph.tangentLines[index].animate({ "stroke": KhanUtil.TANGENT_COLOR }, 100);
	                        }

	                        // If all the points are in the right place, reveal the derivative function
	                        var answers = $.map($("div#solutionarea .answer-label"), function(x) {
	                            return parseFloat($(x).text());
	                        });
	                        var correct = $.map(KhanUtil.points, function(x) {
	                            return KhanUtil.roundTo(2, KhanUtil.ddx(x));
	                        });
	                        if (answers.join() === correct.join()) {
	                            KhanUtil.revealDerivative(400);
	                        }
	                    }
	                });
	            }
	        });

	    },


	    // Set the slope for one point. Snap to the right answer if we're close enough.
	    setSlope: function(index, coordY) {
	        var graph = KhanUtil.currentGraph;
	        var answer = KhanUtil.ddx(KhanUtil.points[index]);
	        var degreesOff = Math.abs(Math.atan(answer * graph.scale[1] / graph.scale[0]) -
	                Math.atan(coordY * graph.scale[1] / graph.scale[0])) * (180 / Math.PI);

	        // How far off you're allowed to be
	        if (degreesOff < 7) {
	            coordY = answer;
	        }

	        $($("div#solutionarea :text")[index]).val(KhanUtil.roundTo(2, coordY));
	        $($("div#solutionarea .answer-label")[index]).text(KhanUtil.roundTo(2, coordY));
	        graph.tangentLines[index].rotate(-Math.atan(coordY * (graph.scale[1] / graph.scale[0])) * (180 / Math.PI), true);
	        graph.slopePoints[index].attr("cy", (graph.range[1][1] - coordY) * graph.scale[1]);
	        graph.mouseTargets[index].attr("cy", (graph.range[1][1] - coordY) * graph.scale[1]);
	    },


	    // Shows the derivative plot and equation
	    // Called when all the points are in the right place or as a hint
	    revealDerivative: function(duration) {
	        if (!KhanUtil.ddxShown) {
	            var graph = KhanUtil.currentGraph;
	            var ddxplot;
	            duration = duration || 0;
	            graph.style({
	                stroke: KhanUtil.DDX_COLOR,
	                strokeWidth: 1,
	                opacity: duration === 0 ? 1 : 0
	            }, function() {
	                ddxplot = graph.plot(function(x) {
	                    return KhanUtil.ddx(x);
	                }, KhanUtil.tmpl.getVAR("XRANGE"));
	            });

	            $("span#ddxspan").show();  // for IE
	            $("span#ddxspan").fadeTo(duration, 1);

	            ddxplot.animate({ opacity: 1 }, duration);
	            KhanUtil.ddxShown = true;
	        }
	    }

	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(10);
	__webpack_require__(39);

	$.extend(KhanUtil, {

	    /* fraction math-format function called with defraction enabled, which is always
	     * what is used in the exponent exercises. */

	    frac: function(n, d) {
	        return KhanUtil.fraction(n, d, true, true, false, false);
	    },

	    fracSmall: function(n, d) {
	        return KhanUtil.fraction(n, d, true, true, true, false);
	    },

	    fracParens: function(n, d) {
	        return KhanUtil.fraction(n, d, true, true, false, true);
	    },

	    /* Used to show the contracting of something like (-2)^4 into 16, by showing
	     * (-2)^4 = (-2)(-2)(-2)(-2) = 4(-2)(-2) = -8(-2) = 16. Returns an array of
	     * each of these steps. */
	    expandExponent: function(base, exp) {
	        var base_str = KhanUtil.negParens(base),
	            expansion = "\\cdot" + base_str, steps = [], multiplier;

	        steps.unshift(Math.round(Math.pow(base, exp)));

	        for (var i = 1; i < exp; i++) {
	            multiplier = Math.round(Math.pow(base, exp - i));

	            // we wanth the first hint to say (-2)(-2)(-2)(-2), but the next one to
	            // say 4(-2)(-2), -8(-2), etc.
	            if (i === exp - 1) {
	                multiplier = KhanUtil.negParens(multiplier);
	            }

	            steps.unshift(multiplier + expansion);

	            expansion += "\\cdot " + base_str;
	        }

	        return steps;
	    },

	    /* expandExponent for rational bases, taking into account negative
	     * exponents. Assumes abs(exp)>=1. */
	    expandFractionExponent: function(base_n, base_d, exp) {
	        if (Math.abs(exp) < 1) {
	            return "";
	        }

	        exp = Math.abs(exp);
	        var flip_n = exp > 0 ? base_n : base_d,
	            flip_d = exp > 0 ? base_d : base_n,
	            parens = function(n, d) {
	                return KhanUtil.fraction(n, d, true, true, false, true);
	            }, noParens = function(n, d) {
	                return KhanUtil.fraction(n, d, true, true, false, false);
	            }, base_str = parens(flip_n, flip_d),
	            expansion = "\\cdot" + base_str, steps = [], mult_n, mult_d;

	        steps.unshift(noParens(
	            Math.round(Math.pow(flip_n, exp)),
	            Math.round(Math.pow(flip_d, exp))));

	        for (var i = 1; i < exp; i++) {
	            mult_n = Math.round(Math.pow(flip_n, exp - i));
	            mult_d = Math.round(Math.pow(flip_d, exp - i));

	            steps.unshift(
	                (i === exp - 1 ? parens : noParens)
	                    .call(this, mult_n, mult_d) +
	                    expansion);

	            expansion += "\\cdot " + base_str;
	        }

	        return steps;
	    },

	    /* Given a base, returns the highest positive integer it is reasonable to
	     * raise that base to. */
	    maxReasonableExp: function(n) {
	        // The values are shown in comments to show that they're reasonable.
	        return {
	            0: 1000,
	            1: 1000,
	            2: 8,    // 2*2*2*2*2*2*2*2 = 256
	            3: 5,    // 3*3*3*3*3 = 243
	            4: 4,    // 4*4*4*4 = 256
	            5: 4,    // 5*5*5*5 = 625
	            6: 3,    // 6*6*6 = 216
	            7: 3,    // 7*7*7 = 343
	            8: 3,    // 8*8*8 = 512
	            9: 3,    // 9*9*9 = 729
	            10: 10  // 10^10 = 100000000000
	        }[Math.abs(n)];
	    },

	    /* Picks two bases and one root such that both bases can reasonably be taken
	     * to that root. The first base is chosen evenly from all the reasonable
	     * bases, and then the root is chosen from all the roots which it is
	     * reasonable to take that base to, and then the second base is chosen from
	     * all other bases which it is reasonable to take that base to. */
	    twoBasesOneRoot: function() {
	        var bases_by_root = {
	            //   1   2   3    4    5   6   7   8   9   10
	            2: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100],
	            3: [1, 8, 27, 64, 125],
	            4: [1, 16, 81, 256]
	        };

	        // these are all the bases that can be rooted.
	        var bases = bases_by_root[2]
	            .concat(bases_by_root[3])
	            .concat(bases_by_root[4]);

	        var roots_by_base = {};
	        for (var i = 0; i < bases.length; i++) {
	            var base = bases[i];
	            for (var j = 2; j <= 4; j++) {
	                if (_(bases_by_root[j]).indexOf(base) !== -1) {
	                    if (roots_by_base[base] === undefined) {
	                        roots_by_base[base] = [j];
	                    } else if (_(roots_by_base[base]).indexOf(j) === -1) {
	                        roots_by_base[base].push(j);
	                    }
	                }
	            }
	        }

	        var base_1 = KhanUtil.randFromArray(bases);

	        var root;
	        while (root === undefined || root === 1) {
	            root = KhanUtil.randFromArray(roots_by_base[base_1]);
	        }

	        var base_2;
	        while (base_2 === undefined || base_2 === base_1) {
	            base_2 = KhanUtil.randFromArray(bases_by_root[root]);
	        }

	        return {
	            base_1: base_1,
	            base_2: base_2,
	            root: root
	        };
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {

	    expr: function(expr, compute) {
	        if (typeof expr === "object") {
	            var op = expr[0],
	                args = expr.slice(1),
	                table = compute ? KhanUtil.computeOperators : KhanUtil.formatOperators;

	            return table[op].apply(this, args);
	        } else {
	            return compute ? expr : expr.toString();
	        }
	    },

	    exprType: function(expr) {

	        if (typeof expr === "object") {
	            if (expr[0] === "color") {
	                return KhanUtil.exprType(expr[2]);
	            }

	            return expr[0];

	        } else {

	            return typeof(expr);

	        }
	    },

	    // Do I start with a minus sign?
	    exprIsNegated: function(expr) {
	        switch (KhanUtil.exprType(expr)) {
	            case "color":
	            return KhanUtil.exprIsNegated(expr[2]);

	            case "/":
	            return KhanUtil.exprIsNegated(expr[1]);

	            case "+":
	            case "-":
	            return true;

	            case "number":
	            return expr < 0;

	            case "string":
	            return expr.charAt(0) === "-";

	            default:
	            // case "*":
	            return false;
	        }
	    },

	    // Mostly, is it okay to add a coefficient to me without adding parens?
	    exprIsShort: function(expr) {
	        switch (KhanUtil.exprType(expr)) {
	            case "color":
	            return KhanUtil.exprIsShort(expr[2]);

	            case "+":
	            case "-":
	            case "*":
	            case "/":
	            case "frac":
	            return false;

	            case "^":
	            return KhanUtil.exprType(expr[1]) !== "number" || expr[1] < 0;

	            case "number":
	            case "sqrt":
	            return true;

	            default:
	            return expr.length <= 1;
	        }
	    },

	    exprParenthesize: function(expr) {
	        return KhanUtil.exprIsShort(expr) ?
	            KhanUtil.expr(expr) :
	            "(" + KhanUtil.expr(expr) + ")";
	    },

	    formatOperators: {
	        "color": function(color, arg) {

	            // Arguments should look like ["blue", [...]]
	            return "\\color{" + color + "}{" + KhanUtil.expr(arg) + "}";
	        },

	        "+": function() {
	            var args = [].slice.call(arguments, 0);
	            var terms = $.grep(args, function(term, i) {
	                return term != null;
	            });

	            // Remove terms that evaluate to 0
	            terms = _.filter(terms, function(term) {
	                return "" + KhanUtil.expr(term) !== "0";
	            });

	            terms = $.map(terms, function(term, i) {
	                var parenthesize;
	                switch (KhanUtil.exprType(term)) {
	                    case "+":
	                    parenthesize = true;
	                    break;

	                    case "-":
	                    parenthesize = (term.length > 2);
	                    break;

	                    default:
	                    // case "*":
	                    // case "/":
	                    // case "^":
	                    parenthesize = false;
	                }

	                term = KhanUtil.expr(term);

	                if (parenthesize) {
	                    term = "(" + term + ")";
	                }

	                if (term.charAt(0) !== "-" || parenthesize) {
	                    term = "+" + term;
	                }

	                return term;
	            });

	            var joined = terms.join("");

	            if (joined.charAt(0) === "+") {
	                return joined.slice(1);
	            } else {
	                return joined;
	            }
	        },

	        "-": function() {
	            if (arguments.length === 1) {
	                return KhanUtil.expr(["*", -1, arguments[0]]);
	            } else {
	                var args = [].slice.call(arguments, 0);
	                var terms = $.map(args, function(term, i) {
	                    var negate = KhanUtil.exprIsNegated(term);
	                    var parenthesize;
	                    switch (KhanUtil.exprType(term)) {
	                        case "+":
	                        case "-":
	                        parenthesize = true;
	                        break;

	                        default:
	                        // case "*":
	                        // case "/":
	                        // case "^":
	                        parenthesize = false;
	                    }

	                    term = KhanUtil.expr(term);

	                    if ((negate && i > 0) || parenthesize) {
	                        term = "(" + term + ")";
	                    }

	                    return term;
	                });

	                var joined = terms.join("-");

	                return joined;
	            }
	        },

	        "*": function() {
	            var rest = Array.prototype.slice.call(arguments, 1);
	            rest.unshift("*");

	            // If we're multiplying by 1, ignore it, unless we have ["*", 1] and
	            // should return 1
	            if (arguments[0] === 0) {
	                return 0;
	            } else if (arguments[0] === 1 && rest.length > 1) {
	                return KhanUtil.expr(rest);
	            } else if (arguments[0] === -1 && rest.length > 1) {
	                var form = KhanUtil.expr(rest);
	                if (KhanUtil.exprIsNegated(rest[1])) {
	                    return "-(" + form + ")";
	                } else {
	                    return "-" + form;
	                }
	            }

	            if (arguments.length > 1) {
	                var args = [].slice.call(arguments, 0);
	                var parenthesizeRest = KhanUtil.exprType(arguments[0]) === "number" &&
	                    KhanUtil.exprType(arguments[1]) === "number";
	                var factors = $.map(args, function(factor, i) {
	                    var parenthesize;
	                    switch (KhanUtil.exprType(factor)) {
	                        case "number":
	                        if (i > 0) {
	                            parenthesize = true;
	                        }
	                        break;

	                        default:
	                        parenthesize = !KhanUtil.exprIsShort(factor);
	                        break;
	                    }

	                    parenthesizeRest = parenthesizeRest || parenthesize;
	                    factor = KhanUtil.expr(factor);

	                    if (parenthesizeRest) {
	                        factor = "(" + factor + ")";
	                    }

	                    return factor;
	                });

	                return factors.join("");
	            } else {
	                return KhanUtil.expr(arguments[0]);
	            }
	        },

	        "times": function(left, right) {
	            var parenthesizeLeft = !KhanUtil.exprIsShort(left);
	            var parenthesizeRight = !KhanUtil.exprIsShort(right);

	            left = KhanUtil.expr(left);
	            right = KhanUtil.expr(right);

	            left = parenthesizeLeft ? "(" + left + ")" : left;
	            right = parenthesizeRight ? "(" + right + ")" : right;

	            return left + " \\times " + right;
	        },

	        "dot": function(left, right) {
	            var parenthesizeLeft = !KhanUtil.exprIsShort(left);
	            var parenthesizeRight = !KhanUtil.exprIsShort(right);

	            left = KhanUtil.expr(left);
	            right = KhanUtil.expr(right);

	            left = parenthesizeLeft ? "(" + left + ")" : left;
	            right = parenthesizeRight ? "(" + right + ")" : right;

	            return left + " \\cdot " + right;
	        },

	        "/": function(num, den) {
	            var parenthesizeNum = !KhanUtil.exprIsShort(num);
	            var parenthesizeDen = !KhanUtil.exprIsShort(den);

	            num = KhanUtil.expr(num);
	            den = KhanUtil.expr(den);

	            num = parenthesizeNum ? "(" + num + ")" : num;
	            den = parenthesizeDen ? "(" + den + ")" : den;

	            return num + "/" + den;
	        },

	        "frac": function(num, den) {
	            return "\\dfrac{" + KhanUtil.expr(num) + "}{" +
	                KhanUtil.expr(den) + "}";
	        },

	        "^": function(base, pow) {
	            if (pow === 0) {
	                return "";
	            } else if (pow === 1) {
	                return KhanUtil.expr(base);
	            }

	            var parenthesizeBase, trigFunction;
	            switch (KhanUtil.exprType(base)) {
	                case "+":
	                case "-":
	                case "*":
	                case "/":
	                case "^":
	                case "ln":
	                parenthesizeBase = true;
	                break;

	                case "number":
	                parenthesizeBase = base < 0;
	                break;

	                case "sin":
	                case "cos":
	                case "tan":
	                case "csc":
	                case "sec":
	                case "cot":
	                parenthesizeBase = false;
	                trigFunction = true;
	                break;

	                default:
	                parenthesizeBase = false;
	                trigFunction = false;
	            }

	            base = KhanUtil.expr(base);
	            if (parenthesizeBase) {
	                base = "(" + base + ")";
	            }

	            pow = KhanUtil.expr(pow);

	            if (trigFunction) {
	                return base.replace(/\\(\S+?)\{/, function(match, word) {
	                    return "\\" + word + "^{" + pow + "} {";
	                });
	            } else {
	                return base + "^{" + pow + "}";
	            }
	        },

	        "sqrt": function(arg) {
	            return "\\sqrt{" + KhanUtil.exprParenthesize(arg) + "}";
	        },

	        "sin": function(arg) {
	            return "\\sin{" + KhanUtil.exprParenthesize(arg) + "}";
	        },

	        "cos": function(arg) {
	            return "\\cos{" + KhanUtil.exprParenthesize(arg) + "}";
	        },

	        "tan": function(arg) {
	            return "\\tan{" + KhanUtil.exprParenthesize(arg) + "}";
	        },

	        "sec": function(arg) {
	            return "\\sec{" + KhanUtil.exprParenthesize(arg) + "}";
	        },

	        "csc": function(arg) {
	            return "\\sec{" + KhanUtil.exprParenthesize(arg) + "}";
	        },

	        "cot": function(arg) {
	            return "\\sec{" + KhanUtil.exprParenthesize(arg) + "}";
	        },

	        "ln": function(arg) {
	            return "\\ln{" + KhanUtil.exprParenthesize(arg) + "}";
	        },

	        "+-": function() {
	            if (arguments.length === 1) {
	                return "\\pm " + KhanUtil.exprParenthesize(arguments[0]);
	            } else {
	                var args = [].slice.call(arguments, 0);
	                return $.map(args, function(term, i) {
	                    return KhanUtil.expr(term);
	                }).join(" \\pm ");
	            }
	        }
	    },

	    computeOperators: {
	        "color": function(color, arg) {
	            return KhanUtil.expr(arg, true);
	        },

	        "+": function() {
	            var args = [].slice.call(arguments, 0);
	            var sum = 0;

	            $.each(args, function(i, term) {
	                sum += KhanUtil.expr(term, true);
	            });

	            return sum;
	        },

	        "-": function() {
	            if (arguments.length === 1) {
	                return -KhanUtil.expr(arguments[0], true);
	            } else {
	                var args = [].slice.call(arguments, 0);
	                var sum = 0;

	                $.each(args, function(i, term) {
	                    sum += (i === 0 ? 1 : -1) * KhanUtil.expr(term, true);
	                });

	                return sum;
	            }
	        },

	        "*": function() {
	            var args = [].slice.call(arguments, 0);
	            var prod = 1;

	            $.each(args, function(i, term) {
	                prod *= KhanUtil.expr(term, true);
	            });

	            return prod;
	        },

	        "/": function() {
	            var args = [].slice.call(arguments, 0);
	            var prod = 1;

	            $.each(args, function(i, term) {
	                var e = KhanUtil.expr(term, true);
	                prod *= (i === 0 ? e : 1 / e);
	            });

	            return prod;
	        },

	        "^": function(base, pow) {
	            return Math.pow(KhanUtil.expr(base, true), KhanUtil.expr(pow, true));
	        },

	        "sqrt": function(arg) {
	            return Math.sqrt(KhanUtil.expr(arg, true));
	        },

	        "+-": function() {
	            return NaN;
	        }
	    },

	    // Remove ["color", ...] tags from an expression
	    exprStripColor: function(expr) {
	        if (typeof expr !== "object") {
	            return expr;
	        } else if (expr[0] === "color") {
	            return KhanUtil.exprStripColor(expr[2]);
	        } else {
	            return $.map(expr, function(el, i) {

	                // Wrap in an array because $.map flattens the result by one level
	                return [(i === 0) ? el : KhanUtil.exprStripColor(el)];
	            });
	        }
	    },

	    // simplify an expression by collapsing all the associative
	    // operations.  e.g. ["+", ["+", 1, 2], 3] -> ["+", 1, 2, 3]
	    exprSimplifyAssociative: function(expr) {
	        if (typeof expr !== "object") {
	            return expr;
	        }

	        var simplified = $.map(expr.slice(1), function(x) {
	            //encapsulate in a list so $.map unpacks it correctly
	            return [KhanUtil.exprSimplifyAssociative(x)];
	        });

	        var flattenOneLevel = function(e) {
	            switch (expr[0]) {
	                case "+":
	                if (e[0] === "+") {
	                    return e.slice(1);
	                }
	                break;

	                case "*":
	                if (e[0] === "*") {
	                    return e.slice(1);
	                }
	                break;
	            }
	            //make sure that we encapsulate e in an array so $'s map
	            //does't accidently unpacks e itself.
	            return [e];
	        };

	        //here we actually want the $ behavior of
	        //having any lists that flattenOneLevel returns merged into
	        //the result
	        var ret = $.map(simplified, flattenOneLevel);
	        ret.unshift(expr[0]);

	        return ret;
	    }
	});

	KhanUtil.computeOperators["frac"] = KhanUtil.computeOperators["/"];

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {
	    tabulate: function(fn, n) {
	        // Return an array, [fn(), fn(), ...] of length n if fn does not take arguments
	        // or the array [fn(0), fn(1), ..., fn(n - 1)] if it does
	        return $.map(new Array(n), function(val, i) {
	            return [fn(i)];
	        });
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var eps = 1e-9;
	var eq = function(x, y) { return Math.abs(x - y) < eps; };
	var signum = function(x) { return eq(x, 0) ? 0 : x / Math.abs(x); };

	var sub = function(p1, p2) { return {x: p1.x - p2.x, y: p1.y - p2.y}; };
	var len = function(p) { return Math.sqrt(p.x * p.x + p.y * p.y); };
	var dist = function(p1, p2) { return len(sub(p1, p2)); };
	var dot = function(p1, p2) { return p1.x * p2.x + p1.y * p2.y; };
	var cross = function(p1, p2) { return p1.x * p2.y - p1.y * p2.x; };
	var ccw = function(p1, p2, p3) { return cross(sub(p2, p1), sub(p3, p1)); };

	var Geom = {
	    convexhull: function(points) {
	        var v0;

	        _.each(points, function(p) {
	            if (v0 == null || p.x < v0.x - eps ||
	                    (eq(p.x, v0.x) && p.y < v0.y)) {
	                v0 = p;
	            }
	        });

	        points = points.slice(0);
	        points.sort(function(a, b) {
	            if (a === v0) {
	                return -1;
	            } else if (b === v0) {
	                return 1;
	            }

	            var c = ccw(v0, a, b);
	            if (eq(c, 0)) {
	                var d1 = dist(v0, a);
	                var d2 = dist(v0, b);

	                if (d1 < d2) {
	                    return -1;
	                } else if (d1 > d2) {
	                    return 1;
	                } else {
	                    return 0;
	                }
	            } else {
	                return -signum(c);
	            }
	        });

	        var ch = [];
	        _.each(points, function(p) {
	            while (ch.length >= 2 &&
	                    ccw(ch[ch.length - 2], ch[ch.length - 1], p) <= eps) {
	                ch.pop();
	            }
	            ch.push(p);
	        });

	        return ch;
	    },

	    /**
	     * Return a list of angles between 0 and 2 pi, in radians, through
	     * which the passed-in set of points have rotational symmetry (about
	     * the origin).
	     */
	    rotationalSymmetries: function(points) {
	        var n = points.length,
	            v0 = points[0],
	            angles = [],
	            tau = 2 * Math.PI;

	        out: for (var i = 1; i < n; i++) {
	            var v1 = points[i];

	            var mag = len(v0) * len(v1);
	            var cos = dot(v0, v1) / mag;
	            var sin = -cross(v0, v1) / mag;

	            for (var j = 0; j < n; j++) {
	                var p = points[(i + j) % n];
	                var rotP = {
	                    x: cos * p.x - sin * p.y,
	                    y: sin * p.x + cos * p.y
	                };

	                if (!eq(dist(rotP, points[j]), 0.0)) {
	                    // Points don't line up; no good.
	                    continue out;
	                }
	            }

	            var angle = (eps + tau + Math.atan2(sin, cos)) % tau - eps;
	            if (!eq(angle, 0.0)) {
	                angles.push(angle);
	            }
	        }

	        angles = KhanUtil.sortNumbers(angles);
	        angles = _.uniq(angles, /* isSorted: */ true, function() {
	            return KhanUtil.roundToNearest(eps);
	        });

	        return angles;
	    }
	};

	KhanUtil.Geom = Geom;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(3);
	var kmatrix = __webpack_require__(38);
	var kvector = __webpack_require__(9);

	$.extend(KhanUtil, {
	    // make a 3d object, which holds the vertices,
	    //   faces, and perspective of an object
	    make3dObject: function(verts, options) {
	        var object = $.extend({
	            verts: verts,
	            perspective: kmatrix.makeMatrix([
	                [1, 0, 0, 0],
	                [0, 1, 0, 0],
	                [0, 0, 1, 0],
	                [0, 0, 0, 1]
	            ]),
	            scale: 5.0,
	            faces: [],
	            sketches: [],
	            facesTransparent: true,
	            faceBorder: false

	        }, options);

	        var graph = KhanUtil.currentGraph;

	        // set the scale
	        object.setScale = function(scale) {
	            object.scale = scale;
	        };

	        // set and offset the camera pos
	        object.offsetPos = function(offset) {
	            this.perspective[0][3] += offset[0];
	            this.perspective[1][3] += offset[1];
	            this.perspective[2][3] += offset[2];
	        };

	        object.setPos = function(pos) {
	            this.perspective[0][3] = pos[0];
	            this.perspective[1][3] = pos[1];
	            this.perspective[2][3] = pos[2];
	        };

	        // perform a rotation of ang around the vector (x, y, z)
	        object.rotate = function(x, y, z, ang) {
	            var s = Math.sin(ang);
	            var c = Math.cos(ang);

	            // stolen from the OpenGL glRotate man page
	            var rotation = kmatrix.makeMatrix([
	                [x*x*(1-c)+c,   x*y*(1-c)-z*s, x*z*(1-c)+y*s, 0],
	                [y*x*(1-c)+z*s, y*y*(1-c)+c,   y*z*(1-c)-x*s, 0],
	                [x*z*(1-c)-y*s, y*z*(1-c)+x*s, z*z*(1-c)+c,   0],
	                [0,             0,             0,             1]
	            ]);

	            this.perspective = kmatrix.matrixMult(this.perspective, rotation);
	        };

	        // perform the perspective transformation stored in
	        //   object.perspective on a 3d point
	        object.doPerspective = function(pt) {
	            var newpt = KhanUtil.arrayToColumn(pt);

	            newpt[3] = [-1];

	            var result = kmatrix.matrixMult(this.perspective, newpt);

	            return KhanUtil.columnToArray(result).slice(0, 3);
	        };

	        // perform the perspective rotation sorted in object.perspective
	        //   on a 3d vector (doesn't perform translation)
	        object.doRotation = function(pt) {
	            var newpt = KhanUtil.arrayToColumn(pt);

	            newpt[3] = [0];

	            var result = kmatrix.matrixMult(this.perspective, newpt);

	            return KhanUtil.columnToArray(result).slice(0, 3);
	        };

	        // perform the perspective transformation and then project
	        //   the 3d point onto a 2d screen
	        object.doProjection = function(pt) {
	            var p = this.doPerspective(pt);

	            var x1 = p[0] * (this.scale / p[2]);
	            var y1 = p[1] * (this.scale / p[2]);

	            return [x1, y1];
	        };

	        // add a face to the object, with verts being indices of the
	        //   object.verts array
	        object.addFace = function(options) {
	            var face = $.extend(true, {
	                verts: [],
	                color: "black",
	                lines: [],
	                labels: [],
	                infront: false
	            }, options);

	            // compute the normal of a face
	            face.normal = function() {
	                var a = object.verts[this.verts[0]];
	                var b = object.verts[this.verts[1]];
	                var c = object.verts[this.verts[2]];

	                var ab = [b[0] - a[0], b[1] - a[1], b[2] - a[2]];
	                var ac = [c[0] - a[0], c[1] - a[1], c[2] - a[2]];

	                var normal = [
	                    ab[1] * ac[2] - ab[2] * ac[1],
	                    ab[2] * ac[0] - ab[0] * ac[2],
	                    ab[0] * ac[1] - ab[1] * ac[0]
	                ];

	                var length = kvector.length(normal);

	                return _.map(normal, function(e) { return e / length; });
	            };

	            // find the array of the projected points of the face
	            face.mappedVerts = function() {
	                return _.map(this.verts, function(v) {
	                    return object.doProjection(object.verts[v]);
	                });
	            };

	            // find the zdepth of the face. i.e. how close the face is to the
	            // camera
	            face.zDepth = function() {
	                var a = object.verts[this.verts[0]];
	                var b = object.verts[this.verts[1]];
	                var c = object.verts[this.verts[2]];

	                var x = a[0] + b[0] + c[0];
	                var y = a[1] + b[1] + c[1];
	                var z = a[2] + b[2] + c[2];
	                return object.doPerspective([x, y, z])[2];
	            };

	            // create a path of the face
	            face.path = function() {
	                return graph.path(
	                    face.mappedVerts(),
	                    { fill: face.color, stroke: false }
	                );
	            };

	            face.drawBorder = function() {
	                return graph.path(
	                    face.mappedVerts().concat(true),
	                    { fill: null, stroke: "#666", opacity: 1 }
	                );
	            };

	            // draw the face's lines
	            face.drawLines = function() {
	                var set = graph.raphael.set();

	                _.each(this.lines, function(line) {
	                    set.push(
	                        graph.line(
	                            object.doProjection(line[0]),
	                            object.doProjection(line[1]),
	                            {
	                                stroke: "black",
	                                strokeDasharray: ". "
	                            }
	                        )
	                    );
	                });

	                return set;
	            };

	            // draw the face's labels
	            face.drawLabels = function() {
	                _.each(this.labels, function(label) {
	                    var normal = face.normal();
	                    var newpt = [0.2 * normal[0] + label[0][0],
	                                 0.2 * normal[1] + label[0][1],
	                                 0.2 * normal[2] + label[0][2]];
	                    var pt = object.doProjection(newpt);

	                    if (label.label == null) {
	                        label.label = graph.label(pt, label[1]);
	                    } else {
	                        label.label.setPosition(pt);
	                    }
	                });
	            };

	            // draw all the objects on the face and return the set of them all
	            face.draw = function() {
	                var set = graph.raphael.set();

	                set.push(face.path());
	                set.push(face.drawLines());

	                face.drawLabels();

	                return set;
	            };

	            // draw the face in the back, which is just the outline
	            face.drawBack = function() {
	                if (object.facesTransparent) {
	                    return graph.path(face.mappedVerts(),
	                        { fill: null, stroke: "#666", opacity: 0.1 });
	                }
	            };

	            face.toFront = function() {
	                this.infront = true;
	            };

	            face.toBack = function() {
	                this.infront = false;

	                _.each(this.labels, function(label) {
	                    if (label.label != null) {
	                        label.label.remove();
	                        label.label = null;
	                    }
	                });
	            };

	            this.faces.push(face);

	            return this;
	        };

	        // add a sketch to the object, which is a path that always gets drawn
	        object.addSketch = function(options) {
	            var sketch = $.extend(true, {
	                verts: [],
	                color: "black",
	                lines: [],
	                labels: [],
	                opacityValue: 0.1
	            }, options);

	            // find the array of the projected points of the sketch
	            sketch.mappedVerts = function() {
	                return _.map(this.verts, function(v) {
	                    return object.doProjection(object.verts[v]);
	                });
	            };

	            // create a path of the sketch
	            sketch.path = function() {
	                return graph.path(
	                    sketch.mappedVerts(),
	                    { fill: sketch.color, stroke: true }
	                );
	            };

	            // draw the sketch's lines
	            sketch.drawLines = function() {
	                return graph.path(
	                    sketch.mappedVerts(),
	                    { fill: null, stroke: "#666", opacity: sketch.opacityValue }
	                );
	            };

	            // draw all the objects on the face and return the set of them all
	            sketch.draw = function() {
	               return  graph.raphael.set().push(sketch.drawLines());
	            };

	            this.sketches.push(sketch);
	            return this;
	        };

	        // draw the object, performing backface culling to ensure
	        //   faces don't intersect each other
	        object.draw = function() {
	            var frontFaces = [];
	            var backFaces = [];
	            var faces = object.faces.slice();

	            // Sort the objects faces by their zDepth, so that faces further
	            // away are drawn first. This is the "painters" algorithm, which
	            // should be fine for our purposes. If we ever end up in a
	            // situation where we need to draw configurations with nontrivial
	            // cycles, we will really need more powerful 3d capabilities
	            // e.g. webGL
	            faces.sort(function(a, b) {
	                    return a.zDepth() - b.zDepth();
	                });

	            // figure out which objects should be drawn in front,
	            // and which in back
	            _.each(faces, function(face) {
	                var vert = object.doPerspective(object.verts[face.verts[0]]);
	                var normal = face.normal();
	                if (kvector.dot(object.doRotation(normal), vert) < 0) {
	                    frontFaces.push(face);
	                } else {
	                    backFaces.push(face);
	                }
	            });


	            // draw each of the faces, and store it in a raphael set
	            var image = graph.raphael.set();
	            _.each(frontFaces, function(face) {
	                face.toFront();
	                image.push(face.draw());
	                if (object.faceBorder) {
	                    image.push(face.drawBorder());
	                }
	            });
	            _.each(backFaces, function(face) {
	                face.toBack();
	                image.push(face.drawBack());
	            });
	            _.each(object.sketches, function(sketch) {
	                image.push(sketch.draw());
	            });

	            return image;
	        };

	        // a list of the current and next frame
	        // each time a new one is created, the old one is
	        // removed later to avoid fast flickering
	        object.images = [graph.raphael.set()];

	        // whether or not an image is pending for deletion,
	        // in which case we shouldn't draw again
	        object.drawPending = false;

	        // do the full double-buffered drawing
	        object.doDraw = function() {
	            // only draw if we don't have a second frame waiting
	            if (!this.drawPending) {
	                this.drawPending = true;

	                // do the drawing, and store the new frame
	                this.images.push(this.draw());

	                // defer removing the old frame
	                _.defer(function() {
	                    object.images.shift().remove();
	                    object.drawPending = false;
	                });
	            }
	        };

	        return object;
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(10);
	__webpack_require__(3);

	/**
	 * Provides a concise API for drawing static versions of the 2D
	 * geometrical constructs found in interactive.js, consistent with
	 * the originals in style.
	 */

	// Expand an object's whitelisted non-array keys into arrays of length n
	// e.g. expandKeys({foo: 1, bar: 2}, ["foo"], 3) -> {foo: [1, 1, 1], bar: 2}
	var expandKeys = function(obj, keys, n) {
	    _.each(keys, function(key) {
	        var value = obj[key];
	        if (!_.isArray(value)) {
	            obj[key] = _.times(n, function() {
	                return value;
	            });
	        }
	    });
	};

	var normalStyle = {
	    stroke: KhanUtil.BLACK,
	    strokeWidth: 2,
	    strokeOpacity: 1,
	    strokeDasharray: "",
	    fill: KhanUtil.BLACK,
	    fillOpacity: 0,
	    color: KhanUtil.BLACK
	};

	var labelStyle = _.extend({}, normalStyle, {
	    strokeWidth: 1
	});

	// Return a copy of the object with all camelCase keys converted to dashed-case
	var toDashed = function(obj) {
	    var keys = _.map(_.keys(obj), function(key) {
	        return key.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
	    });
	    return _.object(keys, _.values(obj));
	};

	// Return the normal and label styles for a given options object
	var getStyles = function(options) {
	    // Color overrides stroke and fill if not present
	    if (_.has(options, "color")) {
	        _.defaults(options, {
	            stroke: options.color,
	            fill: options.color
	        });
	    }

	    // Dasharray can combine dashes and dots
	    if (options.dashed && options.dotted) {
	        options.strokeDasharray = "- .";
	    } else if (options.dashed) {
	        options.strokeDasharray = "- ";
	    } else if (options.dotted) {
	        options.strokeDasharray = ". ";
	    }

	    return {
	        normalStyle: toDashed(_.extend({}, normalStyle, options)),
	        labelStyle: toDashed(_.extend({}, labelStyle, options))
	    };
	};

	$.extend(KhanUtil.Graphie.prototype, {

	    drawPoint: function(options) {
	        var graphie = this;

	        _.defaults(options, {
	            point: [0, 0],
	            label: ""
	        });

	        var styles = getStyles(options);

	        return graphie.addMovablePoint({
	            coord: options.point,
	            constraints: {fixed: true},
	            vertexLabel: options.label,
	            normalStyle: _.extend(styles.normalStyle, {"fill-opacity": 1}),
	            labelStyle: styles.labelStyle
	        });
	    },

	    drawSegment: function(options) {
	        var graphie = this;

	        // Instead of two points, can specify a point and an angle/radius
	        if (_.has(options, "point")) {
	            var radius = options.radius || 5;
	            var angle = options.angle || 0;
	            var offset = graphie.polar(radius, angle);
	            options.points = [
	                options.point,
	                graphie.addPoints(options.point, offset)
	            ];
	        }

	        _.defaults(options, {
	            points: [[-5, 0], [5, 0]],
	            sideLabel: "",
	            vertexLabels: "",
	            showPoints: false,
	            line: false,
	            ray: false
	        });

	        expandKeys(options, ["vertexLabels", "showPoints"], 2);

	        var styles = getStyles(options);

	        _.each(options.showPoints, function(showPoint, i) {
	            if (showPoint) {
	                graphie.drawPoint(_.extend(options, {
	                    point: options.points[i]
	                }));
	            }
	        });

	        return graphie.addMovableLineSegment({
	            coordA: options.points[0],
	            coordZ: options.points[1],
	            fixed: true,
	            extendLine: options.line,
	            extendRay: options.ray,
	            sideLabel: options.sideLabel,
	            vertexLabels: options.vertexLabels,
	            normalStyle: styles.normalStyle,
	            labelStyle: styles.labelStyle
	        });
	    },


	    drawLine: function(options) {
	        return this.drawSegment(_.extend(options, {
	            line: true,
	            ray: false
	        }));
	    },

	    drawRay: function(options) {
	        return this.drawSegment(_.extend(options, {
	            line: false,
	            ray: true
	        }));
	    },

	    drawPolygon: function(options) {
	        var graphie = this;

	        // Shorthand defaults for all per angle/side/vertex properties
	        var defaults = {
	            angleLabels: "",
	            showRightAngleMarkers: true,
	            sideLabels: "",
	            vertexLabels: "",
	            arcs: 0,
	            arrows: 0,
	            ticks: 0,
	            showPoints: false
	        };

	        _.defaults(options, defaults, {
	            points: [[3, -2], [0, 4], [-3, -2]]
	        });

	        expandKeys(options, _.keys(defaults), options.points.length);

	        var styles = getStyles(_.omit(options, "arrows"));

	        _.each(options.showPoints, function(showPoint, i) {
	            if (showPoint) {
	                graphie.drawPoint(_.extend(options, {
	                    point: options.points[i]
	                }));
	            }
	        });

	        return graphie.addMovablePolygon(_.extend(options, {
	            fixed: true,
	            numArcs: options.arcs,
	            numArrows: options.arrows,
	            numTicks: options.ticks,
	            normalStyle: styles.normalStyle,
	            labelStyle: styles.labelStyle
	        }));
	    },

	    drawArc: function(options) {
	        var graphie = this;

	        if (_.has(options, "radius")) {
	            _.defaults(options, {
	                radii: options.radius
	            });
	        }

	        _.defaults(options, {
	            center: [0, 0],
	            radii: 5,
	            start: 45,
	            end: 135,
	            sector: false
	        });

	        // Fill arcs by drawing an unstroked sector
	        if (!options.sector && options.fillOpacity !== 0) {
	            graphie.drawSector(_.extend({}, options, {
	                strokeOpacity: 0
	            }));
	            options.fillOpacity = 0;
	        }

	        var styles = getStyles(options);

	        return graphie.arc(
	            options.center,
	            options.radii,
	            options.start,
	            options.end,
	            options.sector,
	            styles.normalStyle
	        );
	    },

	    drawSector: function(options) {
	        return this.drawArc(_.extend(options, {
	            sector: true
	        }));
	    },

	    drawEllipse: function(options) {
	        var graphie = this;

	        if (_.has(options, "radius")) {
	            _.defaults(options, {
	                radii: options.radius
	            });
	        }

	        _.defaults(options, {
	            center: [0, 0],
	            radii: [2, 5]
	        });

	        var styles = getStyles(options);

	        return graphie.ellipse(
	            options.center,
	            options.radii,
	            styles.normalStyle
	        );
	    },

	    drawCircle: function(options) {
	        _.defaults(options, {
	            radius: 5
	        });

	        return this.drawEllipse(options);
	    },

	    drawAngleLabel: function(options) {
	        var graphie = this;

	        _.defaults(options, {
	            points: [],
	            label: "",
	            showRightAngleMarker: true,
	            distance: 0,
	            arcs: 1
	        });

	        var styles = getStyles(options);

	        return graphie.labelAngle({
	            point1: options.points[0],
	            vertex: options.points[1],
	            point3: options.points[2],
	            clockwise: true,
	            text: options.label,
	            showRightAngleMarker: options.showRightAngleMarker,
	            numArcs: options.arcs,
	            pushOut: options.distance,
	            style: styles.labelStyle
	        });
	    }

	    // TODO(alex): drawPolyline(), drawSpokes(), labelSegment()
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(3);
	var kline = __webpack_require__(5);
	var kmatrix = __webpack_require__(38);

	// TODO(eater): shove these into KhanUtil or somewhere reasonable

	window.rotatePoint = function(p, deg, c) {
	    c = c || [0, 0];
	    var rad = KhanUtil.toRadians(deg),
	        cos = Math.cos(rad),
	        sin = Math.sin(rad),
	        cx = c[0],
	        cy = c[1],
	        px = p[0],
	        py = p[1],
	        x = cx + (px - cx) * cos - (py - cy) * sin,
	        y = cy + (px - cx) * sin + (py - cy) * cos;
	    return [KhanUtil.roundTo(9, x), KhanUtil.roundTo(9, y)];
	};

	$.extend(KhanUtil, {
	    rightAngleBox: function(path1, path2, style) {
	        var graph = KhanUtil.currentGraph;

	        var size = 0.5;

	        var intersection = findIntersection(path1, path2),
	        path = [intersection],
	        curr = graph.cartToPolar(intersection)[1],
	        offset;

	        for (var i = 1; i < 4; i++) {
	            offset = graph.polar(size, curr);

	            path.push([path[i - 1][0] - offset[0],
	                       path[i - 1][1] - offset[1]]);

	            curr -= 90;
	        }

	        path.push(intersection);

	        return graph.path(path, style);
	    },

	    parallel: function(path, num, style) {
	        var graph = KhanUtil.currentGraph;

	        var point = kline.midpoint(path);

	        graph.path([path[0], point], $.extend(style, { arrows: "->" }));
	    },

	    congruent: function(path, num, style) {
	        var graph = KhanUtil.currentGraph;

	        var spacing = 5, scale = 5;

	        for (var i = 0; i < num; i++) {
	            var sPath = _.map(path, graph.scalePoint),
	            sPoint = kline.midpoint(sPath),
	            angle = Math.atan((sPath[0][1] - sPath[1][1]) / (sPath[0][0] - sPath[1][0])),
	            perpangle = angle + Math.PI / 2;

	            var sMarkPath = [[sPoint[0] + Math.cos(angle)*spacing*i + Math.cos(perpangle)*scale,
	                              sPoint[1] + Math.sin(angle)*spacing*i + Math.sin(perpangle)*scale],
	                             [sPoint[0] + Math.cos(angle)*spacing*i - Math.cos(perpangle)*scale,
	                              sPoint[1] + Math.sin(angle)*spacing*i - Math.sin(perpangle)*scale]];

	            graph.path(_.map(sMarkPath, graph.unscalePoint), style);
	        }
	    }
	});

	window.lineLength = function(line) {
	    var a = line[0];
	    var b = line[1];
	    return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));
	};

	//Takes an array and an array of positions, all elements whose index is not in the positions array gets replaced by ""
	//Very useful for labels, for example, clearArray(["x", "x", "x"], [ANGLE]), where ANGLE is 1, will give you ["", "x", ""], which you can use to label angles in a Triangle such that the second angle is labeled x

	window.clearArray = function(arr, i) {
	    return $.map(arr, function(el, index) {
	        if ($.inArray(index, i) !== -1) {
	            return el;
	        }
	        else {
	            return "";
	       }
	    });
	};

	//Used together with clearArray, for example mergeArray(clearArray(["x", "x", "x"], [ANGLE]), ["a","b","c"]), where ANGLE is 1, gives labels for a triangle ["a", "x", "c"]
	//need to be same length
	window.mergeArray = function(ar1, ar2) {
	    var i = 0;
	    for (i = 0; i < ar1.length; i++) {
	        if (ar1[i] === "") {
	            ar1[i] = ar2[i];
	        }
	    }
	    return ar1;
	};

	window.isPointOnLineSegment = function(l, p, precision) {
	    precision = precision || 0.1;
	    //If line is vertical
	    if (Math.abs(l[1][0] - l[0][0]) < precision) {
	        return (Math.abs(p[0] - l[0][0]) < precision) && (p[1] <= (Math.max(l[1][1], l[0][1]) + precision)) && (p[1] >= (Math.min(l[1][1], l[0][1]) - precision));
	    }
	    var m = (l[1][1] - l[0][1]) / (l[1][0] - l[0][0]);
	    var k = l[0][1] - m * l[0][0];
	    return (Math.abs(m * p[0] + k - p[1]) < precision);
	};

	//Are two polygons intersecting
	window.areIntersecting = function(pol1, pol2) {
	    var i, k = 0;
	    for (i = 0; i < pol1.length; i++) {
	        for (k = 0; k < pol2.length; k++) {
	            if (findIntersection(pol1[i], pol2[k])[2]) {
	                return true;
	            }
	        }
	    }
	    return false;
	};


	//Returns an intersection of two lines, and whether that point is inside both line segments
	window.findIntersection = function(a, b) {
	    var tY = [0, a[0][1], a[1][1], b[0][1], b[1][1]];
	    var tX = [0, a[0][0], a[1][0], b[0][0], b[1][0]];

	    var denominator = (tY[4] - tY[3]) * (tX[2] - tX[1]) - (tX[4] - tX[3]) * (tY[2] - tY[1]);
	    var ua = ((tX[4] - tX[3]) * (tY[1] - tY[3]) - (tY[4] - tY[3]) * (tX[1] - tX[3])) / denominator;
	    var ub = ((tX[2] - tX[1]) * (tY[1] - tY[3]) - (tY[2] - tY[1]) * (tX[1] - tX[3])) / denominator;
	    var isContained = (ua >= -0.01) && (ua <= 1.01) && (ub >= -0.01) && (ub <= 1.01);
	    return [tX[1] + ua * (tX[2] - tX[1]), tY[1] + ua * (tY[2] - tY[1]), isContained];
	};

	window.degToRad = function(deg) {
	    return deg * Math.PI / 180;
	};

	//Returns [ m, k ] of y = mx + k
	//Vulnerable to division by 0
	window.lineEquation = function(line) {

	    var m = (line[1][1] - line[0][1]) / (line[1][0] - line[0][0]);
	    var k = line[0][1] - m * line[0][0];

	    return [m, k];

	};

	//Given a line, returns a segment of that line of length amount starting at start
	window.lineSegmentFromLine = function(start, line, amount) {

	    var eq = lineEquation(line);
	    var m = eq[0];
	    var angle = Math.atan(m);
	    return [start, [start[0] + Math.cos(angle) * amount, start[1] + Math.sin(angle) * amount]];

	};

	//Gives a line parralel to line going through point
	window.parallelLine = function(line, point) {

	    var dif = [point[0] - line[0][0], point[1] - line[0][1]];
	    return [point, [line[1][0] + dif[0], line[1][1] + dif[1]]];

	};

	window.movePoint = function(p, a) {

	    return [p[0] + a[0], p[1] + a[1]];
	};


	//Returns a line that bisects an angle defined by line1 and line2
	window.bisectAngle = function(line1, line2, scale) {
	    var intPoint = findIntersection(line1, line2);
	    var l1 = [];
	    var l2 = [];

	    if ((line1[1][0] - line1[0][0]) >= 0) {
	        l1 = lineSegmentFromLine(intPoint, line1, scale);
	    }
	    else {
	        l1 = lineSegmentFromLine(intPoint, line1, -scale);
	    }
	    if ((line2[1][0] - line2[0][0]) >= 0) {
	        l2 = lineSegmentFromLine(intPoint, line2, scale);
	    }
	    else {
	        l2 = lineSegmentFromLine(intPoint, line2, -scale);
	    }
	    return [intPoint, parallelLine(l1, l2[1])[1]];

	};

	window.vectorProduct = function(line1, line2) {
	    var x1 = line1[1][0] - line1[0][0];
	    var x2 = line2[1][0] - line2[0][0];
	    var y1 = line1[1][1] - line1[0][1];
	    var y2 = line2[1][1] - line2[0][1];
	    return x1 * y2 - x2 * y1;
	};

	//For [a, b] returns [b , a]
	window.reverseLine = function(line) {
	    return [line[1], line[0]];
	};

	window.Triangle = function(center, angles, scale, labels, points) {

	    var fromPoints = false;
	    if (points) {
	        fromPoints = true;
	    }

	    this.labels = labels;
	    if (fromPoints) {
	        this.points = points;
	        this.sides = [[this.points[0], this.points[1]], [this.points[1], this.points[2]] , [this.points[2], this.points[0]]];
	        this.sideLengths = $.map(this.sides, lineLength);
	        this.angles = anglesFromSides(this.sideLengths);
	    }
	    else {
	        this.angles = angles;
	    }

	    this.radAngles = $.map(angles, degToRad);
	    this.scale = (scale || 3);

	    this.cosines = $.map(this.radAngles, Math.cos);
	    this.sines = $.map(this.radAngles, Math.sin);


	    this.x = center[0];
	    this.y = center[1];
	    this.rotation = 0;

	    //Given the scale(which represensts the area of the triangle) and angles we want to find the side lengths.
	    //http://en.wikipedia.org/wiki/Triangle#Using_trigonometry. Using the ASA equation in the link, we find the length of one side.
	    var a = Math.sqrt((2 * this.scale * this.sines[1]) / (this.sines[0] * this.sines[2]));
	    var b = a * this.sines[2] / this.sines[1];
	    if (! fromPoints) {
	        this.points = [[this.x, this.y], [b + this.x, this.y], [this.cosines[0] * a + this.x, this.sines[0] * a + this.y]];
	    }
	    this.sides = [[this.points[0], this.points[1]], [this.points[1], this.points[2]] , [this.points[2], this.points[0]]];

	    this.sideLengths = $.map(this.sides, lineLength);

	    this.niceSideLengths = $.map(this.sideLengths, function(x) { return parseFloat(x.toFixed(1)); });

	    this.set = "";
	    this.niceAngles = $.map(this.angles, function(x) { return x + "^{\\circ}"; });
	    this.labelObjects = { "sides": [] , "angles" : [], "points" : [], "name" : [] };


	    this.angleScale = function(ang) {
	        if (ang > 150) {
	            return 0.8;
	        }
	        else if (ang > 140) {
	            return 0.7;
	        }
	        else if (ang > 130) {
	            return 0.6;
	        }
	        else if (ang > 90) {
	            return 0.5;
	        }
	        else if (ang > 40) {
	            return 0.6;
	        }
	        else if (ang > 25) {
	            return 0.7;
	        }
	        return 0.8;
	    };

	    this.draw = function() {
	        this.set = this.set || KhanUtil.currentGraph.raphael.set();
	        this.set.push(KhanUtil.currentGraph.path(this.points.concat([this.points[0]])));
	        return this.set;
	    };

	    this.color = "black";
	    this.createLabel = function(p, v) {
	        this.set = this.set || KhanUtil.currentGraph.raphael.set();
	        this.set.push(KhanUtil.currentGraph.label(p, v, "center", { color: this.color }));
	    };

	    this.boxOut = function(pol, amount) {
	        var shouldMove = areIntersecting(pol, this.sides);
	        while (areIntersecting(pol, this.sides)) {
	            this.translate(amount);
	        }
	        if (shouldMove) {
	            this.translate(amount);
	        }
	    };

	    this.boundingRange = function(margin) {
	        margin = margin || 0;
	        var X = $.map(this.points, function(p) { return p[0]; });
	        var Y = $.map(this.points, function(p) { return p[1]; });
	        return [[_.min(X) - margin, _.max(X) + margin],
	             [_.min(Y) - margin, _.max(Y) + margin]];
	    };

	    this.findCenterPoints = function() {
	        var Ax = this.points[0][0];
	        var Ay = this.points[0][1];
	        var Bx = this.points[1][0];
	        var By = this.points[1][1];
	        var Cx = this.points[2][0];
	        var Cy = this.points[2][1];
	        var D = 2 * (Ax * (By - Cy) + Bx * (Cy - Ay) + Cx * (Ay - By));
	        var a = this.sideLengths[1];
	        var b = this.sideLengths[2];
	        var c = this.sideLengths[0];
	        var P = a + b + c;
	        var x1 = (a * Ax + b * Bx + c * Cx) / P;
	        var y1 = (a * Ay + b * By + c * Cy) / P;
	        var x = ((Ay * Ay + Ax * Ax) * (By - Cy) + (By * By + Bx * Bx) * (Cy - Ay) + (Cy * Cy + Cx * Cx) * (Ay - By)) / D;
	        var y = ((Ay * Ay + Ax * Ax) * (Cx - Bx) + (By * By + Bx * Bx) * (Ax - Cx) + (Cy * Cy + Cx * Cx) * (Bx - Ax)) / D;
	        this.circumCenter = [x, y];
	        this.centroid = [1 / 3 * (Ax + Bx + Cx), 1 / 3 * (Ay + By + Cy)];
	        this.inCenter = [x1, y1];
	    };

	    this.findCenterPoints();

	    this.findRadii = function() {
	        this.semiperimeter = (this.sideLengths[0] + this.sideLengths[1] + this.sideLengths[2]) / 2;
	        this.inradius = this.scale / this.semiperimeter;
	        this.circumradius = this.sideLengths[0] * this.sideLengths[1] * this.sideLengths[2] / (4 * this.semiperimeter * this.inradius);
	    };

	    this.rotationCenter = this.centroid;

	    this.rotate = function(amount) {
	        amount = amount * Math.PI / 180;
	        var tr = this;
	        this.points = $.map(this.points, function(el, i) {
	                return [tr.rotatePoint(el, amount)];
	        });
	        this.genSides();
	        this.findCenterPoints();
	    };

	    this.genSides = function() {
	        this.sides = [];
	        var x = 0;
	        for (x = 0; x < this.points.length; x++) {
	            this.sides.push([this.points[x], this.points[(x + 1) % this.points.length]]);
	        }
	    };

	    this.translate = function(amount) {
	        this.points = $.map(this.points, function(el, i) {
	            return [movePoint(el, amount)];
	        });
	        this.genSides();
	        this.findCenterPoints();
	    };

	    this.rotatePoint = function(pos, theta) {
	        theta = theta || this.rotation;
	        return [this.rotationCenter[0] + (pos[0] - this.rotationCenter[0]) * Math.cos(theta) + (pos[1] - this.rotationCenter[1]) * Math.sin(theta), this.rotationCenter[1] + (-1) * ((pos[0] - this.rotationCenter[0]) * Math.sin(theta)) + ((pos[1] - this.rotationCenter[1]) * Math.cos(theta))];
	    };

	    this.drawLabels = function() {
	        var i = 0;
	        var s = KhanUtil.currentGraph.scaleVector([1, 1])[0];

	        if ("points" in this.labels) {
	            //Need to change the position of placement into label objects
	            for (i = this.angles.length - 1; i >= 0; i--) {
	                var n = (i + 1) % this.angles.length;
	                var coord = bisectAngle(reverseLine(this.sides[n]), this.sides[i], 12 / s)[1];
	                this.labelObjects.points.push(this.createLabel(coord, this.labels.points[n]));
	            }
	        }

	        if ("angles" in this.labels) {
	            for (i = this.angles.length - 1; i >= 0; i--) {
	                var n = (i + 1) % this.angles.length;
	                var coord = bisectAngle(this.sides[n], reverseLine(this.sides[i]), this.angleScale(this.angles[n]) * 45 / s)[1];
	                this.labelObjects.angles.push(this.createLabel(coord, this.labels.angles[n]));
	            }
	        }

	        if ("sides" in this.labels) {
	            for (i = 0; i < this.sides.length; i++) {
	                //http://www.mathworks.com/matlabcentral/newsreader/view_thread/142201
	                var midPoint = kline.midpoint(this.sides[i]);
	                var t = lineLength([this.sides[i][1], midPoint]);
	                var d = 15 / s;
	                var x3 = midPoint[0] + (this.sides[i][1][1] - midPoint[1]) / t * d;
	                var y3 = midPoint[1] - (this.sides[i][1][0] - midPoint[0]) / t * d;
	                this.labelObjects.sides.push(this.createLabel([x3, y3], this.labels.sides[i]));
	            }
	        }

	        if ("name" in this.labels) {
	            this.labelObjects["name"] = this.createLabel(bisectAngle(reverseLine(this.sides[2]), this.sides[1], 0.3)[1], this.labels.name);
	        }


	//DEPRECATED
	        if ("c" in this.labels) {
	            this.createLabel([(this.points[0][0] + this.points[1][0]) / 2, (this.points[0][1] + this.points[1][1]) / 2 - 0.4] , labels.c);
	        }
	        if ("a" in this.labels) {
	            this.createLabel([(this.points[1][0] + this.points[2][0]) / 2 + 0.4, (this.points[1][1] + this.points[2][1]) / 2] , labels.a);
	        }
	        if ("b" in this.labels) {
	            this.createLabel([(this.points[0][0] + this.points[2][0]) / 2 - 0.4, (this.points[0][1] + this.points[2][1]) / 2] , labels.b);
	        }


	        return this.set;
	    };

	};
	window.Quadrilateral = function(center, angles, sideRatio, labels, size) {

	    this.sideRatio = sideRatio;
	    this.angles = angles;
	    this.radAngles = $.map(angles, degToRad);
	    this.scale = 1;
	    this.rotation = 0;
	    this.x = center[0];
	    this.y = center[1];
	    this.rotationCenter = [center[0], center[1]];
	    this.set = "";
	    this.size = size || 10;
	    this.cosines = $.map(this.radAngles, Math.cos);
	    this.sines = $.map(this.radAngles, Math.sin);
	    this.labels = labels || {};
	    this.sides = [];

	    this.generatePoints = function() {
	        var once = false;
	        while ((! once) || this.isCrossed() || this.sideTooShort()) {
	            var len = Math.sqrt(2 * this.scale * this.scale * this.sideRatio * this.sideRatio - 2 * this.sideRatio * this.scale * this.scale * this.sideRatio * this.cosines[3]);
	            once = true;
	            var tX = [0, this.scale * this.sideRatio * this.cosines[0] , len * Math.cos((this.angles[0] - (180 - this.angles[3]) / 2) * Math.PI / 180), this.scale, this.scale + Math.cos((180 - this.angles[1]) * Math.PI / 180)];
	            var tY = [0, this.scale * this.sideRatio * this.sines[0] , len * Math.sin((this.angles[0] - (180 - this.angles[3]) / 2) * Math.PI / 180), 0, Math.sin((180 - this.angles[1]) * Math.PI / 180)];

	            var denominator = (tY[4] - tY[3]) * (tX[2] - tX[1]) - (tX[4] - tX[3]) * (tY[2] - tY[1]);

	            var ua = ((tX[4] - tX[3]) * (tY[1] - tY[3]) - (tY[4] - tY[3]) * (tX[1] - tX[3])) / denominator;

	            this.points = [[this.x, this.y], [this.x + this.scale * this.sideRatio * this.cosines[0], this.y + this.scale * this.sideRatio * this.sines[0]], [this.x + tX[1] + ua * (tX[2] - tX[1]), this.y + tY[1] + ua * (tY[2] - tY[1])], [this.x + this.scale, this.y]];

	            this.sides = [[this.points[0], this.points[3]], [this.points[3], this.points[2]], [this.points[2], this.points[1]], [this.points[1], this.points[0]]];
	            this.sideLengths = $.map(this.sides, lineLength);
	            this.niceSideLengths = $.map(this.sideLengths, function(x) { return parseFloat(x.toFixed(1)); });

	            if (vectorProduct([this.points[0], this.points[1]], [this.points[0], this.points[2]]) > 0) {
	                this.sideRatio -= 0.3;
	            }

	            if (vectorProduct([this.points[0], this.points[3]], [this.points[0], this.points[2]]) < 0) {
	                this.sideRatio += 0.3;
	            }

	            var tooShort = this.sideTooShort();
	            if (tooShort) {
	                if (tooShort.whichSide % 2 === 0) {
	                    this.sideRatio -= 0.05;
	                }
	                else {
	                    this.sideRatio += 0.05;
	                }
	            }
	        }
	    };

	    this.sideTooShort = function() {
	        if (this.sideRatio === 1) {
	            return false;
	        }
	        var shortestSide = _.min(this.sideLengths);
	        var allSides = _.reduce(this.sideLengths, function(acc,n) { return acc+n; }, 0);
	        return shortestSide/allSides < 0.12 && {whichSide:_.indexOf(this.sideLengths,shortestSide)};
	    };

	    this.isCrossed = function() {
	        return (vectorProduct([this.points[0], this.points[1]], [this.points[0], this.points[2]]) > 0) || (vectorProduct([this.points[0], this.points[3]], [this.points[0], this.points[2]]) < 0);
	    };

	    this.genSides = function() {
	        this.sides = [[this.points[0], this.points[3]], [this.points[3], this.points[2]], [this.points[2], this.points[1]], [this.points[1], this.points[0]]];
	    };

	    this.generatePoints();

	    var area = 0.5 * vectorProduct([this.points[0], this.points[2]], [this.points[3], this.points[1]]);
	    this.scale = this.scale * Math.sqrt(this.size / area);
	    this.generatePoints();

	    area = 0.5 * vectorProduct([this.points[0], this.points[2]], [this.points[3], this.points[1]]);

	};


	Quadrilateral.prototype = new Triangle([0, 0], [30, 30, 30], 3, "");

	//From http://en.wikipedia.org/wiki/Law_of_cosines
	window.anglesFromSides = function(sides) {
	        var c = sides[0];
	        var a = sides[1];
	        var b = sides[2];
	        var gamma = Math.round(Math.acos((a * a + b * b - c * c) / (2 * a * b)) * 180 / Math.PI);
	        var beta = Math.round(Math.acos((a * a + c * c - b * b) / (2 * a * c)) * 180 / Math.PI);
	        var alpha = Math.round(Math.acos((b * b + c * c - a * a) / (2 * b * c)) * 180 / Math.PI);
	        return [alpha, beta, gamma];
	};



	window.randomTriangleAngles = {

	        triangle: function() {
	            var a, b, c;
	            a = KhanUtil.randRange(30, 120);
	            b = KhanUtil.randRange(30, 150 - a);
	            c = 180 - a - b;
	            return [a, b, c];
	        },

	        scalene: function() {
	            var a, b, c;
	            do {
	                a = KhanUtil.randRange(30, 120);
	                b = KhanUtil.randRange(30, 150 - a);
	                c = 180 - a - b;
	            } while (a === b || a === c || b === c);
	            return [a, b, c];
	        },

	        isosceles: function() {
	            var a = KhanUtil.randRangeExclude(25, 75, [60]);
	            var c = 180 - 2 * a;
	            return KhanUtil.shuffle([a, a, c]);
	        },
	        equilateral: function() {
	            return [60, 60, 60];
	        }
	};


	window.randomQuadAngles = {

	        square: function() {
	            return [90, 90, 90, 90];
	        },

	        rectangle: function() {
	            return [90, 90, 90, 90];
	        },

	        rhombus: function() {
	            var angA, angB;
	            do {
	                angA = KhanUtil.randRange(30, 150);
	                angB = 180 - angA;
	            }while (Math.abs(angA - angB) < 5);
	            return [angA, angB, angA, angB];
	        },

	        parallelogram: function() {
	            var angA, angB;
	            do {
	                angA = KhanUtil.randRange(30, 150);
	                angB = 180 - angA;
	            } while (angA === angB);
	            return [angA, angB, angA, angB];
	        },

	        trapezoid: function() {
	            var angA, angB, angC, angD;
	            do {
	                angA = KhanUtil.randRange(30, 150);
	                angB = 180 - angA;
	                angC = KhanUtil.randRange(30, 150);
	                angD = 180 - angC;
	            } while (Math.abs(angA - angC) < 6 || angA + angC === 180);
	            return [angA, angC, angD, angB];
	        },

	        isoscelesTrapezoid: function() {
	            var angC, angD;
	            do {
	                angC = KhanUtil.randRange(30, 150);
	                angD = 180 - angC;
	            } while (angC === angD);
	            return [angC, angC, angD, angD];
	        },

	        kite: function() {
	            var angA, angB, angC;
	            do {
	                angA = KhanUtil.randRange(90, 140);
	                angB = KhanUtil.randRange(30, (360 - (2 * angA)) - 30);
	                angC = 360 - angB - 2 * angA;
	            } while (angA === angB);
	            return [angB, angA, angC, angA];
	        }
	};


	$.extend(KhanUtil, {

	    // Creates a representation of a weird blocky shape that you can find
	    // the perimeter or area of
	    createOddShape: function(options) {
	        var shape = $.extend({
	            width: 10,
	            height: 10,
	            squares: [],
	            sides: []
	        }, options);

	        // Start at the top of the shape and pick a random left and right
	        // edge for the top row.
	        var y = shape.height - 1;
	        var left = KhanUtil.randRange(0, shape.width - 1);
	        var right = KhanUtil.randRange(left + 1, shape.width);

	        // Add the top side
	        shape.sides.push({
	            start: [left, y],
	            end: [right, y],
	            length: right - left,
	            labelPos: "above"
	        });
	        // The y-positions where the next vertical line on the left and
	        // right sides of the figure starts.
	        var leftStart = y;
	        var rightStart = y;

	        // Add each square in the top row
	        _(right - left).times(function(dx) {
	            shape.squares.push([left + dx, y]);
	        });

	        // Iterate through each subsequent row
	        while (y > 2) {
	            y -= 1;
	            // Pick a new left and right edge for each row, with a 70%
	            // probability of continuing on the same row as the row above
	            var prevLeft = left;
	            var prevRight = right;
	            left = KhanUtil.randRangeWeighted(0, prevRight - 1, prevLeft, 0.7);
	            right = KhanUtil.randRangeWeighted(Math.max(left, prevLeft) + 1,
	                shape.width, prevRight, 0.7);

	            // Add each square in this row
	            _(right - left).times(function(dx) {
	                shape.squares.push([left + dx, y]);
	            });

	            // If the left side isn't the same as the row above,
	            // add a new vertical and horizontal side
	            if (left !== prevLeft) {
	                shape.sides.push({
	                    start: [prevLeft, leftStart],
	                    end: [prevLeft, y],
	                    length: leftStart - y,
	                    labelPos: "left"
	                });
	                shape.sides.push({
	                    start: [prevLeft, y],
	                    end: [left, y],
	                    length: Math.abs(left - prevLeft),
	                    labelPos: "center"
	                });
	                // record where the next vertical side on the left starts
	                leftStart = y;
	            }

	            // If the right side isn't the same as the row above,
	            // add a new vertical and horizontal side
	            if (right !== prevRight) {
	                shape.sides.push({
	                    start: [prevRight, rightStart],
	                    end: [prevRight, y],
	                    length: rightStart - y,
	                    labelPos: "right"
	                });
	                shape.sides.push({
	                    start: [prevRight, y],
	                    end: [right, y],
	                    length: Math.abs(right - prevRight),
	                    labelPos: "center"
	                });
	                // record where the next vertical side on the right starts
	                rightStart = y;
	            }
	        }

	        // Add the last left and right vertical sides
	        shape.sides.push({
	            start: [left, leftStart],
	            end: [left, 1],
	            length: leftStart - 1,
	            labelPos: "left"
	        });
	        shape.sides.push({
	            start: [right, rightStart],
	            end: [right, 1],
	            length: rightStart - 1,
	            labelPos: "right"
	        });

	        // Add the bottom side
	        shape.sides.push({
	            start: [left, 1],
	            end: [right, 1],
	            length: right - left,
	            labelPos: "below"
	        });

	        shape.perimeter = _.reduce(shape.sides, function(perimeter, side) {
	                return perimeter + side.length;
	            }, 0);

	        shape.area = shape.squares.length;

	        shape.numSides = shape.sides.length;

	        shape.labelSquares = function() {
	            _.each(shape.squares, function(square, n) {
	                KhanUtil.currentGraph.label([square[0] + 0.5, square[1] - 0.5],
	                    n + 1, "center", false);
	            });
	        };

	        shape.labelSides = function() {
	            _.each(shape.sides, function(side) {
	                KhanUtil.currentGraph.label([(side.start[0] + side.end[0]) / 2,
	                    (side.start[1] + side.end[1]) / 2], side.length,
	                    side.labelPos);
	            });
	        };

	        return shape;
	    }
	});


	// The following triangley code creates hopefully more legible triangles
	// TODO(eater): Collapse this stuff into the existing triangle code above
	//              without breaking a bunch of stuff (and refactor things so
	//              Quadrilateral no longer inherits from Triangle)
	//
	//            angles[0]
	//               /\
	//              /  \
	//    sides[1] /    \ sides[2]
	//            /      \
	//           /________\
	// angles[2]  sides[0]  angles[1]
	//

	// The following solves the triangle by filling in any side and angle measures
	// that were not included.
	//
	// The sides and angles included must unambiguously specify one triangle. duh.
	// If not, behavior is undefined.
	//
	KhanUtil.solveTriangle = function(triangle) {
	    var sides = triangle.sides;
	    var angles = triangle.angles;
	    var numSides = _.reduce(sides, function(n, side) {
	        return n + (typeof side === "number" ? 1 : 0);
	    }, 0);
	    var numAngles = _.reduce(angles, function(n, angle) {
	        return n + (typeof angle === "number" ? 1 : 0);
	    }, 0);

	    // If we have 2 sides, we must have the angle opposite the unknown side.
	    // (SAS is the only valid postulate in this case)
	    // We can use the law of cosines to find the third side
	    if (numSides === 2) {
	        var missingSide = sides.indexOf(null);
	        var side1 = sides[(missingSide + 1) % 3];
	        var side2 = sides[(missingSide + 2) % 3];
	        sides[missingSide] = Math.sqrt(side1 * side1 + side2 * side2 - 2 *
	            side1 * side2 * Math.cos(angles[missingSide] * Math.PI / 180));
	        numSides = 3;
	    }

	    // If we have all three sides, we can use the law of cosines to find all
	    // the angles
	    if (numSides === 3) {
	        // Use law of cosines to find all the angles
	        angles = _.map(angles, function(angle, n) {
	            var oppSide = sides[n];
	            var adjSide1 = sides[(n + 1) % 3];
	            var adjSide2 = sides[(n + 2) % 3];
	            return Math.acos((adjSide1 * adjSide1 + adjSide2 * adjSide2 -
	                oppSide * oppSide) / (2 * adjSide1 * adjSide2));
	        });
	        angles = _.map(angles, KhanUtil.toDegrees);
	    }

	    // If we have 2 angles, we can easily fill in the third angle
	    if (numAngles === 2) {
	        var missingAngle = angles.indexOf(null);
	        angles[missingAngle] = 180 - angles[(missingAngle + 1) % 3] -
	            angles[(missingAngle + 2) % 3];
	        numAngles = 3;
	    }

	    // 3 angles and 1 side is enough to figure out the rest of the sides using
	    // the law of sines
	    if (numAngles === 3 && numSides >= 1) {
	        var knownSide = sides.indexOf(sides[0] || sides[1] || sides[2]);
	        sides[(knownSide + 1) % 3] = (sides[knownSide] *
	            Math.sin(angles[(knownSide + 1) % 3] * Math.PI / 180)) /
	            Math.sin(angles[knownSide] * Math.PI / 180);
	        sides[(knownSide + 2) % 3] = (sides[knownSide] *
	            Math.sin(angles[(knownSide + 2) % 3] * Math.PI / 180)) /
	            Math.sin(angles[knownSide] * Math.PI / 180);
	    }

	    triangle.sides = sides;
	    triangle.angles = angles;

	    triangle.isRight = function() {
	        return (this.angles[0] === 90 || this.angles[1] === 90 ||
	            this.angles[2] === 90);
	    };

	    triangle.isScalene = function() {
	        return (this.angles[0] !== this.angles[1] &&
	            this.angles[1] !== this.angles[2] &&
	            this.angles[0] !== this.angles[2]);
	    };

	    triangle.isNotDegenerate = function() {
	        return (this.sides[1] + this.sides[2] > this.sides[0] &&
	            this.sides[0] + this.sides[2] > this.sides[1] &&
	            this.sides[0] + this.sides[1] > this.sides[2]);
	    };

	    return triangle;
	};


	KhanUtil.Graphie.prototype.addTriangle = function(triangle) {
	    var graphie = this;
	    triangle = $.extend({
	        sides: [],
	        angles: [],
	        points: [],
	        sideLabels: [],
	        angleLabels: [],
	        vertexLabels: [],
	        labels: [],
	        rot: 0,
	        xPos: 0,
	        yPos: 0,
	        width: 10,
	        height: 10,
	        color: KhanUtil.BLUE
	    }, triangle);

	    var rotatePoint = function(point, angle) {
	        var matrix = kmatrix.makeMatrix([
	            [Math.cos(angle), -Math.sin(angle), 0],
	            [Math.sin(angle), Math.cos(angle), 0],
	            [0, 0, 1]
	        ]);
	        var vector = kmatrix.makeMatrix([[point[0]], [point[1]], [1]]);
	        var prod = kmatrix.matrixMult(matrix, vector);
	        return [prod[0][0], prod[1][0]];
	    };

	    var findCenterPoints = function(triangle, points) {
	        var Ax = points[0][0];
	        var Ay = points[0][1];
	        var Bx = points[1][0];
	        var By = points[1][1];
	        var Cx = points[2][0];
	        var Cy = points[2][1];
	        var D = 2 * (Ax * (By - Cy) + Bx * (Cy - Ay) + Cx * (Ay - By));
	        var a = triangle.sides[0];
	        var b = triangle.sides[1];
	        var c = triangle.sides[2];
	        var P = a + b + c;
	        var x1 = (a * Ax + b * Bx + c * Cx) / P;
	        var y1 = (a * Ay + b * By + c * Cy) / P;
	        var x = ((Ay * Ay + Ax * Ax) * (By - Cy) + (By * By + Bx * Bx) *
	            (Cy - Ay) + (Cy * Cy + Cx * Cx) * (Ay - By)) / D;
	        var y = ((Ay * Ay + Ax * Ax) * (Cx - Bx) + (By * By + Bx * Bx) *
	            (Ax - Cx) + (Cy * Cy + Cx * Cx) * (Bx - Ax)) / D;
	        return {
	            circumCenter: [x, y],
	            centroid: [1 / 3 * (Ax + Bx + Cx), 1 / 3 * (Ay + By + Cy)],
	            inCenter: [x1, y1]
	        };
	    };

	    triangle.draw = function() {
	        if (triangle.set != null) {
	            triangle.set.remove();
	        }
	        _.each(triangle.labels, function(lbl) {
	            lbl.remove();
	        });
	        triangle.set = graphie.raphael.set();
	        triangle.set.push(graphie.path(triangle.points.concat([true]),{
	            stroke: triangle.color
	        }));

	        var centerPoints = findCenterPoints(triangle, triangle.points);
	        _(3).times(function(i) {
	            if (triangle.angleLabels[i] != null) {
	                var ang = Math.atan2(centerPoints.inCenter[1] -
	                    triangle.points[i][1], centerPoints.inCenter[0] -
	                    triangle.points[i][0]);

	                // The angle measure label needs to be further from the vertex
	                // for small angles and closer for large angles. This is an
	                // empirically determined formula for figuring out how far.
	                var labelDist = (3.51470560176242 - 0.5687298702748785) *
	                    Math.exp(-0.037587715462826674 * triangle.angles[i]) +
	                    0.5687298702748785;

	                triangle.labels.push(graphie.label([
	                    triangle.points[i][0] + Math.cos(ang) * labelDist,
	                    triangle.points[i][1] + Math.sin(ang) * labelDist],
	                    triangle.angleLabels[i], "center"));
	            }
	        });

	        _(3).times(function(i) {
	            if (triangle.sideLabels[i] != null) {
	                var x = (triangle.points[(i + 1) % 3][0] +
	                    triangle.points[(i + 2) % 3][0]) / 2;
	                var y = (triangle.points[(i + 1) % 3][1] +
	                    triangle.points[(i + 2) % 3][1]) / 2;
	                var ang;
	                if (triangle.angles[i] < 90) {
	                    ang = Math.atan2(y - centerPoints.circumCenter[1],
	                        x - centerPoints.circumCenter[0]);
	                } else if (triangle.angles[i] > 90) {
	                    ang = Math.atan2(centerPoints.circumCenter[1] - y,
	                        centerPoints.circumCenter[0] - x);
	                } else {
	                    ang = Math.atan2(y - centerPoints.centroid[1],
	                        x - centerPoints.centroid[0]);
	                }

	                triangle.labels.push(graphie.label([x, y],
	                    triangle.sideLabels[i], ang));
	            }
	        });

	        _(3).times(function(i) {
	            if (triangle.vertexLabels[i] != null) {
	                var ang = Math.atan2(triangle.points[i][1] -
	                    centerPoints.inCenter[1], triangle.points[i][0] -
	                    centerPoints.inCenter[0]);
	                var labelDist = 0.4;

	                var lbl = graphie.label([
	                    triangle.points[i][0] + Math.cos(ang) * labelDist,
	                    triangle.points[i][1] + Math.sin(ang) * labelDist],
	                    triangle.vertexLabels[i], "center");
	                lbl.css("color", triangle.color);
	                triangle.labels.push(lbl);
	            }
	        });
	    };

	    // Return the points coorresponding to an alitude to angle[n]
	    triangle.findAltitude = function(n) {
	        var p1 = triangle.points[n];
	        var p2 = triangle.points[(n + 1) % 3];
	        var p3 = triangle.points[(n + 2) % 3];

	        // Project p1 onto line between p2 and p3
	        // Could use kvector's projection method
	        var v1 = [p1[0] - p2[0], p1[1] - p2[1]];
	        var v2 = [p3[0] - p2[0], p3[1] - p2[1]];
	        var dot1 = v1[0] * v2[0] + v1[1] * v2[1];
	        var dot2 = v2[0] * v2[0] + v2[1] * v2[1];
	        var s = dot1 / dot2;
	        return [p1, [p2[0] + v2[0] * s, p2[1] + v2[1] * s]];
	    };

	    triangle.points[2] = [0, 0];
	    triangle.points[1] = [triangle.sides[0], 0];
	    triangle.points[0] = [Math.cos(triangle.angles[2] * Math.PI / 180) *
	        triangle.sides[1], Math.sin(triangle.angles[2] * Math.PI / 180) *
	        triangle.sides[1]];

	    // Rotate the triangle
	    triangle.points[0] = rotatePoint(triangle.points[0], triangle.rot *
	        Math.PI / 180);
	    triangle.points[1] = rotatePoint(triangle.points[1], triangle.rot *
	        Math.PI / 180);
	    triangle.points[2] = rotatePoint(triangle.points[2], triangle.rot *
	        Math.PI / 180);

	    // Scale and translate the triangle such that it fits within the
	    // specified width/height constraint and is positioned at xPos, yPos
	    var minX = _.min(_.map(triangle.points, function(p) { return p[0]; }));
	    var maxX = _.max(_.map(triangle.points, function(p) { return p[0]; }));
	    var minY = _.min(_.map(triangle.points, function(p) { return p[1]; }));
	    var maxY = _.max(_.map(triangle.points, function(p) { return p[1]; }));
	    var xScale = triangle.width / (maxX - minX);
	    var yScale = triangle.height / (maxY - minY);
	    var scale = _.min([xScale, yScale]);
	    triangle.width = (maxX - minX) * scale;
	    triangle.height = (maxY - minY) * scale;

	    triangle.points = _.map(triangle.points, function(p) {
	        return [(p[0] - minX) * scale + triangle.xPos,
	            (p[1] - minY) * scale + triangle.yPos];
	    });

	    return triangle;
	};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var decimalPointSymbol = icu.getDecimalFormatSymbols().decimal_separator;

	function Adder(a, b, decimalA, decimalB) {
	    var graph = KhanUtil.currentGraph;
	    decimalA = decimalA || 0;
	    decimalB = decimalB || 0;
	    var decimalPos = Math.max(decimalA, decimalB);

	    // Remove trailing zeros from decimals
	    if (decimalPos) {
	        while (a % 10 === 0 && a !== 0) {
	            a /= 10;
	            decimalA--;
	        }

	        while (b % 10 === 0 && b !== 0) {
	            b /= 10;
	            decimalB--;
	        }

	        // Add trailing zeros so decimals line up
	        a *= (decimalB > decimalA ? Math.pow(10, decimalB - decimalA) : 1);
	        b *= (decimalA > decimalB ? Math.pow(10, decimalA - decimalB) : 1);
	    }

	    var digitsA = KhanUtil.digits(a);
	    var digitsB = KhanUtil.digits(b);
	    var digitDiff = digitsA.length - digitsB.length;

	    // Add leading zeros to decimals
	    if (decimalPos) {
	        for (var i = 0; i < -digitDiff || digitsA.length < decimalA + 1; i++) {
	            digitsA.push(0);
	        }

	        for (var i = 0; i < digitDiff || digitsB.length < decimalB + 1; i++) {
	            digitsB.push(0);
	        }
	    }

	    var pos = { max: Math.max(digitsA.length, digitsB.length, KhanUtil.digits(a + b).length),
	        carry: 3,
	        first: 2,
	        second: 1,
	        sum: 0,
	        sideX: Math.max(digitsA.length, digitsB.length) + 2,
	        sideY: 1.5 };

	    var index = 0;
	    var carry = 0;
	    var highlights = [];
	    var numHints = Adder.numHintsFor(a, b);

	    this.show = function() {
	        graph.init({
	            range: [[-1, 11], [pos.sum - 0.5, pos.carry + 0.5]],
	            scale: [20, 40]
	        });

	        drawDigits(digitsA.slice(0).reverse(), pos.max - digitsA.length + 1, pos.first);
	        drawDigits(digitsB.slice(0).reverse(), pos.max - digitsB.length + 1, pos.second);

	        graph.path([[-0.5, pos.second - 0.5], [pos.max + 0.5, pos.second - 0.5]]);
	        graph.label([0, 1] , "\\LARGE{+\\vphantom{0}}");

	        if (decimalPos !== 0) {
	            for (var i = 0; i < 3; i++) {
	                graph.style({ fill: "#000" }, function() {
	                    graph.label([pos.max - decimalPos + 0.5, i - 0.1],
	                        "\\LARGE{" + decimalPointSymbol + "}", "center", true);
	                });
	            }
	            this.showSideLabel("\\text{Make sure digits are lined up by place value.}");
	            this.showSideLabel("\\text{Use the decimal points to help you.}", -0.6);
	        }
	    };

	    this.showHint = function() {
	        this.removeHighlights();
	        if ((index === numHints - 2) && (numHints - 1 > digitsA.length)) {
	            this.showFinalCarry();
	            index++;
	            return;
	        } else if (index === numHints - 1) {
	            return;
	        }
	        var prevCarry = carry;
	        var prevCarryStr = "";
	        var resultStr = "";
	        var addendStr = "";
	        var sum;

	        var x = pos.max - index;
	        var power = Math.pow(10, index - decimalPos);
	        var decimalPlaces = Math.max(0, decimalPos - index);

	        if (prevCarry !== 0) {
	            highlights.push(graph.label([x, pos.carry], "\\blue{" + prevCarry + "}", "below"));
	            prevCarryStr = "\\blue{" + KhanUtil.localeToFixed(prevCarry * power,  decimalPlaces) + "} + ";
	        }

	        sum = digitsA[index] + carry;
	        highlights = highlights.concat(drawDigits([digitsA[index]], x, pos.first, KhanUtil.BLUE));

	        if (index < digitsB.length) {
	            highlights = highlights.concat(drawDigits([digitsB[index]], x, pos.second, KhanUtil.BLUE));
	            addendStr = " + \\blue{" + KhanUtil.localeToFixed(digitsB[index] * power, decimalPlaces) + "}";
	            sum += digitsB[index];
	        }

	        drawDigits([sum % 10], x, pos.sum);
	        highlights = highlights.concat(drawDigits([sum % 10], x, pos.sum, KhanUtil.GREEN));

	        carry = Math.floor(sum / 10);
	        var doCarry = Math.min(carry, 1);

	        if (decimalPlaces > doCarry) {
	            resultStr += "0.";
	            resultStr += (new Array(decimalPlaces - doCarry).join("0"));
	        }

	        if (carry !== 0) {
	            highlights.push(graph.label([x - 1, pos.carry], "\\orange{" + carry + "}", "below"));
	            resultStr += "\\orange{" + carry + "}";
	            if (decimalPlaces === 1) {
	                resultStr += ".";
	            }
	        }

	        resultStr += "\\green{" + (sum % 10) + "}";
	        if (index + 1 > decimalPos) {
	            resultStr += (new Array(index - decimalPos + 1).join("0"));
	        }

	        this.showSideLabel("\\Large{" +
	            prevCarryStr +
	            "\\blue{" + KhanUtil.localeToFixed(digitsA[index] * power, decimalPlaces) + "}" +
	            addendStr +
	            " = " +
	            resultStr +
	            "}");

	        index++;
	    };

	    this.showFinalCarry = function() {
	        highlights.push(graph.label([pos.max - index, pos.carry],
	            "\\blue{" + carry + "}", "below"));
	        graph.label([pos.max - index, pos.sum], "\\LARGE{" + carry + "}");
	        highlights.push(graph.label([pos.max - index, pos.sum],
	            "\\LARGE{\\green{" + carry + "}}"));

	        this.showSideLabel("\\Large{" +
	            "\\blue{" + carry + "}" +
	            " = " +
	            "\\green{" + carry + "}" +
	            "}");
	    };

	    this.getNumHints = function() {
	        return numHints;
	    };

	    this.removeHighlights = function() {
	        while (highlights.length) {
	            highlights.pop().remove();
	        }
	    };

	    this.showSideLabel = function(str, dy) {
	        var y = pos.sideY + (dy || 0);
	        highlights.push(graph.label([pos.sideX, y], str, "right"));
	    };
	}

	Adder.processDigit = function() {

	};

	Adder.numHintsFor = function(a, b) {
	    return KhanUtil.digits(a + b).length + 1;
	};

	function Subtractor(a, b, digitsA, digitsB, decimalPlaces) {
	    var graph = KhanUtil.currentGraph;
	    digitsA = digitsA || KhanUtil.digits(a);
	    digitsB = digitsB || KhanUtil.digits(b);
	    var workingDigitsA = digitsA.slice(0);
	    var workingDigitsB = digitsB.slice(0);
	    var highlights = [];
	    var pos = { max: digitsA.length,
	        carry: 3,
	        first: 2,
	        second: 1,
	        diff: 0,
	        sideX: Math.max(digitsA.length, digitsB.length) + 2,
	        sideY: 1.5 };

	    var index = 0;
	    var numHints = Subtractor.numHintsFor(a, b);
	    decimalPlaces = decimalPlaces || 0;

	    this.show = function() {
	        graph.init({
	            range: [[-1, 11], [pos.diff - 0.5, pos.carry + 0.5]],
	            scale: [20, 40]
	        });
	        drawDigits(digitsA.slice(0).reverse(), pos.max - digitsA.length + 1, pos.first);
	        drawDigits(digitsB.slice(0).reverse(), pos.max - digitsB.length + 1, pos.second);

	        graph.path([[-0.5, pos.second - 0.5], [pos.max + 0.5, pos.second - 0.5]]);
	        graph.label([0, 1] , "\\LARGE{-\\vphantom{0}}");

	        for (var i = 0; i < digitsA.length; i++) {
	            highlights.unshift([]);
	        }
	    };

	    this.borrow = function(idx) {
	        var borrowedIdx = idx + 1;
	        if (workingDigitsA[idx + 1] < 1) {
	            borrowedIdx = this.borrow(idx + 1);
	        }
	        workingDigitsA[idx + 1] -= 1;
	        workingDigitsA[idx] += 10;

	        var depth = borrowedIdx - idx - 1;

	        highlights[idx].push(graph.label([pos.max - idx, pos.carry + (0.5 * depth)],
	                                             "\\blue{" + workingDigitsA[idx] + "}", "below"));
	        highlights[idx].push(graph.path([[pos.max - 0.3 - idx, pos.first - 0.4], [pos.max + 0.3 - idx, pos.first + 0.4]]));

	        highlights[idx + 1].push(graph.label([pos.max - 1 - idx, pos.carry + (0.5 * depth)],
	                                                 "\\orange{" + workingDigitsA[idx + 1] + "}", "below"));
	        highlights[idx + 1].push(graph.path([[pos.max - 1.3 - idx, pos.first - 0.4], [pos.max - 0.7 - idx, pos.first + 0.4]]));
	        if (depth !== 0) {
	            highlights[idx + 1].push(graph.path([[pos.max - 1.3 - idx, pos.carry - 1 + (0.5 * depth)], [pos.max - 0.7 - idx, pos.carry - 0.7 + (0.5 * depth)]]));
	        }
	        return borrowedIdx;
	    };

	    this.showHint = function() {
	        this.removeHighlights(index);

	        if (index !== 0) {
	            this.removeHighlights(index - 1);
	        }
	        if (index === numHints - 1) {
	            return;
	        }

	        var value = workingDigitsA[index];
	        var withinB = index < workingDigitsB.length;
	        var subtrahend = withinB ? workingDigitsB[index] : 0;
	        var subStr = "";
	        var power = Math.pow(10, index);

	        if (value < subtrahend) {
	            this.borrow(index);
	        } else if (workingDigitsA[index] === digitsA[index]) {
	            highlights[index].push(graph.label([pos.max - index, pos.first],
	                "\\LARGE{\\blue{" + workingDigitsA[index] + "}}"));
	        } else {
	            highlights[index].push(graph.label([pos.max - index, pos.carry],
	                "\\blue{" + workingDigitsA[index] + "}", "below"));
	        }

	        if (withinB) {
	            highlights[index].push(graph.label([pos.max - index, pos.second],
	                "\\LARGE{\\blue{" + workingDigitsB[index] + "}}"));
	            subStr = " - \\blue{" + (subtrahend * power) + "}";
	        }

	        var diff = workingDigitsA[index] - subtrahend;
	        if (((a - b) / Math.pow(10, index)) > 1 || index < decimalPlaces) {
	            graph.label([pos.max - index, pos.diff], "\\LARGE{" + diff + "}");
	        }
	        var zeros = diff ? new Array(index + 1).join("0") :  "";

	        highlights[index].push(graph.label([pos.max - index, pos.diff], "\\LARGE{\\green{" + diff + "}}"));
	        if (subStr === "") {
	            subStr = "- \\blue{ 0 }";
	        }

	        this.showSideLabel("\\Large{" +
	            "\\blue{" + (workingDigitsA[index] * power) + "}" +
	            subStr +
	            " = " +
	            "\\green{" + diff + "}" + 
	            zeros +
	            "}");

	        index++;
	    };

	    this.getNumHints = function() {
	        return numHints;
	    };

	    this.removeHighlights = function(i) {
	        if (i >= highlights.length) {
	            return;
	        }

	        var col = highlights[i];
	        while (col.length) {
	            col.pop().remove();
	        }
	    };

	    this.showSideLabel = function(str) {
	        highlights[index].push(graph.label([pos.sideX, pos.sideY], str, "right"));
	    };

	    this.showDecimals = function(deciA, deciB) {
	        for (var i = 0; i < 3; i++) {
	            graph.style({ fill: "#000" }, function() {
	                graph.label([pos.max - Math.max(deciA, deciB) + 0.5, i - 0.1],
	                    "\\LARGE{" + decimalPointSymbol + "}", "center", true);
	            });
	        }
	        this.showSideLabel("\\text{Make sure the decimals are lined up.}");
	    };
	}

	Subtractor.numHintsFor = function(a, b) {
	    return KhanUtil.digits(a).length + 1;
	};

	// convert Adder -> DecimalAdder and Subtractor -> DecimalSubtractor
	(function() {
	    var decimate = function(drawer) {
	        var news = function(a, aDecimal, b, bDecimal) {
	            var newA = a * (bDecimal > aDecimal ? Math.pow(10, bDecimal - aDecimal) : 1);
	            var newB = b * (aDecimal > bDecimal ? Math.pow(10, aDecimal - bDecimal) : 1);
	            return [newA, newB];
	        };

	        var decimated = function(a, aDecimal, b, bDecimal) {
	            var newAB = news(a, aDecimal, b, bDecimal);
	            var newA = newAB[0], newB = newAB[1];

	            var aDigits = KhanUtil.digits(newA);
	            for (var i = 0; i < (aDecimal - bDecimal) || aDigits.length < aDecimal + 1; i++) {
	                aDigits.push(0);
	            }

	            var bDigits = KhanUtil.digits(newB);
	            for (var i = 0; i < (bDecimal - aDecimal) || bDigits.length < bDecimal + 1; i++) {
	                bDigits.push(0);
	            }
	            var drawn = new drawer(newA, newB, aDigits, bDigits, Math.max(aDecimal, bDecimal));

	            drawn.showDecimals = (function(old) {
	                return function() {
	                    old.call(drawn, aDecimal, bDecimal);
	                };
	            })(drawn.showDecimals);

	            return drawn;
	        };

	        decimated.numHintsFor = function(a, aDecimal, b, bDecimal) {
	            var newAB = news(a, aDecimal, b, bDecimal);
	            var newA = newAB[0], newB = newAB[1];

	            return drawer.numHintsFor(newA, newB);
	        };

	        return decimated;
	    };

	    // I hate global variables
	    KhanUtil.DecimalAdder = decimate(Adder);
	    KhanUtil.DecimalSubtractor = decimate(Subtractor);
	})();

	function drawCircles(num, color) {
	    var graph = KhanUtil.currentGraph;
	    var numCols = Math.floor(Math.sqrt(num));
	    var numRows = Math.floor(num / numCols);
	    var extra = num % numRows;

	    graph.init({
	        range: [[0, numCols + 1], [-1, numRows + 2]],
	        scale: [30, 30]
	    });

	    graph.style({
	        stroke: color,
	        fill: color
	    });

	    for (var i = numRows; i > 0; i--) {
	        for (var j = numCols; j > 0; j--) {
	            graph.circle([j, i], 0.25);
	        }
	    }

	    for (var j = extra; j > 0; j--) {
	        graph.circle([j, 0], 0.25);
	    }
	}

	function crossOutCircles(numCircles, numCrossed, color) {
	    var graph = KhanUtil.currentGraph;
	    var numCols = Math.floor(Math.sqrt(numCircles));
	    var numRows = Math.floor(numCircles / numCols);
	    var extra = numCircles % numRows;
	    var count = 0;

	    graph.style({
	        stroke: color,
	        fill: color
	    });

	    for (var i = numRows; i > 0; i--) {
	        for (var j = numCols; j > 0; j--) {
	            graph.path([[j - 0.3, i - 0.3], [j + 0.3, i + 0.3]]);
	            graph.path([[j - 0.3, i + 0.3], [j + 0.3, i - 0.3]]);
	            count += 1;
	            if (count === numCrossed) {
	                return;
	            }
	        }
	    }

	    for (var j = extra; j > 0; j--) {
	        graph.path([[j - 0.3, i - 0.3], [j + 0.3, i + 0.3]]);
	        graph.path([[j - 0.3, i + 0.3], [j + 0.3, i - 0.3]]);
	        count += 1;
	        if (count === numCrossed) {
	            return;
	        }
	    }
	}

	function drawDigits(digits, startX, startY, color) {
	    var graph = KhanUtil.currentGraph;
	    var set = [];
	    $.each(digits, function(index, digit) {
	        var str = "\\LARGE{" + digit + "}";
	        set.push(graph.label([startX + index, startY], str, { color: color }));
	    });
	    return set;
	}

	// for multiplication 0.5, 1
	function drawRow(num, y, color, startCount) {
	    var graph = KhanUtil.currentGraph;

	    graph.style({
	        stroke: color
	    });

	    var set = graph.raphael.set();
	    for (var x = 0; x < num; x++) {
	        set.push(graph.label([x, y], "\\small{\\color{" + color + "}{" + (startCount + x) + "}}"));
	        set.push(graph.circle([x, y], 0.35));
	    }

	    return set;
	}

	function Multiplier(a, b, digitsA, digitsB, deciA, deciB) {
	    var graph = KhanUtil.currentGraph;
	    deciA = deciA || 0;
	    deciB = deciB || 0;
	    digitsA = digitsA || KhanUtil.digits(a);
	    digitsB = digitsB || KhanUtil.digits(b);

	    var digitsProduct = KhanUtil.integerToDigits(a * b);
	    var highlights = [];
	    var carry = 0;
	    var indexA = 0;
	    var indexB = 0;
	    var maxNumDigits = Math.max(deciA + deciB, digitsProduct.length);

	    var leadingZero = 0;
	    for (var i = digitsB.length - 1; i > 0; i--) {
	        if (digitsB[i] === 0) {
	            leadingZero++;
	        } else {
	            break;
	        }
	    }

	    var numHints = digitsA.length * (digitsB.length - leadingZero) + 1;

	    this.show = function() {
	        var height = Math.max(numHints - 4, 3);
	        if (deciA || deciB) {
	            height += 3;
	        }

	        graph.init({
	            range: [[-2 - maxNumDigits, 18], [-height, 3]],
	            scale: [20, 40]
	        });

	        drawDigits(digitsA.slice(0).reverse(), 1 - digitsA.length, 2);
	        drawDigits(digitsB.slice(0).reverse(), 1 - digitsB.length, 1);

	        graph.path([[-1 - digitsProduct.length, 0.5], [1, 0.5]]);
	        graph.label([- (Math.max(digitsA.length, digitsB.length)), 1] , "\\LARGE{\\times\\vphantom{0}}");
	    };

	    this.removeHighlights = function() {
	        while (highlights.length) {
	            highlights.pop().remove();
	        }
	    };

	    this.getTrueValue = function(n, power) {
	        n *= Math.pow(10, power);
	        if (n !== 0) {
	            return KhanUtil.localeToFixed(n, Math.max(0, -power));
	        } else {
	            return n;
	        }
	    }

	    this.showHint = function() {
	        this.removeHighlights();

	        if (indexB === digitsB.length - leadingZero) {
	            this.showFinalAddition();
	            return;
	        }

	        var bigDigit = digitsA[indexA];
	        var smallDigit = digitsB[indexB];

	        var product = smallDigit * bigDigit + carry;
	        var ones = product % 10;
	        var currCarry = Math.floor(product / 10);

	        // Highlight the digits we're using
	        highlights = highlights.concat(drawDigits([bigDigit], -indexA, 2, KhanUtil.BLUE));
	        highlights = highlights.concat(drawDigits([smallDigit], -indexB, 1, KhanUtil.PINK));
	        if (carry) {
	            highlights = highlights.concat(graph.label([-indexA, 3], "\\purple{" + carry + "}", "below"));
	        }

	        var hint = "\\blue{" + this.getTrueValue(bigDigit, indexA - deciA) + "}";
	        hint += "\\times \\pink{" + this.getTrueValue(smallDigit, indexB - deciB) + "}";
	        hint += (carry ? "+\\purple{" + this.getTrueValue(carry, indexA + indexB - deciA - deciB) + "}" : "");
	        hint += "= \\green{" + this.getTrueValue(product, indexA + indexB - deciA - deciB) + "}";

	        graph.label([2, 2 - indexB * digitsA.length - indexA], hint, "right");

	        var result = [ones];
	        if (indexA === 0) {
	            for (var i = 0; i < indexB; i++) {
	                result.push(0);
	            }
	        }

	        drawDigits(result, -indexB - indexA, -indexB);
	        highlights = highlights.concat(drawDigits([ones], -indexB - indexA, -indexB, KhanUtil.GREEN));

	        if (currCarry) {
	            highlights = highlights.concat(graph.label([-1 - indexA, 3], "\\green{" + currCarry + "}", "below"));
	            if (indexA === digitsA.length - 1) {
	                drawDigits([currCarry], -indexB - indexA - 1, -indexB);
	                highlights = highlights.concat(drawDigits([currCarry], -indexB - indexA - 1, -indexB, KhanUtil.GREEN));
	            }
	        }
	        carry = currCarry;

	        if (indexA === digitsA.length - 1) {
	            indexB++;
	            indexA = 0;
	            carry = 0;
	        } else {
	            indexA++;
	        }
	    };

	    this.showFinalAddition = function() {
	        if (digitsB.length - leadingZero > 1) {
	            while (digitsProduct.length < deciA + deciB + 1) {
	                digitsProduct.unshift(0);
	            }
	            var y = leadingZero - digitsB.length;

	            graph.path([[-1 - digitsProduct.length, y + 0.5], [1, y + 0.5]]);
	            graph.label([-1 - digitsProduct.length, y + 1] , "\\LARGE{+\\vphantom{0}}");
	            drawDigits(digitsProduct, 1 - digitsProduct.length, y);
	        }
	    };

	    this.getNumHints = function() {
	        return numHints;
	    };

	    this.showDecimals = function() {
	        graph.style({
	            fill: "#000"
	        }, function() {
	            if (deciA > 0) {
	                graph.label([-deciA + 0.5, 1.9],
	                    "\\LARGE{" + decimalPointSymbol + "}", "center", true);
	            }
	            if (deciB > 0) {
	                graph.label([-deciB + 0.5, 0.9],
	                    "\\LARGE{" + decimalPointSymbol + "}", "center", true);
	            }
	        });
	    };

	    this.showDecimalsInProduct = function() {
	        var x = -maxNumDigits;
	        var y = -Math.max((digitsB.length - leadingZero) * digitsA.length, 3 + digitsB.length - leadingZero);

	        graph.label([x, y + 2],
	            $.ngettext("\\text{The top number has 1 digit to the right of the decimal.}", "\\text{The top number has %(num)s digits to the right of the decimal.}", deciA), "right");
	        graph.label([x, y + 1],
	            $.ngettext("\\text{The bottom number has 1 digit to the right of the decimal.}", "\\text{The bottom number has %(num)s digits to the right of the decimal.}", deciB), "right");
	        // TODO(jeresig): i18n: Should this be pluralized?
	        graph.label([x, y],
	                    $._("\\text{The product has %(numA)s + %(numB)s = %(numSum)s digits to the right of the decimal.}",
	                        {numA: deciA, numB: deciB, numSum: deciA + deciB}),
	                    "right");
	        graph.style({
	            fill: "#000"
	        }, function() {
	            var y = -digitsB.length + leadingZero;
	            if (y === -1) {
	                // y gets mistakenly calculated -1 only in the case where there's
	                // no addition step. In that case, the decimal really goes at y = 0
	                y = 0;
	            }
	            graph.label([-deciB - deciA + 0.5, y - 0.1],
	                "\\LARGE{" + decimalPointSymbol + "}", "center", true);
	        });
	    };
	}

	function Divider(divisor, dividend, deciDivisor, deciDividend, decimalRemainder) {
	    var graph = KhanUtil.currentGraph;
	    var digitsDivisor = KhanUtil.integerToDigits(divisor);
	    var digitsDividend = KhanUtil.integerToDigits(dividend);
	    deciDivisor = deciDivisor || 0;
	    deciDividend = deciDividend || 0;

	    deciDividend = Divider.processDividend(digitsDividend, deciDividend);
	    var deciDiff = deciDivisor - deciDividend;
	    var hints = Divider.getHints(divisor, digitsDividend, deciDivisor, deciDividend, decimalRemainder);
	    var numHints = hints.length;

	    var highlights = [];
	    var leadingZeros = [];
	    var decimals = [];
	    var temporaryLabel = false;
	    var index = 0;
	    var dx = 0;
	    var dy = 0;
	    var currentValue = 0;
	    var fOnlyZeros = true;

	    this.show = function() {
	        // Count number of subdivisions shown and find how many decimals have been added
	        var steps = 0;
	        var decimalsAdded = 0;
	        for (var i = 0; i < hints.length; i++) {
	            if (hints[i][0] === 'result' && hints[i][1] !== 0) {
	                steps++;
	            } else if (hints[i][0] === 'decimal-remainder') {
	                decimalsAdded = hints[i][1];
	            }
	        }

	        // Calculate the x-coordinate for the hints
	        dx = digitsDividend.length + decimalsAdded + Math.max(0, deciDiff) + 0.5;

	        var paddedDivisor = digitsDivisor;
	        if (deciDivisor !== 0) {
	            paddedDivisor = (KhanUtil.padDigitsToNum(digitsDivisor.reverse(), deciDivisor + 1)).reverse();
	        }

	        graph.init({
	            range: [[-1 - paddedDivisor.length, 17], [-2 * steps - 1, 2]],
	            scale: [20, 40]
	        });

	        graph.style({
	            fill: "#000"
	        }, function() {
	            if (deciDivisor !== 0) {
	                decimals = decimals.concat(
	                    graph.label([-1 - deciDivisor, -0.1],
	                        "\\LARGE{" + decimalPointSymbol + "}", "center", true));
	            }
	            if (deciDividend !== 0) {
	                decimals = decimals.concat(
	                    graph.label(
	                        [digitsDividend.length - deciDividend - 0.5, -0.1],
	                        "\\LARGE{" + decimalPointSymbol + "}", "center", true));
	            }
	        });

	        drawDigits(paddedDivisor, -0.5 - paddedDivisor.length, 0);
	        drawDigits(digitsDividend, 0, 0);
	        graph.path([[-0.75, -0.5], [-0.75, 0.5], [dx - 0.8, 0.5]]);
	    };

	    this.showHint = function() {
	        this.clearArray(highlights);
	        var hint = hints.shift();

	        // For the last hint, remove leading zero in the answer
	        if (hints.length === 0) {
	            this.clearArray(leadingZeros);
	        }

	        switch (hint[0]) {
	            case 'shift':
	                this.shiftDecimals();
	                break;
	            case 'bring-up-decimal':
	                this.bringUpDecimal();
	                break;
	            case 'division':
	                currentValue = hint[1];
	                this.showDivisionStep();
	                break;
	            case 'result':
	                this.showDivisionStepResult(hint[1], hint[2], hint[3]);
	                break;
	            case 'decimal-remainder':
	                this.addDecimalRemainder();
	                break;
	            case 'remainder':
	                this.showRemainder(hint[1]);
	                break;
	        }
	    };

	    this.shiftDecimals = function() {
	        this.clearArray(decimals);

	        temporaryLabel = graph.label([dx, 1],
	            $.ngettext("\\text{Shift the decimal 1 to the right.}",
	                       "\\text{Shift the decimal %(num)s to the right.}",
	                       deciDivisor),
	            "right");

	        this.addDecimals([[-1, -0.1], [digitsDividend.length + deciDiff - 0.5, -0.1]]);

	        // Draw extra zeros in the dividend
	        if (deciDiff > 0) {
	            var orig = digitsDividend;
	            digitsDividend = KhanUtil.padDigitsToNum(digitsDividend, digitsDividend.length + deciDiff);
	            var x = digitsDividend.length - deciDiff;
	            var zeros = digitsDividend.slice(x);
	            drawDigits(zeros, x, 0);
	            highlights = highlights.concat(drawDigits(zeros, x, 0, KhanUtil.PINK));
	        }
	    };

	    this.bringUpDecimal = function() {
	        if (temporaryLabel) {
	            temporaryLabel.remove();
	            temporaryLabel = false;
	        }

	        // TODO(jeresig): i18n: This probably won't work in multiple langs
	        graph.label([dx, 1.2], $._("\\text{Bring the decimal up into the}"), "right");
	        graph.label([dx, 0.8], $._("\\text{answer (the quotient).}"), "right");
	        this.addDecimals([[digitsDividend.length + deciDiff - 0.5, 0.9]]);
	    };

	    this.showDivisionStep = function(division) {
	        // Write question
	        var question = $._("\\text{How many times does }%(divisor)s" +
	                           "\\text{ go into }\\color{#6495ED}{%(value)s}\\text{?}",
	                            {divisor: divisor, value: currentValue});

	        if (currentValue >= divisor) {
	            graph.label([dx, dy], question, "right");
	        } else {
	            highlights = highlights.concat(graph.label([dx, dy], question, "right"));
	        }

	        // Bring down another number
	        if (!fOnlyZeros) {
	            graph.style({
	                arrows: "->"
	            }, function() {
	                highlights.push(graph.path([[index, -0.5], [index, dy + 0.5]]));
	            });

	            if (digitsDividend[index]) {
	                drawDigits([digitsDividend[index]], index, dy);
	            } else {
	                // Add a zero in the dividend and bring that down
	                drawDigits([0], index, 0);
	                drawDigits([0], index, dy);
	            }
	        }

	        // Highlight current dividend
	        var digits = KhanUtil.integerToDigits(currentValue);
	        highlights = highlights.concat(drawDigits(digits, index - digits.length + 1, dy, KhanUtil.BLUE));
	    };

	    this.showDivisionStepResult = function(result, remainder) {
	        if (result !== 0) {
	            fOnlyZeros = false;
	        }

	        // Leading zeros except one before a decimal point and those after
	        // are stored separately so they can be removed later.
	        if (fOnlyZeros && index < digitsDividend.length + deciDiff - 1) {
	            leadingZeros = leadingZeros.concat(drawDigits([0], index, 1));
	        } else { 
	            drawDigits([result], index, 1);
	        }

	        // Highlight result
	        highlights = highlights.concat(drawDigits([result], index, 1, KhanUtil.GREEN));

	        if (result !== 0) {
	            dy -= 2;
	            var productDigits = KhanUtil.integerToDigits(result * divisor);
	            var productLength = productDigits.length;
	            drawDigits(productDigits, index - productLength + 1, dy + 1);

	            graph.path([[index - productLength - 0.25, dy + 0.5], [index + 0.5, dy + 0.5]]);
	            graph.label([index - productLength, dy + 1] , "-");

	            var remainderDigits = KhanUtil.integerToDigits(remainder);
	            var remainderX = index - remainderDigits.length + 1;
	            drawDigits(remainderDigits, remainderX, dy);
	            highlights = highlights.concat(drawDigits(remainderDigits, remainderX, dy, KhanUtil.PINK));

	            graph.label([dx, dy + 1],
	                "\\blue{" + currentValue + "}" +
	                "\\div" + divisor + "=" +
	                "\\green{" + result + "}" +
	                "\\text{" + $._(" with a remainder of ") + " }" +
	                "\\pink{" + remainder + "}",
	                "right");
	        }

	        index++;
	    };

	    this.addDecimalRemainder = function() {
	        digitsDividend = KhanUtil.integerToDigits(dividend * 10);
	        deciDividend = 1;
	        deciDiff = deciDivisor - deciDividend;

	        drawDigits([0], index, 0);
	        this.addDecimals([[index - 0.5, 0.9], [index - 0.5, -0.1]]);

	        graph.label([dx, 1], $._("\\text{Write in a decimal and a zero.}"), "right");
	    };

	    this.showRemainder = function(remainder) {
	        var txt;
	        if (remainder === 0) {
	            txt = "\\text{" + $._("The remainder is 0 so we have our answer.") + "}";
	        } else {
	            txt = $._("\\text{Since } %(remainder)s \\text{ is less than } %(divisor)s \\text{, it is left as our remainder.}",
	                    { remainder: remainder, divisor: divisor });

	            drawDigits(["\\text{R}"].concat(KhanUtil.integerToDigits(remainder)), digitsDividend.length, 1);
	        }

	        graph.label([dx, dy], txt, "right");
	    };

	    this.getNumHints = function() {
	        return numHints;
	    };

	    this.clearArray = function(arr) {
	        while (arr.length) {
	            arr.pop().remove();
	        }
	    };

	    this.addDecimals = function(coords) {
	        graph.style({
	                fill: "#000"
	            }, function() {
	                for (var i = 0; i < coords.length; i++) {
	                    graph.label(coords[i], "\\LARGE{" + decimalPointSymbol + "}", "center", true);
	                }
	            });
	    };

	}

	// Go through the division step-by-step
	// Return steps as an array of arrays,
	// where the first item is the type of hint and following items are parameters.
	// The hint types are:
	// ['shift']                        The divisor is a decimal, so shift the decimal to make it an integer.
	// ['bring-up-decimal']             The dividend is a decimal, so bring up decimal point into the quotient.
	// ['decimal-remainder', param1]    decimalRemainder is true and we need to add decimals to the dividend to continue.
	//                                  Param1 is the number of zeros added (to a maximum of 4).
	//                                  e.g. for 1 / 8, we add a decimal and 3 zeros so 1 becomes 1.000.
	// ['division', param1]             Show a sub-division step, dividing param1 by the divisor.
	//                                  e.g. For 58 / 2, the first step is to divide 5 (param1) by 2.
	// ['result', param1, param2]       Show the result of a sub-division step. The result is param1 remainder param2.
	//                                  e.g. For 5 / 2, param1 is 2 and param2 is 1.
	// ['remainder', param1]            Show the remainder of param1 (Usually 0 showing we have finished).
	// Appended to the end of the hints is the number of decimals added as part of the decimal-remainder step

	Divider.getHints = function(divisor, digitsDividend, deciDivisor, deciDividend, decimalRemainder) {
	    var hints = [];
	    //var digitsDividend = KhanUtil.integerToDigits(dividend);
	    var dividend = 0;

	    if (deciDivisor > 0) {
	        hints.push(['shift']);
	        if (deciDivisor > deciDividend) {
	            digitsDividend = KhanUtil.padDigitsToNum(digitsDividend, digitsDividend.length + deciDivisor - deciDividend);
	        }
	    }

	    if (deciDividend > deciDivisor) {
	        hints.push(['bring-up-decimal']);
	    }

	    // If we want a decimal remainder, add up to 5 extra places
	    var numPlaces = digitsDividend.length + (decimalRemainder ? 5 : 0);
	    var digits = KhanUtil.padDigitsToNum(digitsDividend, numPlaces);
	    var decimalsAdded = 0;
	    var decimalsRemainder = ['decimal-remainder', 0];

	    for (var i = 0; i < digits.length; i++) {
	        if (i >= digitsDividend.length) {
	            if (dividend === 0) {
	                // No need to add more decimals
	                break;
	            } else {
	                decimalsAdded++;
	            }

	            if (i === digitsDividend.length) {
	                hints.push(decimalsRemainder);
	            }
	        }

	        if (decimalsAdded > 0) {
	            decimalsRemainder[1] = decimalsAdded;
	        }

	        dividend = dividend * 10 + digits[i];
	        hints.push(['division', dividend]);

	        var quotient = Math.floor(dividend / divisor);
	        var product = divisor * quotient;
	        dividend -= product;
	        hints.push(['result', quotient, dividend]);
	    }

	    if (dividend === 0 || decimalsAdded !== 5) {
	        hints.push(['remainder', dividend]);
	    }

	    return hints;
	};

	Divider.getNumberOfHints = function(divisor, dividend, deciDivisor, deciDividend, decimalRemainder) {
	    var digitsDividend = KhanUtil.integerToDigits(dividend);
	    deciDividend = Divider.processDividend(digitsDividend, deciDividend);
	    var hints = Divider.getHints(divisor, digitsDividend, deciDivisor, deciDividend, decimalRemainder);
	    return hints.length;
	};

	Divider.processDividend = function(dividendDigits, deciDividend) {
	    // Trim unnecessary zeros after the decimal point
	    var end = dividendDigits.length - 1;
	    for (var i = 0; i < deciDividend; i++) {
	        if (dividendDigits[end - i] === 0) {
	            dividendDigits.splice(end - i);
	            deciDividend--;
	        } else {
	            break;
	        }
	    }

	    // Add zeros before the decimal point
	    var extraZeros = deciDividend - dividendDigits.length + 1;
	    for (var i = 0; i < extraZeros; i++) {
	        dividendDigits.splice(0, 0, 0);
	    }

	    return deciDividend;
	};

	KhanUtil.Adder = Adder;
	KhanUtil.Subtractor = Subtractor;
	KhanUtil.Multiplier = Multiplier;
	KhanUtil.Divider = Divider;
	KhanUtil.drawCircles = drawCircles;
	KhanUtil.drawDigits = drawDigits;
	KhanUtil.drawRow = drawRow;
	KhanUtil.crossOutCircles = crossOutCircles;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(39);

	// Temporary not really following convention file, see #160

	window.numberLine = function(start, end, step, x, y, denominator) {
	    step = step || 1;
	    x = x || 0;
	    y = y || 0;
	    var decPlaces = (step + "").length - (step + "").indexOf(".") - 1;
	    if ((step + "").indexOf(".") < 0) {
	        decPlaces = 0;
	    }
	    var graph = KhanUtil.currentGraph;
	    var set = graph.raphael.set();
	    set.push(graph.line([x, y], [x + end - start, y]));
	    set.labels = [];
	    for (var i = 0; i <= end - start; i += step) {
	        set.push(graph.line([x + i, y - 0.2], [x + i, y + 0.2]));

	        if (denominator) {
	            var base = KhanUtil.roundTowardsZero(start + i + 0.001);
	            var frac = start + i - base;
	            var lab = base;

	            if (! (Math.abs(Math.round(frac * denominator)) === denominator || Math.round(frac * denominator) === 0)) {
	                if (base === 0) {
	                    lab = KhanUtil.fraction(Math.round(frac * denominator), denominator, false, false, true);
	                }
	                else {
	                    lab = base + "\\frac{" + Math.abs(Math.round(frac * denominator)) + "}{" + denominator + "}";
	                }
	            }
	            var label = graph.label([x + i, y - 0.2], "\\small{" + lab + "}",
	                "below", { labelDistance: 3 });
	            set.labels.push(label);
	            set.push(label);
	        }
	        else {
	            var label = graph.label([x + i, y - 0.2],
	                "\\small{" + KhanUtil.localeToFixed(start + i, decPlaces) + "}",
	                "below", { labelDistance: 3 });
	            set.labels.push(label);
	            set.push(label);
	        }
	    }
	    return set;
	};

	window.piechart = function(divisions, colors, radius, strokeColor, x, y) {
	    var graph = KhanUtil.currentGraph;
	    var set = graph.raphael.set();
	    var arcColor = strokeColor || "none";
	    var lineColor = strokeColor || "#fff";
	    x = x || 0;
	    y = y || 0;

	    var sum = 0;
	    $.each(divisions, function(i, slice) {
	        sum += slice;
	    });

	    var partial = 0;
	    $.each(divisions, function(i, slice) {
	        if (slice === sum) {
	            set.push(graph.ellipse([x, y], [radius, radius], {
	                stroke: arcColor,
	                fill: colors[i]
	            }));
	        } else {
	            set.push(graph.arc([x, y], radius, partial * 360 / sum, (partial + slice) * 360 / sum, true, {
	                stroke: arcColor,
	                fill: colors[i]
	            }));
	        }
	        partial += slice;
	    });

	    for (var i = 0; i < sum; i++) {
	        var p = graph.polar(radius, i * 360 / sum);
	        set.push(graph.line([x, y], [x + p[0], y + p[1]], { stroke: lineColor }));
	    }

	    return set;
	};

	// Shade a rectangular area with diagonal stripes. We need to use clipRect so
	// that the ends of the diagonal lines are beveled at each end such that they
	// conform to the overall area of the rectangle being shaded. So this actually
	// draws the diagonal stripes over the entire graphie area and uses clipRect to
	// only show them where desired.
	//
	// The pad argument is an optional number of pixels of padding. Positive
	// numbers make the shaded area smaller.
	window.shadeRect = function(x, y, width, height, pad) {
	    var graph = KhanUtil.currentGraph;
	    var set = graph.raphael.set();
	    var x2 = graph.range[0][0];
	    var y1 = graph.range[1][0];
	    var y2 = graph.range[1][1];
	    var x1 = x2 - (y2 - y1) * graph.scale[1] / graph.scale[0];
	    var step = 8 / graph.scale[0];
	    var xpad = (pad || 0) / graph.scale[0];
	    var ypad = (pad || 0) / graph.scale[1];

	    while (x1 < graph.range[0][1]) {
	        set.push(graph.line([x1, y1], [x2, y2], {
	            clipRect: [[x + xpad, y + ypad],
	                      [width - 2 * xpad, height - 2 * ypad]]
	        }));
	        x1 += step;
	        x2 += step;
	    }
	    return set;
	};

	window.rectchart = function(divisions, fills, y, strokes, shading) {
	    var graph = KhanUtil.currentGraph;
	    var set = graph.raphael.set();

	    y = y || 0;

	    var sum = 0;
	    $.each(divisions, function(i, slice) {
	        sum += slice;
	    });

	    var unit = graph.unscaleVector([1, 1]);
	    var partial = 0;
	    $.each(divisions, function(i, slice) {
	        var fill = fills[i];
	        // If no stroke is provided, match the fill color so the rectangle
	        // appears to be the same size
	        var stroke = strokes && strokes[i] || fill;

	        for (var j = 0; j < slice; j++) {
	            var x = partial / sum, w = 1 / sum;
	            set.push(graph.path(
	                [
	                    [x + 2 * unit[0], y + 2 * unit[1]],
	                    [x + w - 2 * unit[0], y + 2 * unit[1]],
	                    [x + w - 2 * unit[0], y + 1 - 2 * unit[1]],
	                    [x + 2 * unit[0], y + 1 - 2 * unit[1]],
	                    true
	                ],
	                {
	                    stroke: stroke,
	                    fill: fill
	                }
	            ));
	            if (shading && shading[i]) {
	                graph.style({
	                    stroke: "#000",
	                    strokeWidth: 2,
	                    strokeOpacity: 0.5,
	                    fillOpacity: 0,
	                    fill: null
	                }, function() {
	                    // We add or subtract a pixel of padding depending on
	                    // whether there's a stroke. If there is, we only shade
	                    // inside, otherwise we shade over the whole area. That's
	                    // why the last argument to shadeRect is 1 or -1 (the width
	                    // of the stroke is assumed to be 2)
	                    set.push(shadeRect(
	                        x + 2 * unit[0], y + 2 * unit[1],
	                        w - 4 * unit[0], 1 - 4 * unit[1],
	                        (strokes && strokes[i]) ? 1 : -1));
	                });
	            }
	            partial += 1;
	        }
	    });

	    return set;
	};

	window.Parabola = function(lc, x, y) {
	    var leadingCoefficient = lc;
	    var x1 = x;
	    var y1 = y;
	    var raphaelObjects = [];

	    this.graphieFunction = function(x) {
	        return (leadingCoefficient * (x - x1) * (x - x1)) + y1;
	    };

	    this.plot = function(fShowFocusDirectrix) {
	        var graph = KhanUtil.currentGraph;
	        raphaelObjects.push(graph.plot(this.graphieFunction, [-10, 10]));
	        if (fShowFocusDirectrix) {
	            var focusX = this.getFocusX();
	            var focusY = this.getFocusY();
	            var directrixK = this.getDirectrixK();

	            graph.style({
	                fill: "#6495ED"
	            }, function() {
	                raphaelObjects.push(graph.circle([focusX, focusY], 0.1));
	                raphaelObjects.push(graph.line([-10, directrixK], [10, directrixK]));
	            });
	        }
	    };

	    this.redraw = function(fShowFocusDirectrix) {
	        $.each(raphaelObjects, function(i, el) {
	            el.remove();
	        });
	        raphaelObjects = [];
	        this.plot(fShowFocusDirectrix);
	    };

	    this.update = function(newLC, newX, newY) {
	        leadingCoefficient = newLC;
	        x1 = newX;
	        y1 = newY;
	    };

	    this.delta = function(deltaLC, deltaX, deltaY) {
	        this.update(leadingCoefficient + deltaLC, x1 + deltaX, y1 + deltaY);
	    };

	    this.deltaFocusDirectrix = function(deltaX, deltaY, deltaK) {
	        var focusY = this.getFocusY() + deltaY;
	        var k = this.getDirectrixK() + deltaK;

	        if (focusY === k) {
	            focusY += deltaY;
	            k += deltaK;
	        }
	        var newVertexY = (focusY + k) / 2;
	        var newLeadingCoefficient = 1 / (2 * (focusY - k));

	        this.update(newLeadingCoefficient, this.getVertexX() + deltaX, newVertexY);
	    };

	    this.getVertexX = function() {
	        return x1;
	    };

	    this.getVertexY = function() {
	        return y1;
	    };

	    this.getLeadingCoefficient = function() {
	        return leadingCoefficient;
	    };

	    this.getFocusX = function() {
	        return x1;
	    };

	    this.getFocusY = function() {
	        return y1 + (1 / (4 * leadingCoefficient));
	    };

	    this.getDirectrixK = function() {
	        return y1 - (1 / (4 * leadingCoefficient));
	    };
	};

	window.redrawParabola = function(fShowFocusDirectrix) {
	    var graph = KhanUtil.currentGraph;
	    var storage = graph.graph;
	    var currParabola = storage.currParabola;
	    currParabola.redraw(fShowFocusDirectrix);

	    var leadingCoefficient = currParabola.getLeadingCoefficient();
	    var vertexX = currParabola.getVertexX();
	    var vertexY = currParabola.getVertexY();

	    if (fShowFocusDirectrix) {
	        $("#focus-x-label").html("<code>" + currParabola.getFocusX() + "</code>").runModules();
	        $("#focus-y-label").html("<code>" + KhanUtil.localeToFixed(currParabola.getFocusY(), 2) + "</code>").runModules();
	        $("#directrix-label").html("<code>" + "y = " + KhanUtil.localeToFixed(currParabola.getDirectrixK(), 2) + "</code>").runModules();
	    } else {
	        var equation = "y - " + vertexY + "=" + leadingCoefficient + "(x - " + vertexX + ")^{2}";
	        equation = KhanUtil.cleanMath(equation);
	        $("#equation-label").html("<code>" + equation + "</code>").runModules();
	    }
	    $("#leading-coefficient input").val(leadingCoefficient);
	    $("#vertex-x input").val(vertexX);
	    $("#vertex-y input").val(vertexY);
	};

	window.updateParabola = function(deltaA, deltaX, deltaY, fShowFocusDirectrix) {
	    KhanUtil.currentGraph.graph.currParabola.delta(deltaA, deltaX, deltaY);
	    redrawParabola(fShowFocusDirectrix);
	};

	window.updateFocusDirectrix = function(deltaX, deltaY, deltaK) {
	    KhanUtil.currentGraph.graph.currParabola.deltaFocusDirectrix(deltaX, deltaY, deltaK);
	    redrawParabola(true);
	};

	window.ParallelLineMarkers = function(x, y, rotation) {
	    var graph = KhanUtil.currentGraph;
	    rotation = rotation || 0;

	    var s = 8 / graph.scaleVector([1, 1])[0];
	    var x2 = x + 0.75 * s * Math.cos(rotation);
	    var y2 = y + 0.75 * s * Math.sin(rotation);
	    var dx1 = s * Math.cos(rotation + Math.PI / 4);
	    var dy1 = s * Math.sin(rotation + Math.PI / 4);
	    var dx2 = s * Math.cos(rotation - Math.PI / 4);
	    var dy2 = s * Math.sin(rotation - Math.PI / 4);

	    graph.path([[x - dx1, y - dy1], [x, y], [x - dx2, y - dy2]]);
	    graph.path([[x2 - dx1, y2 - dy1], [x2, y2], [x2 - dx2, y2 - dy2]]);
	};

	// A pair of parallel lines with a line traversing them.
	// Lines are centered on x, y, with a given length and a given distance apart.
	window.ParallelLines = function(x, y, length, distance, rotation) {
	    var lowerIntersection;
	    var upperIntersection;
	    var anchorAngle;

	    var dx1 = distance / 2 * Math.cos(rotation + Math.PI / 2);
	    var dy1 = distance / 2 * Math.sin(rotation + Math.PI / 2);
	    var dx2 = length / 2 * Math.cos(rotation);
	    var dy2 = length / 2 * Math.sin(rotation);
	    var labels = {};

	    this.draw = function() {
	        var graph = KhanUtil.currentGraph;
	        graph.line([x + dx1 + dx2, y + dy1 + dy2], [x + dx1 - dx2, y + dy1 - dy2]);
	        graph.line([x - dx1 + dx2, y - dy1 + dy2], [x - dx1 - dx2, y - dy1 - dy2]);
	    };

	    this.drawMarkers = function(position) {
	        var graph = KhanUtil.currentGraph;
	        var pmarkX = 0;
	        var pmarkY = 0;
	        var s = 120 / graph.scaleVector([1, 1])[0];

	        if (position === "right" || (position >= 40 && position <= 140)) {
	            pmarkX += s * Math.cos(rotation);
	            pmarkY += s * Math.sin(rotation);
	        } else if (position === "left") {
	            pmarkX -= s * Math.cos(rotation);
	            pmarkY -= s * Math.sin(rotation);
	        }
	        ParallelLineMarkers(x + dx1 + pmarkX, y + dy1 + pmarkY, rotation);
	        ParallelLineMarkers(x - dx1 + pmarkX, y - dy1 + pmarkY, rotation);
	    };

	    this.drawTransverse = function(angleDeg) {
	        var graph = KhanUtil.currentGraph;
	        var angleRad = KhanUtil.toRadians(angleDeg);

	        var cosAngle = Math.cos(rotation + angleRad);
	        var sinAngle = Math.sin(rotation + angleRad);
	        var dx3 = 0.5 * length * cosAngle;
	        var dy3 = 0.5 * length * sinAngle; 
	        graph.line([x + dx3, y + dy3], [x - dx3, y - dy3]);

	        // Find intersections
	        var hypot = 0.5 * distance / Math.cos(Math.PI / 2 - angleRad);
	        var dx4 = hypot * cosAngle;
	        var dy4 = hypot * sinAngle;

	        upperIntersection = [x + dx4, y + dy4];
	        lowerIntersection = [x - dx4, y - dy4];
	        anchorAngle = angleDeg;
	    };

	    function labelAngle(index, coords, angles, color, text) {
	        var graph = KhanUtil.currentGraph;
	        var measure = (angles[1] - angles[0]);
	        var bisect = KhanUtil.toRadians(angles[0] + measure / 2);
	        var radius = 0.7;

	        if (measure < 70) { // control for angle label getting squeezed between intersecting lines
	            radius /= Math.cos(KhanUtil.toRadians(70 - measure));
	        }

	        var dx = radius * Math.cos(bisect);
	        var dy = radius * Math.sin(bisect);
	        var placement = "center";

	        if (typeof text === "boolean") {
	            text = (angles[1] - angles[0]) + "^\\circ";
	        }

	        // Slightly hacky way to align the equations in vertical_angles_2
	        if (text.length > 10 && Math.abs(dx) > 0.25) {
	            dx *= 0.6;
	            dy *= 0.8;
	            placement = dx > 0 ? "right" : "left";
	        }

	        // Remove old label
	        if (labels[index]) {
	            labels[index].remove();
	        }

	        labels[index] = graph.label([coords[0] + dx, coords[1] + dy], text, placement, { color: color });
	    }

	    this.drawAngle = function(index, label, color) {
	        var graph = KhanUtil.currentGraph;
	        var radius = 0.4;

	        color = color || KhanUtil.BLUE;
	        index = (index + 8) % 8;
	        var args = index < 4 ? [lowerIntersection, radius] : [upperIntersection, radius];

	        var angles = [KhanUtil.toDegrees(rotation), KhanUtil.toDegrees(rotation)];
	        switch (index % 4) {
	            case 0: // Quadrant 1
	                angles[1] += anchorAngle;
	                break;
	            case 1: // Quadrant 2
	                angles[0] += anchorAngle;
	                angles[1] += 180;
	                break;
	            case 2: // Quadrant 3
	                angles[0] += 180;
	                angles[1] += 180 + anchorAngle;
	                break;
	            case 3: // Quadrant 4
	                angles[0] += 180 + anchorAngle;
	                angles[1] += 360;
	                break;
	        }
	        $.merge(args, angles);

	        graph.style({ stroke: color}, function() {
	            if (!labels[index]) {
	                graph.arc.apply(graph, args);
	            }

	            if (label) {
	                labelAngle(index, args[0], angles, color, label);
	            }
	        });
	    };

	    this.drawVerticalAngle = function(index, label, color) {
	        index = (index + 8) % 8;
	        var vert = (index + 2) % 4;
	        if (index >= 4) {
	            vert += 4;
	        }
	        this.drawAngle(vert, label, color);
	    };

	    this.drawAdjacentAngles = function(index, label, color) {
	        index = (index + 8) % 8;
	        var adj1 = (index + 1) % 4;
	        var adj2 = (index + 3) % 4;
	        if (index >= 4) {
	            adj1 += 4;
	            adj2 += 4;
	        }
	        this.drawAngle(adj1, label, color);
	        this.drawAngle(adj2, label, color);
	    };
	};

	window.drawComplexChart = function(radius, denominator) {
	    var graph = KhanUtil.currentGraph;
	    var safeRadius = radius * Math.sqrt(2);
	    var color = "#ddd";

	    // Draw lines of complex numbers with same angle and
	    // circles of complex numbers with same radius to help the intuition.

	    graph.style({
	        strokeWidth: 1.0
	    });

	    for (var i = 1; i <= safeRadius; i++) {
	        graph.circle([0, 0], i, {
	            fill: "none",
	            stroke: color
	        });
	    }

	    for (var i = 0; i < denominator; i++) {
	        var angle = i * 2 * Math.PI / denominator;
	        if (denominator % 4 === 0 && i % (denominator / 4) !== 0) { // Don't draw over axes.
	            graph.line([0, 0], [Math.sin(angle) * safeRadius, Math.cos(angle) * safeRadius], {
	                stroke: color
	            });
	        }
	    }

	    graph.label([radius, 0.5], "Re", "left");
	    graph.label([0.5, radius - 1], "Im", "right");
	};

	window.ComplexPolarForm = function(angleDenominator, maxRadius, euler) {
	    var denominator = angleDenominator;
	    var maximumRadius = maxRadius;
	    var angle = 0, radius = 1;
	    var circle;
	    var useEulerForm = euler;

	    this.update = function(newAngle, newRadius) {
	        angle = newAngle;
	        while (angle < 0) {
	            angle += denominator;
	        }
	        angle %= denominator;

	        radius = Math.max(1, Math.min(newRadius, maximumRadius)); // keep between 0 and maximumRadius...

	        this.redraw();
	    };

	    this.delta = function(deltaAngle, deltaRadius) {
	        this.update(angle + deltaAngle, radius + deltaRadius);
	    };

	    this.getAngleNumerator = function() {
	        return angle;
	    };

	    this.getAngleDenominator = function() {
	        return denominator;
	    };

	    this.getAngle = function() {
	        return angle * 2 * Math.PI / denominator;
	    };

	    this.getRadius = function() {
	        return radius;
	    };

	    this.getRealPart = function() {
	        return Math.cos(this.getAngle()) * radius;
	    };

	    this.getImaginaryPart = function() {
	        return Math.sin(this.getAngle()) * radius;
	    };

	    this.getUseEulerForm = function() {
	        return useEulerForm;
	    };

	    this.plot = function() {
	        circle = KhanUtil.currentGraph.circle([this.getRealPart(), this.getImaginaryPart()], 1 / 4, {
	            fill: KhanUtil.ORANGE,
	            stroke: "none"
	        });
	    };

	    this.redraw = function() {
	        if (circle) {
	            circle.remove();
	        }
	        this.plot();
	    };
	};

	window.updateComplexPolarForm = function(deltaAngle, deltaRadius) {
	    KhanUtil.currentGraph.graph.currComplexPolar.delta(deltaAngle, deltaRadius);
	    redrawComplexPolarForm();
	};

	window.redrawComplexPolarForm = function(angle, radius) {
	    var graph = KhanUtil.currentGraph;
	    var storage = graph.graph;
	    var point = storage.currComplexPolar;
	    point.redraw();

	    if (typeof radius === "undefined") {
	        radius = point.getRadius();
	    }
	    if (typeof angle === "undefined") {
	        angle = point.getAngleNumerator();
	    }

	    angle *= 2 * Math.PI / point.getAngleDenominator();

	    var equation = KhanUtil.polarForm(radius, angle, point.getUseEulerForm());

	    $("#number-label").html("<code>" + equation + "</code>").runModules();
	    $("#current-radius").html("<code>" + radius + "</code>").runModules();
	    $("#current-angle").html("<code>" + KhanUtil.piFraction(angle, true) + "</code>").runModules();
	};

	window.labelDirection = function(angle) {
	    angle = angle % 360;
	    if (angle === 0) {
	        return "right";
	    } else if (angle > 0 && angle < 90) {
	        return "above right";
	    } else if (angle === 90) {
	        return "above";
	    } else if (angle > 90 && angle < 180) {
	        return "above left";
	    } else if (angle === 180) {
	        return "left";
	    } else if (angle > 180 && angle < 270) {
	        return "below left";
	    } else if (angle === 270) {
	        return "below";
	    } else if (angle > 270 && angle < 360) {
	        return "below right";
	    }
	};

	// arc orientation is "top"|"left"|"bottom"|"right".
	// arrow direction is clockwise (true) or counter-clockwise (false)
	window.curvyArrow = function(center, radius, arcOrientation, arrowDirection, styles) {
	    styles = styles || {};
	    var graph = KhanUtil.currentGraph;
	    var set = graph.raphael.set();
	    var angles;
	    if (arcOrientation === "left") {
	        angles = [90, 270];
	    } else if (arcOrientation === "right") {
	        angles = [270, 90];
	    } else if (arcOrientation === "top") {
	        angles = [0, 180];
	    } else if (arcOrientation === "bottom") {
	        angles = [180, 0];
	    }
	    angles.push(styles);
	    var arcArgs = [center, radius].concat(angles);
	    set.push(graph.arc.apply(graph, arcArgs));

	    var offset = graph.unscaleVector([1, 1]);

	    // draw Arrows
	    var from = _.clone(center);
	    var to = _.clone(center);
	    if (arcOrientation === "left" || arcOrientation === "right") {
	        var left = arcOrientation === "left";
	        from[1] = to[1] = to[1] + radius * (arrowDirection === left ? 1 : -1);
	        to[0] = from[0] + offset[0] * (left ? 1 : -1);
	    } else {
	        var bottom = arcOrientation === "bottom";
	        from[0] = to[0] = to[0] + radius * (arrowDirection === bottom ? 1 : -1);
	        to[1] = from[1] + offset[1] * (bottom ? 1 : -1);
	    }
	    set.push(graph.line(from, to, _.extend({arrows: "->"}, styles)));
	    return set;
	};

	window.curlyBrace = function(startPointGraph, endPointGraph) {
	    var graph = KhanUtil.currentGraph;

	    var startPoint = graph.scalePoint(startPointGraph);
	    var endPoint = graph.scalePoint(endPointGraph);
	    var angle = KhanUtil.findAngle(endPoint, startPoint);
	    var length = KhanUtil.getDistance(endPoint, startPoint);
	    var midPoint = _.map(startPoint, function(start, i) {
	        return (start + endPoint[i]) / 2;
	    });

	    var specialLen = 16 * 2 + 13 * 2;
	    if (length < specialLen) {
	        throw new Error("Curly brace length is too short.");
	    }
	    var straight = (length - specialLen) / 2;
	    var half = length / 2;

	    var firstHook = "c 1 -3 6 -5 10 -6" +
	                    "c 0 0 3 -1 6 -1";

	    // Mirror of first hook.
	    var secondHook = "c 3 1 6 1 6 1" +
	                     "c 4 1 9 3 10 6";

	    var straightPart = "l " + straight + " 0";

	    var firstMiddle =
	            "c 5 0 10 -3 10 -3" +
	            "l 3 -4";

	    // Mirror of second middle
	    var secondMiddle =
	            "l 3 4" +
	            "c 0 0 5 3 10 3";

	    var path = [
	        "M -" + half + " 0",
	        firstHook,
	        straightPart,
	        firstMiddle,
	        secondMiddle,
	        straightPart,
	        secondHook
	    ].join("");

	    var brace = graph.raphael.path(path);
	    brace.rotate(angle);
	    brace.translate(midPoint[0], midPoint[1]);
	    return brace;
	};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {
	    Polygon: function(numSides) {
	        // This should be renamed...
	        // these are the angles between diagonals
	        // to construct the polygon.
	        var angles = [],
	            points = [],
	            gExteriorAngles = [];

	        function getMaxDiagonalLength(p1, p2, p3) {
	            var intersection = findIntersection([p1, p2], [[0, 0], p3]),
	                x = intersection[0],
	                y = intersection[1];
	            return Math.sqrt(x * x + y * y);
	        }

	        function getDistance(p1, p2) {
	            var dx = p2[0] - p1[0],
	                dy = p2[1] - p1[1];
	            return Math.sqrt(dx * dx + dy * dy);
	        }

	        // Creates a convex n-gon by choosing n-2 angles,
	        // where each of the n vertices will fall somewhere
	        // on these diagonals, or rays from the origin.
	        // ( see http://gyazo.com/625bd5662ac07707c86fd83d9d8531a1 )
	        // Choose the first two diagonal-lengths willy-nilly,
	        // but each subsequent vertex must be closer to the origin
	        // than the intersection of the corresponding diagonal
	        // and the line created by the previous two vertices.
	        // Hippopotamus.
	        (function() {
	            var graph = KhanUtil.currentGraph,
	                curr,
	                length,
	                min = 1,
	                max = 5,
	                incr = 1;

	            for (var i = 0; i < numSides - 2; i++) {
	                var evenlyDivided = 180 / numSides,
	                    jitter = KhanUtil.randRange(-10, 10) / 40;
	                angles.push(evenlyDivided * (1 + jitter));
	            }

	            while (points.length !== angles.length + 2) {
	                curr = 0;
	                points = [[0, 0], graph.polar(KhanUtil.randRange(min, max), curr)];
	                $.each(angles, function(index, angle) {
	                    curr += angle;
	                    if (index === 0) {
	                        length = KhanUtil.randRange(min, max);
	                    } else {
	                        var maxLength = getMaxDiagonalLength(points[points.length - 2], points[points.length - 1], graph.polar(min, curr));
	                        if (Math.floor(maxLength) <= min + incr) {
	                            return;
	                        }
	                        maxLength = Math.min(Math.floor(maxLength) - incr, max);
	                        length = KhanUtil.randRange(min, maxLength);
	                    }
	                    points.push(graph.polar(length, curr));
	                });
	            }
	        })();

	        this.draw = function() {
	            var graph = KhanUtil.currentGraph;
	            graph.style({stroke: KhanUtil.BLUE });
	            points.push([0, 0]);
	            graph.path(points);
	            points.pop();
	        };

	        function drawDiagonalTriangle(start) {
	            var graph = KhanUtil.currentGraph,
	                length = points.length;
	            graph.style({stroke: KhanUtil.ORANGE, "stroke-width": 3});
	            graph.line(points[start % length], points[(start + 1) % length]);
	            graph.line(points[(start + 1) % length], points[(start + 2) % length]);
	            graph.line(points[(start + 2) % length], points[start % length]);
	        }

	        function drawEndTriangles(start) {
	            drawDiagonalTriangle(start);
	            drawDiagonalTriangle(start + points.length - 2);
	        }

	        this.drawDiagonals = function(start) {
	            var graph = KhanUtil.currentGraph,
	                p1 = points[start % points.length];
	            $.each(points, function(i, p2) {
	                if (start !== i) {
	                    graph.line(p1, p2);
	                }
	            });
	            drawEndTriangles(start);
	        };

	        this.drawRadialDiagonals = function() {
	            var graph = KhanUtil.currentGraph,
	                cx = 0,
	                cy = 0;

	            $.each(points, function(index, point) {
	                cx += point[0];
	                cy += point[1];
	            });
	            cx /= points.length;
	            cy /= points.length;
	            graph.style({stroke: KhanUtil.ORANGE}, function() {
	                $.each(points, function(index, point) {
	                    graph.line([cx, cy], point);
	                });
	            });
	            graph.circle([cx, cy], 0.3);
	        };

	        this.drawExteriorAngles = function() {
	            var graph = KhanUtil.currentGraph,
	                prevTheta = 0,
	                prevPoint;
	            graph.style({ "stroke-dasharray": "-"});
	            points.push([0, 0]);
	            $.each(points, function(index, point) {
	                if (index !== 0) {
	                    var distance = getDistance(prevPoint, point),
	                        dx = point[0] - prevPoint[0],
	                        dy = point[1] - prevPoint[1],
	                        theta = Math.acos(dx / distance) * 180 / Math.PI,
	                        coord;
	                    if (dy < 0) {
	                        theta = 360 - theta;
	                    }
	                    coord = graph.polar(distance + 2, theta);
	                    coord[0] += prevPoint[0];
	                    coord[1] += prevPoint[1];
	                    graph.line(prevPoint, coord);
	                    if (index !== 1) {
	                        graph.style({"stroke-dasharray": ""}, function() {
	                            gExteriorAngles.push(graph.arc(prevPoint, 0.5, prevTheta, theta));
	                        });
	                    }
	                    prevTheta = theta;
	                }
	                prevPoint = point;
	            });
	            graph.style({"stroke-dasharray": ""}, function() {
	                gExteriorAngles.push(graph.arc(prevPoint, 0.5, prevTheta, 360));
	            });
	            points.pop();
	        };

	        function getColor(i) {
	            switch (i % 4) {
	                case 0: return KhanUtil.BLUE;
	                case 1: return KhanUtil.ORANGE;
	                case 2: return KhanUtil.GREEN;
	                case 3: return KhanUtil.PINK;
	            }
	        }

	        this.animateExteriorAngles = function(start) {
	            var graph = KhanUtil.currentGraph,
	                origin = graph.scalePoint(points[start]);
	            points.push([0, 0]);
	            gExteriorAngles.unshift("dummy");
	            for (var i = 1; i < gExteriorAngles.length; i++) {
	                var gAngle = gExteriorAngles[i],
	                    point = points[i],
	                    coord = graph.scalePoint(point),
	                    clone = gAngle.attr("stroke", getColor(i)).clone();
	                clone.animate({ translation: [origin[0] - coord[0], origin[1] - coord[1]] }, 1000);
	            }
	            points.pop();
	            gExteriorAngles.shift();
	        };

	        this.clone = function() {
	            return $.extend(true, {}, this);
	        };

	        this.ex = function() {
	            return gExteriorAngles;
	        };
	    },

	    Circle: function(radius, center) {
	        center = center || [0, 0];
	        var pointRadius = 0.1;

	        (function() {
	            var graph = KhanUtil.currentGraph;
	            graph.style({stroke: KhanUtil.BLUE});
	            graph.circle(center, radius);
	        })();

	        this.drawPoint = function(theta) {
	            var graph = KhanUtil.currentGraph,
	                point = graph.polar(radius, theta);
	            return graph.circle(point, pointRadius);
	        };

	        this.drawCenter = function() {
	            var graph = KhanUtil.currentGraph;
	            graph.style({ fill: KhanUtil.BLUE }, function() {
	                graph.circle(center, pointRadius);
	            });
	        };

	        this.drawRadius = function(theta) {
	            var graph = KhanUtil.currentGraph,
	                point = graph.polar(radius, theta);
	            return graph.line(center, point);
	        };

	        this.drawChord = function(theta1, theta2) {
	            var graph = KhanUtil.currentGraph,
	                point1 = graph.polar(radius, theta1),
	                point2 = graph.polar(radius, theta2);
	            return graph.line(point1, point2);
	        };

	        function isThetaWithin(theta, min, max) {
	            min = min % 360;
	            max = max % 360;
	            if (min > max) {
	                return theta < max || theta > min;
	            } else {
	                return theta > min && theta < max;
	            }
	        }

	        function getThetaFromXY(x, y) {
	            var angle = Math.atan2(y, x);
	            if (angle < 0) {
	                angle += 2 * Math.PI;
	            }
	            angle = angle * 180 / Math.PI;
	            return angle;
	        }

	        this.drawMovablePoint = function(theta, min, max) {
	            var graph = KhanUtil.currentGraph,
	                point = graph.polar(radius, theta);
	            min = min || 0;
	            max = max || 360;
	            graph.graph.movable = { vertex: KhanUtil.bogusShape, arc: KhanUtil.bogusShape, chords: [KhanUtil.bogusShape, KhanUtil.bogusShape] };

	            graph.graph.inscribedPoint = graph.addMovablePoint({coordX: point[0], coordY: point[1] });

	            graph.graph.inscribedPoint.onMove = function(x, y) {
	                var theta = getThetaFromXY(x, y);
	                if (!isThetaWithin(theta, min, max)) {
	                    return false;
	                }
	                graph.style({stroke: KhanUtil.ORANGE});
	                graph.graph.movable.arc.remove();
	                graph.graph.movable.chords[0].remove();
	                graph.graph.movable.chords[1].remove();
	                graph.graph.movable.vertex.remove();
	                graph.graph.movable = graph.graph.circle.drawInscribedAngle(theta, max, min);
	                return graph.polar(radius, theta);
	            };
	        };

	        this.drawCentralArc = function(start, end, arcRadius) {
	            var graph = KhanUtil.currentGraph,
	                arc;
	            arcRadius = arcRadius || 0.5;
	            graph.style({fill: ""}, function() {
	                arc = graph.arc(center, arcRadius, start, end);
	            });
	            return arc;
	        };

	        this.drawCentralAngle = function(start, end, arcRadius) {
	            var result = { radii: [] };
	            result.radii.push(this.drawRadius(start));
	            result.radii.push(this.drawRadius(end));
	            result.arc = this.drawCentralArc(start, end, arcRadius);
	            return result;
	        };

	        this.drawInscribedArc = function(inscribed, start, end, arcRadius) {
	            var graph = KhanUtil.currentGraph,
	                vertex = graph.polar(radius, inscribed),
	                point1 = graph.polar(radius, start),
	                point2 = graph.polar(radius, end),
	                theta1 = getThetaFromXY(point1[0] - vertex[0], point1[1] - vertex[1]),
	                theta2 = getThetaFromXY(point2[0] - vertex[0], point2[1] - vertex[1]),
	                arc;
	            arcRadius = arcRadius || 0.5;
	            graph.style({ fill: "" }, function() {
	                arc = graph.arc(vertex, arcRadius, theta1, theta2);
	            });
	            return arc;
	        };

	        this.drawInscribedAngle = function(inscribed, start, end, arcRadius) {
	            var chords = [this.drawChord(inscribed, start), this.drawChord(inscribed, end)],
	                vertex = this.drawPoint(inscribed),
	                arc = this.drawInscribedArc(inscribed, start, end, arcRadius);
	            return { chords: chords, vertex: vertex, arc: arc };
	        };
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	(function($) {
	    $.fn.adhere = function(options) {
	        options = $.extend({
	            container: null,
	            topMargin: 0,
	            bottomMargin: 0
	        }, options);

	        var container = $(options.container).eq(0);

	        $(this).each(function() {
	            var el = $(this);
	            var data = el.data("adhesion");
	            var updateDimensions = (data != null);

	            if (data == null) {
	                data = {};
	                el.data("adhesion", data);
	            }

	            var shim = data.shim != null ? data.shim : $("<div>");

	            shim.css({
	                margin: 0,
	                padding: 0,
	                border: 0
	            });

	            if (updateDimensions) {
	                if (data.scrollHandler != null) {
	                    data.scrollHandler();
	                }

	                return;
	            }

	            el.before(shim);
	            el.parent().css("position", "relative");
	            var state = "unstuck";
	            var height;

	            var stick = function(update) {
	                if (state === "stuck" && update !== true) {
	                    return;
	                }

	                shim.height(height);
	                el.parent().height("auto");

	                el.css({
	                    position: "fixed",
	                    top: options.topMargin,
	                    bottom: "auto",
	                    left: el.parent().offset().left,
	                    width: shim.width()
	                });

	                state = "stuck";
	            };

	            var unstick = function() {
	                if (state === "unstuck") {
	                    return;
	                }

	                shim.height(0);
	                el.parent().height("auto");

	                el.css({
	                    position: "static",
	                    width: "auto"
	                });

	                state = "unstuck";
	            };

	            var bottom = function() {
	                if (state === "bottom") {
	                    return;
	                }

	                shim.height(0);
	                el.parent().height(container.height());

	                el.css({
	                    position: "absolute",
	                    top: "auto",
	                    bottom: 0,
	                    left: "auto",
	                    width: shim.width()

	                });

	                state = "bottom";
	            };

	            var scrollHandler = function(update) {
	                var scrollTop = $(window).scrollTop();
	                var windowHeight = $(window).height();
	                var containerOffset = container.offset();
	                var containerHeight = container.outerHeight();
	                height = el.outerHeight(true);

	                var containerScrolledTop = containerOffset.top - scrollTop;
	                var containerScrolledBottom = containerScrolledTop + containerHeight;

	                var elFixedBottom = height + options.topMargin + options.bottomMargin;
	                var shimRight = shim.offset().left + shim.outerWidth();

	                if (elFixedBottom < windowHeight && containerScrolledTop - options.topMargin < 0 && shimRight <= $(window).width()) {
	                    if (elFixedBottom < containerScrolledBottom) {
	                        stick(update);
	                    } else {
	                        bottom();
	                    }
	                } else {
	                    unstick();
	                }
	            };

	            var resizeHandler = function() {
	                scrollHandler(true);
	            };

	            data.scrollHandler = scrollHandler;

	            $(window).scroll(scrollHandler);
	            $(window).resize(resizeHandler);
	        });
	    };
	})(jQuery);


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.fn.khanscript = function(problem) {
	    return this.find("script[type='text/khanscript']").each(function() {
	        var code = $(this).text();
	        code = "(function() {" + code + "})()";
	        $.tmpl.getVAR(code);
	    }).end();
	};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(27);

	var kmatrix = KhanUtil.kmatrix = {
	    // To add two 2-dimensional matrices, use
	    //     deepZipWith(2, function(a, b) { return a + b; }, matrixA, matrixB);
	    deepZipWith: function(depth, fn) {
	        var arrays = [].slice.call(arguments, 2);

	        // if any of the "array" arguments to deepZipWith are null, return null
	        var hasNullValue = _.any(arrays, function(array) {
	            if (array === null) {
	                return true;
	            }
	        });
	        if (hasNullValue) {
	            return null;
	        }

	        if (depth === 0) {
	            return fn.apply(null, arrays);
	        } else {
	            return _.map(_.zip.apply(_, arrays), function(els) {
	                return kmatrix.deepZipWith.apply(this, [depth - 1, fn].concat(els));
	            });
	        }
	    },

	    matrixCopy: function(mat) {
	        return $.extend(true, [], mat);
	    },

	    /**
	     * Apply the given function to each element of the given matrix and return
	     * the resulting matrix.
	     */
	    matrixMap: function(fn, mat) {
	        return _.map(mat, function(row, i) {
	            return _.map(row, function(elem, j) {
	                return fn(elem, i, j);
	            });
	        });
	    },

	    /**
	     * Given a matrix and list of row-col indices to exclude from masking,
	     * return a new matrix with all but the elements in excludeList overwritten
	     * by the value "?".
	     *
	     * @param mat {result of makeMatrix}
	     * @param excludeList {array of arrays} List of row-col indices to keep
	     *          from being overwritten. Note that these indices start at 1, not
	     *          0, to match with common math notation.
	     */
	    maskMatrix: function(mat, excludeList) {
	        var result = [];

	        _.times(mat.r, function(i) {
	            var row = [];
	            _.times(mat.c, function(j) {
	                if (KhanUtil.contains(excludeList, [i+1, j+1])) {
	                    row.push(mat[i][j]);
	                } else {
	                    row.push("?");
	                }
	            });
	            result.push(row);
	        });
	        return result;
	    },

	    /**
	     * Given one or more same-dimension 2d matrices and a function for
	     * how to combine and format their elements in the output matrix,
	     * return the LaTeX code for rendering the matrix. Inherits syntax from
	     * deepZipWith().
	     *
	     * Example usage:
	     *
	     * printMatrix(function(a, b) {
	     *  return colorMarkup(a, "#FF0000") + "-" + colorMarkup(b, "#00FF00");
	     * }, matA, matB);
	     *
	     */
	    printMatrix: function(fn) {
	        var args = Array.prototype.slice.call(arguments);
	        var mat = kmatrix.deepZipWith.apply(this, [2].concat(args));

	        if (!mat) {
	            return null;
	        }

	        var table = _.map(mat, function(row, i) {
	                        return row.join(" & ");
	                    }).join(" \\\\ ");

	        var prefix = "\\left[\\begin{array}";
	        var suffix = "\\end{array}\\right]";

	        // to generate the alignment info needed for LaTeX table markup
	        var alignment = "{";
	        var cols = mat[0].length;
	        _(cols).times(function (){
	            alignment += "r";
	        });
	        alignment += "}";

	        return prefix + alignment + table + suffix;
	    },

	    /**
	     * Given a matrix and a color, format all elements with the given color
	     * (if supplied) and return the LaTeX code for rendering the matrix.
	     *
	     * @param mat {array of arrays} the matrix to format
	     * @param color {string}
	     */
	    printSimpleMatrix: function(mat, color) {
	        return kmatrix.printMatrix(function(item) {
	            if (color) {
	                return KhanUtil.colorMarkup(item, color);
	            }
	            return item;
	        }, mat);
	    },

	    printFractionMatrix: function(mat, color) {
	        return kmatrix.printMatrix(function(item) {
	            item = KhanUtil.decimalFraction(item, true);
	            if (color) {
	                return KhanUtil.colorMarkup(item, color);
	            }
	            return item;
	        }, mat);
	    },

	    /**
	     * Prints matrix as determinant, like |matrix| rather than [matrix]
	     */
	    printSimpleMatrixDet: function(mat, color) {
	        return kmatrix.printSimpleMatrix(mat,color)
	                .replace("left[","left|")
	                .replace("right]","right|");
	    },

	    /**
	     * Format the rows or columns of the given matrix with the colors in the
	     * given colors array, and return the LaTeX code for rendering the matrix.
	     *
	     * @param mat {array of arrays} the matrix to format
	     * @param colors {array of strings} list of colors
	     * @param isRow {bool} whether to apply the colors by row or by column
	     */
	    printColoredDimMatrix: function(mat, colors, isRow) {
	        var matrix = kmatrix.matrixMap(function(item, i, j) {
	            var color = colors[isRow ? i : j];
	            return KhanUtil.colorMarkup(item, color);
	        }, mat);
	        return kmatrix.printSimpleMatrix(matrix);
	    },

	    /**
	     * Generate markup for a color-coded matrix illustrating the calculations
	     * behind each element in matrix multiplication.
	     *
	     * @param a {result of makeMatrix} the first matrix
	     * @param b {result of makeMatrix} the second matrix
	     * @param rowColors {array of strings} list of colors to apply to the
	     *                                     rows of the first matrix
	     * @param colColors {array of strings} list of colors to apply to the
	     *                                     columns of the second matrix
	     */
	    makeMultHintMatrix: function(a, b, rowColors, colColors) {
	        var c = [];
	        // create the new matrix
	        _.times(a.r, function() {
	            c.push([]);
	        });

	        // perform the multiply
	        _.times(a.r, function(i) {
	            var c1 = rowColors[i];
	            _.times(b.c, function(j) {
	                var c2 = colColors[j];
	                var temp = "";
	                _.times(a.c, function(k) {
	                    if (k > 0) {
	                        temp += "+";
	                    }
	                    var elem1 = KhanUtil.colorMarkup(a[i][k], c1);
	                    var elem2 = KhanUtil.colorMarkup(b[k][j], c2);
	                    temp += elem1 + "\\cdot" + elem2;
	                });
	                c[i][j] = temp;
	            });
	        });

	        return kmatrix.makeMatrix(c);
	    },

	    // add matrix properties to a 2d matrix
	    //   currently only rows and columns
	    makeMatrix: function(mat) {
	        mat.r = mat.length;
	        mat.c = mat[0].length;

	        return mat;
	    },

	    // remove specified row and column from the matrix
	    cropMatrix: function(mat, rowIndex, colIndex) {
	        var cropped = kmatrix.matrixCopy(mat);
	        cropped.splice(rowIndex, 1);
	        _.each(cropped, function(row) {
	            row.splice(colIndex, 1);
	        });
	        return cropped;
	    },

	    matrix2x2DetHint: function(mat) {
	        // if terms in the matrix are letters, omit the dot
	        var operator = (typeof mat[0][0] === "string") ? " \\times " : " \\cdot ";
	        var termA = "(" + mat[0][0] + operator + mat[1][1] + ")";
	        var termB = "(" + mat[0][1] + operator + mat[1][0] + ")";
	        return termA + "-" + termB;
	    },

	    matrix3x3DetHint: function(mat, isIntermediate) {
	        var tex = "";

	        // iterate over columns
	        _.times(mat.c, function(j) {
	            var hintMat = kmatrix.cropMatrix(mat, 0, j);

	            var sign = j % 2 ? "-" : "+";
	            sign = j === 0 ? "" : sign;

	            var multiplier = mat[0][j];

	            var term;
	            if (isIntermediate) {
	                term = kmatrix.printSimpleMatrixDet(hintMat);
	            } else {
	                term = kmatrix.matrix2x2DetHint(hintMat);
	                term = KhanUtil.exprParenthesize(term);
	            }

	            tex += sign + multiplier + term;
	        });

	        return tex;
	    },

	    // multiply two matrices
	    matrixMult: function(a, b) {
	        a = kmatrix.makeMatrix(a);
	        b = kmatrix.makeMatrix(b);

	        var c = [];
	        // create the new matrix
	        _.times(a.r, function() {
	            c.push([]);
	        });

	        // perform the multiply
	        _.times(a.r, function(i) {
	            _.times(b.c, function(j) {
	                var temp = 0;
	                _.times(a.c, function(k) {
	                    temp += a[i][k] * b[k][j];
	                });
	                c[i][j] = temp;
	            });
	        });

	        // add matrix properties to the result
	        return kmatrix.makeMatrix(c);
	    },

	    /**
	     * Makes a matrix of minors
	     *
	     * @param m {result of makeMatrix} the matrix
	     */
	    matrixMinors: function(mat) {
	        mat = kmatrix.makeMatrix(mat);
	        if (!mat.r || !mat.c) {
	            return null;
	        }
	        var rr = kmatrix.matrixMap(function(input, row, elem) {
	            return kmatrix.cropMatrix(mat, row, elem);
	        }, mat);
	        return rr;
	    },

	    /**
	     * Find the transpose of a matrix.
	     *
	     * @param m {result of makeMatrix} the matrix
	     */
	     matrixTranspose: function(mat) {
	        mat = kmatrix.makeMatrix(mat);

	        var r = mat.c;
	        var c = mat.r;

	        if (!r || !c) {
	            return null;
	        }

	        var matT = [];

	        _.times(r, function(i) {
	            var row = [];
	            _.times(c, function(j) {
	                row.push(mat[j][i]);
	            });
	            matT.push(row);
	        });

	        return kmatrix.makeMatrix(matT);
	     },

	    /**
	     * Find the determinant of a matrix.
	     *
	     * Note: Only works for 2x2 and 3x3 matrices.
	     *
	     * @param m {result of makeMatrix} the matrix
	     */
	    matrixDet: function(mat) {
	        mat = kmatrix.makeMatrix(mat);

	        // determinant is only defined for a square matrix
	        if (mat.r !== mat.c) {
	            return null;
	        }

	        var a, b, c, d, e, f, g, h, k, det;

	        // 2x2 case
	        // [[a, b], [c, d]]
	        if (mat.r === 2) {

	            a = mat[0][0];
	            b = mat[0][1];
	            c = mat[1][0];
	            d = mat[1][1];

	            det = a*d - b*c;

	        // 3x3 case
	        // [[a, b, c], [d, e, f], [g, h, k]]
	        } else if (mat.r === 3) {

	            a = mat[0][0];
	            b = mat[0][1];
	            c = mat[0][2];
	            d = mat[1][0];
	            e = mat[1][1];
	            f = mat[1][2];
	            g = mat[2][0];
	            h = mat[2][1];
	            k = mat[2][2];

	            det = a*(e*k - f*h) - b*(k*d - f*g) + c*(d*h - e*g);
	        }

	        return det;
	    },

	    /**
	     * Find the adjugate of a matrix.
	     *
	     * Note: Only works for 2x2 and 3x3 matrices.
	     *
	     * @param m {result of makeMatrix} the matrix
	     */
	    matrixAdj: function(mat) {
	        mat = kmatrix.makeMatrix(mat);

	        var a, b, c, d, e, f, g, h, k;
	        var adj;

	        // 2x2 case
	        // [[a, b], [c, d]]
	        if (mat.r === 2) {

	            a = mat[0][0];
	            b = mat[0][1];
	            c = mat[1][0];
	            d = mat[1][1];

	            adj = [[d, -b], [-c, a]];

	        // 3x3 case
	        // [[a, b, c], [d, e, f], [g, h, k]]
	        } else if (mat.r === 3) {

	            a = mat[0][0];
	            b = mat[0][1];
	            c = mat[0][2];
	            d = mat[1][0];
	            e = mat[1][1];
	            f = mat[1][2];
	            g = mat[2][0];
	            h = mat[2][1];
	            k = mat[2][2];

	            var A =  (e*k - f*h);
	            var B = -(d*k - f*g);
	            var C =  (d*h - e*g);
	            var D = -(b*k - c*h);
	            var E =  (a*k - c*g);
	            var F = -(a*h - b*g);
	            var G =  (b*f - c*e);
	            var H = -(a*f - c*d);
	            var K =  (a*e - b*d);

	            adj = [[A, D, G], [B, E, H], [C, F, K]];
	        }

	        if (adj) {
	            adj = kmatrix.makeMatrix(adj);
	        }

	        return adj;
	    },

	    /**
	     * Find the inverse of a matrix.
	     *
	     * Note: Only works for 2x2 and 3x3 matrices.
	     *
	     * @param m {result of makeMatrix} the matrix
	     * @param precision {int} number of decimal places to round to (optional)
	     */
	    matrixInverse: function(mat, precision) {
	        var det = kmatrix.matrixDet(mat);

	        // if determinant is undefined or 0, inverse does not exist
	        if (!det) {
	            return null;
	        }

	        var adj = kmatrix.matrixAdj(mat);

	        if (!adj) {
	            return null;
	        }

	        var inv = kmatrix.deepZipWith(2, function(val) {
	            val = val / det;
	            if (precision) {
	                val = KhanUtil.roundTo(precision, val);
	            }
	            return val;
	        }, adj);

	        inv = kmatrix.makeMatrix(inv);

	        return inv;
	    },

	    /**
	     * Pad (or crop) the given matrix with the given padding value (`padval`)
	     * until it is of dimensions `rows` x `cols`
	     * @param  {result of makeMatrix} m
	     * @param  {int} rows
	     * @param  {int} cols
	     * @param  {anything} padVal [defaults to "" if not specified]
	     * @return {result of makeMatrix}
	     */
	    matrixPad: function(mat, rows, cols, padVal) {
	        if (!mat) {
	            return null;
	        }

	        mat = kmatrix.makeMatrix(mat);
	        var matP = kmatrix.matrixCopy(mat);

	        var finalCols = Math.max(cols, mat.c);

	        if (padVal === undefined) {
	            padVal = "";
	        }

	        // first add padding to the columns
	        var dcols = cols - matP.c;
	        if (dcols > 0) {
	            _.times(matP.r, function(i) {
	                _.times(dcols, function() {
	                    matP[i].push(padVal);
	                });
	            });
	        }

	        // make new rows and fill with padding
	        var drows = rows - matP.r;
	        if (drows > 0) {
	            _.times(drows, function() {
	                var row = [];
	                _.times(finalCols, function() {
	                    row.push(padVal);
	                });
	                matP.push(row);
	            });
	        }

	        return kmatrix.makeMatrix(matP);
	    },

	    // convert an array to a column matrix
	    arrayToColumn: function(arr) {
	        var col = [];

	        _.each(arr, function(e) {
	            col.push([e]);
	        });

	        return kmatrix.makeMatrix(col);
	    },

	    // convert a column matrix to an array
	    columnToArray: function(col) {
	        var arr = [];

	        _.each(col, function(e) {
	            arr.push(e[0]);
	        });

	        return arr;
	    }
	};

	// TODO(jack): This is a hack to keep these functions
	// showing up as "globals" in khan-exercises
	_.each(kmatrix, function(func, name) {
	    KhanUtil[name] = func;
	});

	return kmatrix;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(10);
	__webpack_require__(27);

	$.extend(KhanUtil, {
	    /* Wraps a number in paretheses if it's negative. */
	    negParens: function(n) {
	        return n < 0 ? "(" + n + ")" : n;
	    },

	    /* Wrapper for `fraction` which takes a decimal instead of a numerator and
	     * denominator. */
	    decimalFraction: function(num, defraction, reduce, small, parens) {
	        var f = KhanUtil.toFraction(num);
	        return KhanUtil.fraction(f[0], f[1], defraction, reduce, small, parens);
	    },

	    reduce: function(n, d) {
	        var gcd = KhanUtil.getGCD(n, d);
	        n = n / gcd;
	        d = d / gcd;
	        return [n, d];
	    },

	    toFractionTex: function(n, dfrac) {
	        var f = KhanUtil.toFraction(n);
	        if (f[1] === 1) {
	            return f[0];
	        } else {
	            return (n < 0 ? "-" : "") + "\\" + (dfrac ? "d" : "") + "frac{" + Math.abs(f[0]) + "}{" + Math.abs(f[1]) + "}";
	        }
	    },

	    /* Format the latex of the fraction `n`/`d`.
	     * - Will use latex's `dfrac` unless `small` is specified as truthy.
	     * - Will wrap the fraction in parentheses if necessary (ie, unless the
	     * fraction reduces to a positive integer) if `parens` is specified as
	     * truthy.
	     * - Will reduce the fraction `n`/`d` if `reduce` is specified as truthy.
	     * - Will defraction (spit out 0 if `n` is 0, spit out `n` if `d` is 1, or
	     * spit out `undefined` if `d` is 0) if `defraction` is specified as
	     * truthy. */
	    fraction: function(n, d, defraction, reduce, small, parens) {
	        var frac = function(n, d) {
	            return (small ? "\\frac" : "\\dfrac") + "{" + n + "}{" + d + "}";
	        };

	        var neg = n * d < 0;
	        var sign = neg ? "-" : "";
	        n = Math.abs(n);
	        d = Math.abs(d);

	        if (reduce) {
	            var gcd = KhanUtil.getGCD(n, d);
	            n = n / gcd;
	            d = d / gcd;
	        }

	        defraction = defraction && (n === 0 || d === 0 || d === 1);
	        parens = parens && (!defraction || neg);
	        var begin = parens ? "\\left(" : "";
	        var end = parens ? "\\right)" : "";

	        var main;
	        if (defraction) {
	            if (n === 0) {
	                main = "0";
	            } else if (d === 0) {
	                main = "\\text{undefined}";
	            } else if (d === 1) {
	                main = sign + n;
	            }
	        } else {
	            main = sign + frac(n, d);
	        }

	        return begin + main + end;
	    },

	    mixedFractionFromImproper: function(n, d, defraction, reduce, small, parens) {
	        return KhanUtil.mixedFraction(Math.floor(n / d), n % d, d, defraction, reduce, small, parens);
	    },

	    /* Format the latex of the mixed fraction 'num n/d"
	     * - For negative numbers, if it is a mixed fraction, make sure the whole
	     * number portion is negative.  '-5, 2/3' should be 'mixedFraction(-5,2,3)'
	     * do not put negative for both whole number and numerator portion.
	     * - Will use latex's `dfrac` unless `small` is specified as truthy.
	     * - Will wrap the fraction in parentheses if necessary (ie, unless the
	     * fraction reduces to a positive integer) if `parens` is specified as
	     * truthy.
	     * - Will reduce the fraction `n`/`d` if `reduce` is specified as truthy.
	     * - Will defraction (spit out 0 if `n` is 0, spit out `n` if `d` is 1, or
	     * spit out `undefined` if `d` is 0) if `defraction` is specified as
	     * truthy. */
	    mixedFraction: function(number, n, d, defraction, reduce, small, parens) {
	        var wholeNum = number ? number : 0;
	        var numerator = n ? n : 0;
	        var denominator = d ? d : 1;

	        if (wholeNum < 0 && numerator < 0) {
	            throw "NumberFormatException: Both integer portion and fraction cannot both be negative.";
	        }
	        if (denominator < 0) {
	            throw "NumberFormatException: Denominator cannot be be negative.";
	        }
	        if (denominator === 0) {
	            throw "NumberFormatException: Denominator cannot be be 0.";
	        }

	        if (reduce) {
	            if (wholeNum < 0) {
	                wholeNum -= Math.floor(numerator / denominator);
	            } else {
	                wholeNum += Math.floor(numerator / denominator);
	            }

	            numerator = numerator % denominator;
	        }

	        if (wholeNum !== 0 && numerator !== 0) {
	            return wholeNum + " " + KhanUtil.fraction(n, d, defraction, reduce, small, parens);
	        } else if (wholeNum !== 0 && numerator === 0) {
	            return wholeNum;
	        } else if (wholeNum === 0 && numerator !== 0) {
	            return KhanUtil.fraction(n, d, defraction, reduce, small, parens);
	        } else {
	            return 0;
	        }
	    },

	    /* Calls fraction with the reduce and defraction flag enabled. Additional
	     * parameters correspond to the remaining fraction flags. */
	    fractionReduce: function(n, d, small, parens) {
	        return KhanUtil.fraction(n, d, true, true, small, parens);
	    },

	    /* Calls fraction with the small flag enabled. Additional parameters
	     * correspond to the remaining fraction flags. */
	    fractionSmall: function(n, d, defraction, reduce, parens) {
	        return KhanUtil.fraction(n, d, defraction, reduce, true, parens);
	    },

	    /* Interprets a decimal as a multiple of pi and formats it as would be
	     * expected.
	     *
	     * If niceAngle is truthy, it also delivers more natural values for 0 (0 instead
	     * of 0 \pi) and 1 (\pi instead of 1 \pi).
	     * */
	    piFraction: function(num, niceAngle, tolerance, big) {
	        if (num.constructor === Number) {
	            if (tolerance == null) {
	                tolerance = 0.001;
	            }

	            var f = KhanUtil.toFraction(num / Math.PI, tolerance),
	             n = f[0],
	             d = f[1];

	            if (niceAngle) {
	                if (n === 0) {
	                    return "0";
	                }
	                if (n === 1 && d === 1) {
	                    return "\\pi";
	                }
	            }
	            var frac = big ? KhanUtil.fraction(n, d) : KhanUtil.fractionSmall(n, d) ;
	            return d === 1 ? n + "\\pi" : frac + "\\pi";
	        }
	    },

	    /* Returns whether the fraction n/d reduces. */
	    reduces: function(n, d) {
	        // if the GCD is greater than 1, then there is a factor in common and the
	        // fraction reduces.
	        return KhanUtil.getGCD(n, d) > 1;
	    },

	    fractionSimplification: function(n, d) {
	        var result = "\\frac{" + n + "}{" + d + "}";

	        if (d <= 1 || KhanUtil.getGCD(n, d) > 1) {
	            result += " = " + KhanUtil.fractionReduce(n, d);
	        }

	        return result;
	    },

	    // Randomly return the fraction in its mixed or improper form.
	    mixedOrImproper: function(n, d) {
	        // mixed
	        if (n < d || KhanUtil.rand(2) > 0) {
	            return KhanUtil.fraction(n, d);

	        // improper
	        } else {
	            var imp = Math.floor(n / d);
	            return imp + KhanUtil.fraction(n - (d * imp), d);
	        }
	    },

	    // splitRadical(24) gives [2, 6] to mean 2 sqrt(6)
	    splitRadical: function(n) {
	        if (n === 0) {
	            return [0, 1];
	        }

	        var coefficient = 1;
	        var radical = n;

	        for (var i = 2; i * i <= n; i++) {
	            while (radical % (i * i) === 0) {
	                radical /= i * i;
	                coefficient *= i;
	            }
	        }

	        return [coefficient, radical];
	    },

	    // formattedSquareRootOf(24) gives 2\sqrt{6}
	    formattedSquareRootOf: function(n) {
	        if (n === 1 || n === 0) {
	            /* so as to not return "" or "\\sqrt{0}" later */
	            return n.toString();
	        } else {
	            var split = KhanUtil.splitRadical(n);
	            var coefficient = split[0] === 1 ? "" : split[0].toString();
	            var radical = split[1] === 1 ? "" : "\\sqrt{" + split[1] + "}";

	            return coefficient + radical;
	        }
	    },

	    squareRootCanSimplify: function(n) {
	        return KhanUtil.formattedSquareRootOf(n) !== ("\\sqrt{" + n + "}");
	    },

	    // For numbers 0-20, return the spelling of the number, otherwise
	    // just return the number itself as a string.  This is superior to
	    // cardinal() in that it can be translated easily.
	    cardinalThrough20: function(n) {
	        var cardinalUnits = [$._("zero"), $._("one"), $._("two"), $._("three"),
	            $._("four"), $._("five"), $._("six"), $._("seven"), $._("eight"),
	            $._("nine"), $._("ten"), $._("eleven"), $._("twelve"),
	            $._("thirteen"), $._("fourteen"), $._("fifteen"), $._("sixteen"),
	            $._("seventeen"), $._("eighteen"), $._("nineteen"), $._("twenty")];
	        if (n >= 0 && n <= 20) {
	            return cardinalUnits[n];
	        }
	        return String(n);
	    },

	    CardinalThrough20: function(n) {
	        // NOTE(csilvers): I *think* this always does the right thing,
	        // since scripts that capitalize always do so the same way.
	        var card = KhanUtil.cardinalThrough20(n);
	        return card.charAt(0).toUpperCase() + card.slice(1);
	    },

	    ordinalThrough20: function(n) {
	        var ordinalUnits = [$._("zeroth"), $._("first"), $._("second"),
	            $._("third"), $._("fourth"), $._("fifth"), $._("sixth"),
	            $._("seventh"), $._("eighth"), $._("ninth"), $._("tenth"),
	            $._("eleventh"), $._("twelfth"), $._("thirteenth"),
	            $._("fourteenth"), $._("fifteenth"), $._("sixteenth"),
	            $._("seventeenth"), $._("eighteenth"), $._("nineteenth"),
	            $._("twentieth")];
	        if (n >= 0 && n <= 20) {
	            return ordinalUnits[n];
	        }
	        // This should "never" happen, but better to give weird results
	        // than to raise an error.  I think.
	        return n + "th";
	    },

	    // Ported from https://github.com/clojure/clojure/blob/master/src/clj/clojure/pprint/cl_format.clj#L285
	    // TODO(csilvers): I18N: this doesn't work at all outside English.
	    // cf. https://github.com/kslazarev/numbers_and_words (Ruby, sadly).
	    cardinal: function(n) {
	        var cardinalScales = ["", $._("thousand"), $._("million"),
	            $._("billion"), $._("trillion"), $._("quadrillion"),
	            $._("quintillion"), $._("sextillion"), $._("septillion"),
	            $._("octillion"), $._("nonillion"), $._("decillion"),
	            $._("undecillion"), $._("duodecillion"), $._("tredecillion"),
	            $._("quattuordecillion"), $._("quindecillion"),
	            $._("sexdecillion"), $._("septendecillion"), $._("octodecillion"),
	            $._("novemdecillion"), $._("vigintillion")];
	        var cardinalUnits = [$._("zero"), $._("one"), $._("two"), $._("three"),
	            $._("four"), $._("five"), $._("six"), $._("seven"), $._("eight"),
	            $._("nine"), $._("ten"), $._("eleven"), $._("twelve"),
	            $._("thirteen"), $._("fourteen"), $._("fifteen"), $._("sixteen"),
	            $._("seventeen"), $._("eighteen"), $._("nineteen")];
	        var cardinalTens = ["", "", $._("twenty"), $._("thirty"), $._("forty"),
	            $._("fifty"), $._("sixty"), $._("seventy"), $._("eighty"),
	            $._("ninety")];
	        // For formatting numbers less than 1000
	        var smallNumberWords = function(n) {
	            var hundredDigit = Math.floor(n / 100);
	            var rest = n % 100;
	            var str = "";

	            if (hundredDigit) {
	                str += $._("%(unit)s hundred",
	                    {unit: cardinalUnits[hundredDigit]});
	            }

	            if (hundredDigit && rest) {
	                str += " ";
	            }

	            if (rest) {
	                if (rest < 20) {
	                    str += cardinalUnits[rest];
	                } else {
	                    var tenDigit = Math.floor(rest / 10);
	                    var unitDigit = rest % 10;

	                    if (tenDigit) {
	                        str += cardinalTens[tenDigit];
	                    }

	                    if (tenDigit && unitDigit) {
	                        str += "-";
	                    }

	                    if (unitDigit) {
	                        str += cardinalUnits[unitDigit];
	                    }
	                }
	            }

	            return str;
	        };

	        if (n === 0) {
	            return $._("zero");
	        } else {
	            var neg = false;
	            if (n < 0) {
	                neg = true;
	                n = Math.abs(n);
	            }

	            var words = [];
	            var scale = 0;
	            while (n > 0) {
	                var end = n % 1000;

	                if (end > 0) {
	                    if (scale > 0) {
	                        words.unshift(cardinalScales[scale]);
	                    }

	                    words.unshift(smallNumberWords(end));
	                }

	                n = Math.floor(n / 1000);
	                scale += 1;
	            }

	            if (neg) {
	                words.unshift($._("negative"));
	            }

	            return words.join(" ");
	        }
	    },

	    Cardinal: function(n) {
	        var card = KhanUtil.cardinal(n);
	        return card.charAt(0).toUpperCase() + card.slice(1);
	    },

	    // Depends on expressions.js for expression formatting
	    // Returns a string with the expression for the formatted roots of the quadratic
	    // with coefficients a, b, c
	    // i.e. "x = \pm 3", "
	    quadraticRoots: function(a, b, c) {
	        var underRadical = KhanUtil.splitRadical(b * b - 4 * a * c);
	        var rootString = "x =";

	        if ((b * b - 4 * a * c) === 0) {
	            // 0 under the radical
	            rootString += KhanUtil.fraction(-b, 2 * a, true, true, true);
	        } else if (underRadical[1] === 1) {
	            // The absolute value of the number under the radical is a perfect square
	            rootString += KhanUtil.fraction(-b + underRadical[0], 2 * a, true, true, true) + "," +
	                KhanUtil.fraction(-b - underRadical[0], 2 * a, true, true, true);
	        } else if (underRadical[0] === 1) {
	            // The number under the radical cannot be simplified
	            rootString += KhanUtil.expr(["frac", ["+-", -b, ["sqrt", underRadical[1]]], 2 * a]);
	        } else {
	            // under the radical can be partially simplified
	            var divisor = KhanUtil.getGCD(b, 2 * a, underRadical[0]);

	            if (divisor === Math.abs(2 * a)) {
	                rootString += KhanUtil.expr(["+-", -b / (2 * a), ["*", underRadical[0] / divisor,
	                                                                 ["sqrt", underRadical[1]]]]);
	            } else {
	                rootString += KhanUtil.expr(["frac", ["+-", -b / divisor, ["*", underRadical[0] / divisor,
	                                                                                ["sqrt", underRadical[1]]]],
	                                                     2 * a / divisor]);
	            }
	        }
	        return rootString;
	    },

	    // Thanks to Ghostoy on http://stackoverflow.com/questions/6784894/commafy/6786040#6786040
	    commafy: function(num) {
	        var str = num.toString().split(".");
	        var thousands = icu.getDecimalFormatSymbols().grouping_separator;
	        var decimal = icu.getDecimalFormatSymbols().decimal_separator;

	        // Note that this is not actually the space character. You can find
	        // this character in the icu.XX.js files that use space separators (for
	        // example, icu.fr.js)
	        if (thousands === " ") {
	            thousands = "\\;";
	        }

	        if (str[0].length >= 5) {
	            str[0] = str[0].replace(/(\d)(?=(\d{3})+$)/g,
	                                    "$1{" + thousands + "}");
	        }

	        if (str[1] && str[1].length >= 5) {
	            str[1] = str[1].replace(/(\d{3})(?=\d)/g, "$1\\;");
	        }

	        return str.join(decimal);
	    },

	    // Formats strings like "Axy + By + Cz + D" where A, B, and C are variables
	    // initialized to unknown values. Formats things so that TeX takes care of
	    // negatives, and also handles cases where the strings beind added are wrapped
	    // in TeX color declarations (\color{blue}{Axy} to \color{blue}{xy} if A is 1,
	    // and won't be inserted at all if A is 0). Also <code><var>plus(A, B, C)
	    // </var></code> is cleaner than <code><var>A</var> + <var>B</var> + <var>C</var></code>.
	    // Note: this is somewhat treading on the territory of expressions.js, but has
	    // a slightly different use case.
	    plus: function() {

	        var args = [], s;

	        for (var i = 0; i < arguments.length; i++) {
	            s = KhanUtil._plusTrim(arguments[i]);
	            if (s) {
	                args.push(s);
	            }
	        }

	        return args.length > 0 ? args.join(" + ") : "0";
	    },

	    _plusTrim: function(s) {
	        
	        if (typeof s === "string" && isNaN(s)) {

	            // extract color, so we can handle stripping the 1 out of \color{blue}{1xy}
	            if (s.indexOf("{") !== -1) {

	                // we're expecting something like "\color{blue}{-1}..."
	                var l = s.indexOf("{", s.indexOf("{") + 1) + 1;
	                var r = s.indexOf("}", s.indexOf("}") + 1);

	                // if we've encountered \color{blue}{1}\color{xy} somehow
	                if (l !== s.lastIndexOf("{") + 1 && +KhanUtil._plusTrim(s.slice(l, r)) === 1) {
	                    if (s.indexOf("\\") !== -1) {
	                        return s.slice(0, s.indexOf("\\")) + s.slice(r + 1);
	                    } else {
	                        return s.slice(r + 1);
	                    }
	                }

	                return s.slice(0, l) + KhanUtil._plusTrim(s.slice(l, r)) + s.slice(r);
	            }

	            if (s.indexOf("1") === 0 && isNaN(s[1])) {
	                return s.slice(1);
	            } else if (s.indexOf("-1") === 0 && isNaN(s[2])) {
	                return "-" + s.slice(2);
	            } else if (s.indexOf("0") === 0 || s.indexOf("-0") === 0) {
	                return "";
	            } else {
	                return s;
	            }

	        } else if (typeof s === "number") {

	            // we'll just return the number, but this will actually end up getting
	            // rid of 0's since a returned 0 will be falsey.
	            return s;

	            // if we're dealing with a string that looks like a number
	        } else if (!isNaN(s)) {

	            return +s;

	        }

	    },

	    randVar: function() {
	        // NOTE(jeresig): i18n: I assume it's OK to have roman letters here
	        return KhanUtil.randFromArray(["a", "k", "n", "p", "q", "r", "t", "x", "y", "z"]);
	    },

	    eulerFormExponent: function(angle) {
	        var fraction = KhanUtil.toFraction(angle / Math.PI, 0.001);
	        var numerator = fraction[0], denominator = fraction[1];
	        var eExp = ((numerator > 1) ? numerator : "") + "\\pi i";
	        if (denominator !== 1) {
	            eExp += " / " + denominator;
	        }
	        return eExp;
	    },

	    // Formats a complex number in polar form.
	    polarForm: function(radius, angle, useEulerForm) {
	        var fraction = KhanUtil.toFraction(angle / Math.PI, 0.001);
	        var numerator = fraction[0];

	        var equation;
	        if (useEulerForm) {
	            if (numerator > 0) {
	                var ePower = KhanUtil.expr(["^", "e", KhanUtil.eulerFormExponent(angle)]);
	                equation = ((radius > 1) ? radius : "") + " " + ePower;
	            } else {
	                equation = radius;
	            }
	        } else {
	            if (angle === 0) {
	                equation = radius;
	            } else {
	                var angleRep = KhanUtil.piFraction(angle, true);
	                var cis = "\\cos \\left(" + angleRep + "\\right) + i \\sin \\left(" + angleRep + "\\right)";

	                // Special case to circumvent ugly "*1* (sin(...) + i cos(...))"
	                if (radius !== 1) {
	                    equation = radius + "\\left(" + cis + "\\right)";
	                } else {
	                    equation = cis;
	                }
	            }
	        }
	        return equation;
	    },

	    coefficient: function(n) {
	        if (n === 1 || n === "1") {
	            return "";
	        } else if (n === -1 || n === "-1") {
	            return "-";
	        } else {
	            return n;
	        }
	    },

	    fractionVariable: function(numerator, denominator, variable) {
	        variable = variable || "";
	        
	        if (denominator === 0) {
	            return "\\text{undefined}";
	        }

	        if (numerator === 0) {
	            return 0;
	        }

	        if (typeof denominator === "number") {
	            if (denominator < 0) {
	                numerator *= -1;
	                denominator *= -1;
	            }

	            var GCD = KhanUtil.getGCD(numerator, denominator);
	            numerator /= GCD;
	            denominator /= GCD;

	            if (denominator === 1) {
	                return KhanUtil.coefficient(numerator) + variable;
	            }
	        }

	        if (numerator < 0) {
	            return "-\\dfrac{" + KhanUtil.coefficient(-numerator) + variable + "}{" + denominator + "}";
	        } else {
	            return "\\dfrac{" + KhanUtil.coefficient(numerator) + variable + "}{" + denominator + "}";
	        }
	    },

	    complexNumber: function(real, imaginary) {
	        if (real === 0 && imaginary === 0) {
	            return "0";
	        } else if (real === 0) {
	            return (KhanUtil.coefficient(imaginary)) + "i";
	        } else if (imaginary === 0) {
	            return real;
	        } else {
	            return KhanUtil.expr(["+", real, ["*", imaginary, "i"]]);
	        }
	    },

	    complexFraction: function(real, realDenominator, imag, imagDenominator) {
	        var ret = "";
	        if (real === 0 && imag === 0) {
	            ret = "0";
	        }
	        if (real !== 0) {
	            ret += KhanUtil.fraction(real, realDenominator, false, true);
	        }
	        if (imag !== 0) {
	            if (imag / imagDenominator > 0) {
	                if (real !== 0) {
	                    ret += " + ";
	                }
	                ret += KhanUtil.fraction(imag, imagDenominator, false, true) + " i";
	            } else {
	                imag = Math.abs(imag);
	                imagDenominator = Math.abs(imagDenominator);
	                ret += " - ";
	                ret += KhanUtil.fraction(imag, imagDenominator, false, true) + " i";
	            }
	        }
	        return ret;
	    },

	    scientificExponent: function(num) {
	        return Math.floor(Math.log(Math.abs(num)) / Math.log(10));
	    },

	    scientificMantissa: function(precision, num) {
	        var exponent = KhanUtil.scientificExponent(num);
	        var factor = Math.pow(10, exponent);
	        precision -= 1; // To account for the 1s digit
	        var mantissa = KhanUtil.roundTo(precision, num / factor);
	        return mantissa;
	    },

	    scientific: function(precision, num) {
	        var exponent = KhanUtil.scientificExponent(num);
	        var mantissa = KhanUtil.localeToFixed(KhanUtil.scientificMantissa(precision, num), precision);
	        return "" + mantissa + "\\times 10^{" + exponent + "}";
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Allows for intuitive matrix input for matrix exercises.
	 *
	 * See `matrix_transpose.html` for an example.
	 *
	 * To use in an exercise:
	 *
	 * 1. Add "matrix matrix-input" to data-require.
	 *
	 * 2. Use `matrixPad()` to pad the solution matrix with empty string values
	 *     and assign to a `var` named `PADDED_SOLN_MAT`:
	 *
	 * Ex: <var id="PADDED_SOLN_MAT">matrixPad(SOLN_MAT, 3, 3)</var>
	 *
	 * 3. Use the following HTML for the
	 *     solution markup:
	 *
	 * <div class="solution" data-type="multiple">
	 *     <div data-each="PADDED_SOLN_MAT as row" class="row">
	 *         <div data-each="row as elem">
	 *             <div data-if="elem !== ''" class="sol">
	 *                 <var>elem</var>
	 *             </div>
	 *             <div data-else data-type="text" class="sol">
	 *                 <var>elem</var>
	 *             </div>
	 *         </div>
	 *     </div>
	 * </div>
	 *
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(57);

	$.extend(KhanUtil, {

	    matrixInput: {

	        eventsAttached: false,

	        eventNamespace: "matrix-input",

	        containerEl: null,
	        bracketEls: null,
	        cells: null,

	        LEFT_ARROW: 37,
	        UP_ARROW: 38,
	        RIGHT_ARROW: 39,
	        DOWN_ARROW: 40,
	        ENTER_KEY: 13,

	        ROWS: 3,
	        COLS: 3,

	        maxRow: 0,
	        maxCol: 0,

	        contentMaxRow: 0,
	        contentMaxCol: 0,

	        init: function() {
	            var self = this;

	            this.initContainer();

	            var inputs = $(".matrix-row .sol input[type='text']");
	            this.cells = _.map(inputs, function(input, i) {
	                return {
	                    el: input,
	                    index: i,
	                    row: self.indexToRow(i),
	                    col: self.indexToCol(i),
	                    val: function() {
	                        return $.trim($(this.el).val());
	                    },
	                    clearVal: function() {
	                        $(this.el).val("");
	                    }
	                };
	            });

	            this.addBrackets();
	            this.bindInputEvents();
	            this.resetAllMaxVals();
	            this.render();
	        },

	        initContainer: function() {
	            this.containerEl = $("#solutionarea .matrix-input");
	            if (!this.containerEl[0]) {
	                this.containerEl = $("#solutionarea").addClass("matrix-input");
	            }
	        },

	        addBrackets: function(i) {
	            var left = $("<div>").addClass("matrix-bracket bracket-left");
	            var right = $("<div>").addClass("matrix-bracket bracket-right");
	            this.containerEl.prepend(left, right);
	            this.bracketEls = [left, right];
	        },

	        removeBrackets: function() {
	            _.each(this.bracketEls, function(bracketEl) {
	                $(bracketEl).remove();
	            });
	        },

	        indexToRow: function(i) {
	            return Math.floor(i / this.COLS);
	        },

	        indexToCol: function(i) {
	            return i % this.COLS;
	        },

	        coordToIndex: function(row, col) {
	            return this.COLS * row + col;
	        },

	        bindInputEvents: function() {
	            // We reevaluate the highlighted area after:
	            // 1) clicking on some element besides the cells, or
	            // 2) tabbing to a new cell in the solution area
	            // This is sufficient since these are the only ways
	            // the user will get to change the value.
	            var self = this;

	            // Track whether or not a click originated in an input to avoid
	            // calling the global matrix sizing reset that we append to <body>
	            var clickedInput = false;

	            // case #1
	            $("body").on("click." + self.eventNamespace, function() {
	                if (!clickedInput) {
	                    self.resetMaxToContentMax();
	                    self.render();
	                }
	                clickedInput = false;
	            });

	            _.each(this.cells, function(cell) {

	                $(cell.el).on({
	                    // case #2
	                    focus: function(e) {
	                        self.setMaxVals(cell);
	                        self.render();
	                    },

	                    blur: function(e) {
	                        self.setMaxVals(cell);
	                    },

	                    // case #1 (track whether or not a click originated in an
	                    // input to avoid calling the click event bound to <body>)
	                    click: function(e) {
	                        clickedInput = true;
	                    },

	                    keydown: function(e) {
	                        var LAST_ROW = self.ROWS - 1;
	                        var LAST_INDEX = self.cells.length - 1;

	                        var nextIndex = null;
	                        var nextRow;

	                        // cursor position only does something when you
	                        // are at the start of the input, moving left, or
	                        // at the end of the input, moving right

	                        if (e.which === self.LEFT_ARROW) {
	                            // don't do anything if at the first cell
	                            // or if the cursor is not at the start
	                            if (cell.index === 0 || !$(this).isCursorFirst()) {
	                                 return;
	                            }
	                            nextIndex = cell.index - 1;

	                        } else if (e.which === self.RIGHT_ARROW) {
	                            // don't do anything if at the last cell
	                            // or if the cursor is not at the end of the input
	                            // text
	                            if (cell.index === LAST_INDEX ||
	                                !$(this).isCursorLast()) {
	                                return;
	                            }
	                            nextIndex = cell.index + 1;

	                        } else if (e.which === self.UP_ARROW) {
	                            // if already on first row, don't do anything
	                            if (cell.row === 0) {
	                                return;
	                            }
	                            nextRow = cell.row - 1;
	                            nextIndex = self.coordToIndex(nextRow, cell.col);

	                        } else if (e.which === self.DOWN_ARROW) {
	                            // if on last row, don't do anything
	                            if (cell.row === LAST_ROW) {
	                                return;
	                            }
	                            nextRow = cell.row + 1;
	                            nextIndex = self.coordToIndex(nextRow, cell.col);

	                        // when submitting via enter key, make sure max vals
	                        // are set properly
	                        } else if (e.which === self.ENTER_KEY) {
	                            self.setMaxVals(cell);
	                        }

	                        // let default behavior take place if we don't do
	                        // anything
	                        if (nextIndex === null) {
	                            return;
	                        }

	                        // change focus to next input
	                        $(self.cells[nextIndex].el).focus();

	                        // don't let event bubble
	                        e.preventDefault();
	                    }
	                });
	            });
	        },

	        setContentMaxRow: function(val) {
	            this.contentMaxRow = Math.max(val, this.contentMaxRow);
	        },

	        setContentMaxCol: function(val) {
	            this.contentMaxCol = Math.max(val, this.contentMaxCol);
	        },

	        // maxRow/maxCol is the max of the currently selected element and the
	        // content max element
	        setMaxRow: function(val) {
	            this.maxRow = Math.max(val, this.contentMaxRow);
	        },

	        setMaxCol: function(val) {
	            this.maxCol = Math.max(val, this.contentMaxCol);
	        },

	        resetMaxToContentMax: function() {
	            this.maxRow = this.contentMaxRow;
	            this.maxCol = this.contentMaxCol;
	        },

	        resetAllMaxVals: function() {
	            this.maxRow = 0;
	            this.maxCol = 0;
	            this.contentMaxRow = 0;
	            this.contentMaxCol = 0;
	        },

	        setMaxValsFromScratch: function() {
	            // initialize to 0, since we want to start from scratch
	            this.resetAllMaxVals();

	            var self = this;
	            _.each(this.cells, function(cell) {
	                if (cell.val()) {
	                    self.setContentMaxRow(cell.row);
	                    self.setContentMaxCol(cell.col);
	                }
	            });

	            this.resetMaxToContentMax();
	        },

	        setMaxVals: function(cell) {
	            var val = cell.val();

	            // cell is nonempty
	            if (val) {
	                // only nonempty cell can be used to set content max values
	                // unless (see case below)
	                this.setContentMaxRow(cell.row);
	                this.setContentMaxCol(cell.col);

	            // cell is empty
	            } else {
	                // reset the contents of the cell when it's just spaces
	                cell.clearVal();

	                // if it was the cell responsible for a content max val(s),
	                // we need to find the new content max val(s)...
	                if (this.contentMaxRow === cell.row ||
	                    this.contentMaxCol === cell.col) {

	                    this.setMaxValsFromScratch();
	                }
	            }

	            // both nonempty and empty cells can set absolute max values
	            this.setMaxRow(cell.row);
	            this.setMaxCol(cell.col);
	        },

	        // position matrix brackets based on bounds
	        positionBrackets: function() {

	            var cell = $(this.cells[0].el);
	            var bracketWidth = this.bracketEls[0].width();

	            var rows = this.maxRow + 1;
	            var cols = this.maxCol + 1;

	            var height = cell.outerHeight(true) * rows;
	            var marginLeft = cell.outerWidth(true) * cols - bracketWidth;

	            _.each(this.bracketEls, function($el) {
	                $el.css({
	                    "height": height
	                });
	            });

	            // right bracket
	            this.bracketEls[1].css({
	                "margin-left": marginLeft
	            });
	        },

	        render: function() {
	            this.positionBrackets();
	        },

	        cleanup: function() {
	            $("body").off("." + this.eventNamespace);
	            this.removeBrackets();
	        }
	    }
	});

	$.fn["matrix-inputLoad"] = function() {
	    if (KhanUtil.matrixInput.eventsAttached) {
	        return;
	    }

	    $(Exercises).on("newProblem.matrix-input", function() {
	        KhanUtil.matrixInput.init();
	    });

	    $(Khan).on("showGuess.matrix-input", function() {
	        KhanUtil.matrixInput.setMaxValsFromScratch();
	        KhanUtil.matrixInput.render();
	    });

	    KhanUtil.matrixInput.eventsAttached = true;
	};

	$.fn["matrix-inputCleanup"] = function() {
	    if (!KhanUtil.matrixInput.eventsAttached) {
	        return;
	    }

	    KhanUtil.matrixInput.cleanup();
	    $(Exercises).off("newProblem.matrix-input");
	    $(Khan).off("showGuess.matrix-input");

	    KhanUtil.matrixInput.eventsAttached = false;
	};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(50);

	$.extend(KhanUtil, {

	    updateMean: function(mean) {
	        var graph = KhanUtil.currentGraph;

	        graph.graph.meanArrow.translate((mean * graph.scale[0]) - graph.graph.meanArrow.attr("translation").x, 0);
	        graph.graph.meanValueLabel.remove();
	        graph.graph.meanValueLabel = graph.label([mean, 0.8],
	            (mean + "").replace(/-(\d)/g, "\\llap{-}$1"),
	            "above",
	            { color: KhanUtil.BLUE }
	        );

	        graph.graph.meanLabel.remove();
	        graph.graph.meanLabel = graph.label([mean, 1.3], $._("\\text{mean}"),
	            "above", { color: KhanUtil.BLUE });

	        graph.graph.mean = mean;
	    },


	    updateMedian: function(median) {
	        var graph = KhanUtil.currentGraph;

	        graph.graph.medianArrow.translate((median * graph.scale[0]) - graph.graph.medianArrow.attr("translation").x, 0);
	        graph.graph.medianValueLabel.remove();
	        graph.graph.medianValueLabel = graph.label([median, -1.2],
	            (median + "").replace(/-(\d)/g, "\\llap{-}$1"),
	            "below",
	            { color: KhanUtil.GREEN }
	        );

	        graph.graph.medianLabel.remove();
	        graph.graph.medianLabel = graph.label([median, -1.7],
	            $._("\\text{median}"), "below", { color: KhanUtil.GREEN });

	        graph.graph.median = median;
	    },

	    updateMeanAndMedian: function() {
	        var points = KhanUtil.currentGraph.graph.points;
	        var mean = KhanUtil.mean($.map(points, function(el) { return el.coord[0]; }));
	        var median = KhanUtil.median($.map(points, function(el) { return el.coord[0]; }));

	        KhanUtil.updateMean(KhanUtil.roundTo(2, mean));
	        KhanUtil.updateMedian(KhanUtil.roundTo(2, median));
	    },

	    updateMeanAndStddev: function() {
	        var graph = KhanUtil.currentGraph;
	        var points = KhanUtil.currentGraph.graph.points;
	        var mean = KhanUtil.mean($.map(points, function(el) { return el.coord[0]; }));
	        var stddev = KhanUtil.stdDev($.map(points, function(el) { return el.coord[0]; }));

	        mean = KhanUtil.roundTo(1, mean);
	        stddev = KhanUtil.roundTo(1, stddev);

	        graph.graph.stddevLeft.translate(((mean) * graph.scale[0]) - graph.graph.stddevLeft.attr("translation").x, 0);
	        graph.graph.stddevRight.translate(((mean + stddev) * graph.scale[0]) - graph.graph.stddevRight.attr("translation").x, 0);
	        graph.graph.stddevLine.translate(((mean) * graph.scale[0]) - graph.graph.stddevLine.attr("translation").x, 0);
	        graph.graph.stddevLine.scale(stddev, 1, graph.graph.stddevLine.attr("path")[0][1], graph.graph.stddevLine.attr("path")[0][2]);

	        graph.graph.stddevValueLabel.remove();
	        graph.graph.stddevValueLabel = graph.label([stddev / 2 + mean, -1.3], "s \\approx " + stddev, "below", { color: KhanUtil.GREEN });

	        if (stddev > 0) {

	            graph.style({ strokeWidth: 2, stroke: "#bbb", fill: null, "plot-points": 100 }, function() {
	                graph.graph.pdf.remove();
	                graph.graph.pdf = graph.plot(function(x) {
	                    return KhanUtil.gaussianPDF(mean, stddev, x) * 5 - 0.2;
	                }, [-7, 7]).toBack();
	            });

	            graph.style({ strokeWidth: 2, stroke: KhanUtil.BLUE, fill: null }, function() {
	                graph.graph.meanLine.remove();
	                graph.graph.meanLine = graph.line([mean, -0.2], [mean, KhanUtil.gaussianPDF(mean, stddev, mean) * 5 - 0.2]).toBack();
	            });

	            graph.graph.meanValueLabel.remove();
	            graph.graph.meanValueLabel = graph.label(
	                [mean, KhanUtil.gaussianPDF(mean, stddev, mean) * 5 - 0.2],
	                "\\bar{x} \\approx " + mean, "above", { color: KhanUtil.BLUE }
	            );

	            var points = [];

	            points.push([mean - stddev, -0.2]);
	            points.push([mean - stddev, KhanUtil.gaussianPDF(mean, stddev, mean - stddev) * 5 - 0.2]);
	            var step = stddev / 50;
	            for (var x = mean - stddev; x <= mean + stddev; x += step) {
	                points.push([x, KhanUtil.gaussianPDF(mean, stddev, x) * 5 - 0.2]);
	            }
	            points.push([mean + stddev, KhanUtil.gaussianPDF(mean, stddev, mean + stddev) * 5 - 0.2]);
	            points.push([mean + stddev, -0.2]);

	            graph.style({ strokeWidth: 0, stroke: null, fill: KhanUtil.GREEN, opacity: 0.3 }, function() {
	                graph.graph.stddevArea.remove();
	                graph.graph.stddevArea = graph.path(points).toBack();
	            });

	        } else {
	            graph.graph.pdf.remove();
	            graph.graph.pdf = KhanUtil.bogusShape;
	        }


	        graph.graph.mean = mean;
	        graph.graph.stddev = stddev;
	    },


	    onMovePoint: function(point, x, y, updateFunction) {
	        var points = KhanUtil.currentGraph.graph.points;

	        // don't allow the point to move past the bounds
	        x = Math.min(Math.max(-7, x), 7);

	        // Don't do anything unless the point actually moved
	        if (point.coord[0] !== x) {

	            point.coord = [x, 0];

	            // Figure out which points are at the same position
	            var positions = {};
	            // The point being dragged is always at the bottom of the pile
	            positions[Math.round(x * 2) / 2] = [point];

	            $.each(points, function() {
	                if (this !== point) {
	                    var pos = Math.round(this.coord[0] * 2) / 2;
	                    if (!_.isArray(positions[pos])) {
	                        positions[pos] = [];
	                    }
	                    positions[pos].push(this);
	                }
	            });

	            if (_.isFunction(updateFunction)) {
	                updateFunction();
	            }

	            // Adjust the y-value of each point in case points are stacked
	            $.each(positions, function(value, points) {
	                points = points.sort(function(a, b) { return a.coord[1] - b.coord[1]; });
	                $.each(points, function(i, point) {
	                    if (updateFunction !== undefined) {
	                        point.moveTo(point.coord[0], 0.3 * i);
	                    } else {
	                        point.setCoord([point.coord[0], 0.3 * i]);
	                    }
	                });
	            });

	            return [x, 0];
	        }
	    },


	    arrangePointsAroundMedian: function() {
	        var graph = KhanUtil.currentGraph;
	        var points = graph.graph.points;
	        var targetMedian = graph.graph.targetMedian;
	        var numPoints = graph.graph.numPoints;
	        var maxWidth = Math.min(Math.abs(-7 - targetMedian), Math.abs(7 - targetMedian));

	        var distance = 0.5;
	        var newValues = [];
	        if (numPoints % 2 === 0) {
	            newValues.push(targetMedian + distance);
	            newValues.push(targetMedian - distance);
	            distance += 0.5;
	        } else {
	            newValues.push(targetMedian);
	        }

	        while (newValues.length < points.length) {
	            newValues.push(targetMedian + distance);
	            newValues.push(targetMedian - distance);
	            if (distance >= maxWidth) {
	                distance = 0.5;
	            } else {
	                distance += 0.5;
	            }
	        }
	        return KhanUtil.sortNumbers(newValues);
	    },


	    animatePoints: function(oldValues, newValues, newMedian, newMean) {
	        var graph = KhanUtil.currentGraph;
	        var points = graph.graph.points;
	        var sortedPoints = points.sort(function(a, b) { return a.coord[0] - b.coord[0]; });

	        $.each(oldValues, function(i, oldValue) {
	            $({ 0: oldValue }).animate({ 0: newValues[i] }, {
	                duration: 500,
	                step: function(now, fx) {
	                    KhanUtil.onMovePoint(sortedPoints[i], now, 0);
	                }
	            });
	        });

	        $({ median: graph.graph.median, mean: graph.graph.mean }).animate({
	            median: newMedian, mean: newMean
	        }, {
	            duration: 500,
	            step: function(now, fx) {
	                if (fx.prop === "median") {
	                    KhanUtil.updateMedian(KhanUtil.roundTo(2, now));
	                } else if (fx.prop === "mean") {
	                    KhanUtil.updateMean(KhanUtil.roundTo(2, now));
	                }
	            }
	        });
	    },


	    showMedianExample: function(onComplete) {
	        var points = KhanUtil.currentGraph.graph.points;
	        var targetMedian = KhanUtil.currentGraph.graph.targetMedian;
	        var sortedPoints = points.sort(function(a, b) { return a.coord[0] - b.coord[0]; });
	        var oldValues = [];
	        $.each(sortedPoints, function(i, point) {
	            oldValues.push(point.coord[0]);
	        });
	        var newValues = KhanUtil.arrangePointsAroundMedian();

	        KhanUtil.animatePoints(oldValues, newValues, targetMedian, targetMedian);
	        KhanUtil.currentGraph.graph.moved = true;
	    },


	    showMeanExample: function() {
	        var graph = KhanUtil.currentGraph;
	        var points = graph.graph.points;

	        var calculateMean = function(values) {
	            var mean = 0;
	            $.each(values, function() {
	                mean += this;
	            });
	            mean /= values.length;
	            return mean;
	        };

	        var sortedPoints = points.sort(function(a, b) { return a.coord[0] - b.coord[0]; });
	        var oldValues = [];
	        $.each(sortedPoints, function(i, point) {
	            oldValues.push(point.coord[0]);
	        });

	        var newValues = KhanUtil.arrangePointsAroundMedian();

	        // Keep moving outlier points further away from the median until
	        // we get to the right mean
	        var mean = calculateMean(newValues);
	        while (mean !== graph.graph.targetMean) {
	            if (mean < graph.graph.targetMean) {
	                // Start by moving the right-most point further to the right, then the next, etc.
	                var pointToMove = newValues.length - 1;
	                while (newValues[pointToMove] === 7 && pointToMove > (points.length / 2)) {
	                    --pointToMove;
	                }
	                // If we move all the points on the right of the median all the way to the right
	                // and we still don't have the right mean, start moving points on the left
	                // closer to the median
	                if (pointToMove <= (points.length / 2)) {
	                    pointToMove = 0;
	                }
	                newValues[pointToMove] += 0.5;
	            } else {
	                // Start by moving the left-most point further to the left, then the next, etc.
	                var pointToMove = 0;
	                while (newValues[pointToMove] === -7 && pointToMove < (points.length / 2 - 1)) {
	                    ++pointToMove;
	                }
	                // If we move all the points on the left of the median all the way to the left
	                // and we still don't have the right mean, start moving points on the right
	                // closer to the median
	                if (pointToMove >= (points.length / 2 - 1)) {
	                    pointToMove = newValues.length - 1;
	                }
	                newValues[pointToMove] -= 0.5;
	            }
	            mean = calculateMean(newValues);
	            newValues = KhanUtil.sortNumbers(newValues);
	        }

	        KhanUtil.animatePoints(oldValues, newValues, graph.graph.targetMedian, graph.graph.targetMean);
	        KhanUtil.currentGraph.graph.moved = true;
	    },

	    showStddevExample: function() {
	        var points = KhanUtil.currentGraph.graph.points;
	        var targetStddev = KhanUtil.currentGraph.graph.targetStddev;
	        var sortedPoints = points.sort(function(a, b) { return a.coord[0] - b.coord[0]; });
	        var oldValues = [];
	        $.each(sortedPoints, function(i, point) {
	            oldValues.push(point.coord[0]);
	        });
	        var newValues = new Array(points.length);

	        // brute force answer finder :(
	        var loopCount = 0;
	        do {
	            newValues = $.map(newValues, function() {
	                return KhanUtil.roundToNearest(0.5, KhanUtil.randGaussian() * targetStddev);
	            });
	            newValues = KhanUtil.sortNumbers(newValues);
	            ++loopCount;
	        } while (loopCount < 1000 && (
	            KhanUtil.roundTo(1, KhanUtil.mean(newValues) !== 0) ||
	            KhanUtil.roundTo(1, KhanUtil.stdDev(newValues)) !== targetStddev ||
	            _.isEqual(oldValues, newValues)
	        ));
	        if (loopCount === 1000) {
	            // better this than an infinte loop
	            newValues = oldValues.slice();
	        }


	        $.each(oldValues, function(i, oldValue) {
	            $({ 0: oldValue }).animate({ 0: newValues[i] }, {
	                duration: 500,
	                step: function(now, fx) {
	                    KhanUtil.onMovePoint(sortedPoints[i], now, 0);
	                }
	            });
	        });
	        $({ 0: 0 }).animate({ 0: 1 }, {
	            duration: 600,
	            step: function(now, fx) {
	                KhanUtil.updateMeanAndStddev();
	            }
	        });
	        KhanUtil.currentGraph.graph.moved = true;
	    }

	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {
	    doParabolaInteraction: function(func, vertex, directrix) {
	        var graph = KhanUtil.currentGraph;

	        var vertexLine = KhanUtil.bogusShape;
	        var directrixLine = KhanUtil.bogusShape;
	        var lineEndcap = KhanUtil.bogusShape;
	        var highlighted = false;

	        // Attach an onMove handler that gets called whenever the mouse hovers over
	        // the parabola
	        func.onMove = function(coordX, coordY) {
	            vertexLine.remove();
	            directrixLine.remove();
	            lineEndcap.remove();
	            graph.style({ strokeWidth: 1.5, stroke: KhanUtil.GREEN, opacity: 0.0 });
	            var vertexDistance = KhanUtil.getDistance([coordX, coordY], vertex.coord);

	            // Draw a line from the vertex to the highlighted point on the parabola
	            vertexLine = graph.line([coordX, coordY], vertex.coord);
	            // Draw the horizontal line from the highlighted point on the parabola towards the directrix
	            if (directrix.coordA[1] < coordY) {
	                directrixLine = graph.line([coordX, coordY], [coordX, coordY - vertexDistance]);
	                lineEndcap = graph.line([coordX - 0.05, coordY - vertexDistance], [coordX + 0.05, coordY - vertexDistance]);
	            } else {
	                directrixLine = graph.line([coordX, coordY], [coordX, coordY + vertexDistance]);
	                lineEndcap = graph.line([coordX - 0.05, coordY + vertexDistance], [coordX + 0.05, coordY + vertexDistance]);
	            }
	            vertexLine.toBack();
	            directrixLine.toBack();
	            if (!highlighted) {
	                vertexLine.animate({opacity: 1.0}, 100);
	                directrixLine.animate({opacity: 1.0}, 100);
	                lineEndcap.animate({opacity: 1.0}, 100);
	            } else {
	                vertexLine.attr({ opacity: 1.0 });
	                directrixLine.attr({ opacity: 1.0 });
	                lineEndcap.attr({ opacity: 1.0 });
	            }
	            highlighted = true;
	        };

	        // Attach an onLeave handler that gets called whenever the mouse moves away from the parabola
	        func.onLeave = function(coordX, coordY) {
	            vertexLine.animate({opacity: 0.0}, 100);
	            directrixLine.animate({opacity: 0.0}, 100);
	            lineEndcap.animate({ opacity: 0.0 }, 100);
	            highlighted = false;
	        };

	    },

	    doHyperbolaInteraction: function(func, focus1, focus2) {
	        var graph = KhanUtil.currentGraph;
	        var focusLine1 = KhanUtil.bogusShape;
	        var focusLine2 = KhanUtil.bogusShape;
	        var highlighted = false;

	        func.onMove = function(coordX, coordY) {
	            focusLine1.remove();
	            focusLine2.remove();

	            // Draw a line from each focus to the highlighted point on the hyperbola
	            graph.style({ strokeWidth: 1.5, stroke: KhanUtil.GREEN, opacity: 0.0 });
	            focusLine1 = graph.line([coordX, coordY], focus1.coord);
	            graph.style({ stroke: KhanUtil.RED });
	            focusLine2 = graph.line([coordX, coordY], focus2.coord);

	            focusLine1.toBack();
	            focusLine2.toBack();

	            if (!highlighted) {
	                focusLine1.animate({opacity: 1.0}, 100);
	                focusLine2.animate({opacity: 1.0}, 100);
	                $('#problemarea div.focus-instructions').hide();
	                $('#problemarea div.focus-distances').show();
	            } else {
	                focusLine1.attr({ opacity: 1.0 });
	                focusLine2.attr({ opacity: 1.0 });
	            }

	            highlighted = true;
	            this.writeDistances(coordX, coordY);
	        };

	        func.onLeave = function(coordX, coordY) {
	            focusLine1.animate({opacity: 0.0}, 100);
	            focusLine2.animate({opacity: 0.0}, 100);
	            $('#problemarea div.focus-instructions').show();
	            $('#problemarea div.focus-distances').hide();
	            highlighted = false;
	        };
	    },

	    doEllipseInteraction: function(ellipse, focus1, focus2) {
	        var graph = KhanUtil.currentGraph;
	        var focusLine1 = KhanUtil.bogusShape;
	        var focusLine2 = KhanUtil.bogusShape;
	        var highlighted = false;

	        ellipse.onMove = function(coordX, coordY) {
	            focusLine1.remove();
	            focusLine2.remove();

	            // Draw a line from each focus to the highlighted point on the ellipse
	            graph.style({ strokeWidth: 1.5, stroke: KhanUtil.GREEN, opacity: 0.0 });
	            focusLine1 = graph.line([coordX, coordY], focus1.coord);
	            graph.style({ stroke: KhanUtil.RED });
	            focusLine2 = graph.line([coordX, coordY], focus2.coord);

	            focusLine1.toBack();
	            focusLine2.toBack();

	            if (!highlighted) {
	                focusLine1.animate({opacity: 1.0}, 100);
	                focusLine2.animate({opacity: 1.0}, 100);
	                $('#problemarea div.focus-instructions').hide();
	                $('#problemarea div.focus-distances').show();
	            } else {
	                focusLine1.attr({ opacity: 1.0 });
	                focusLine2.attr({ opacity: 1.0 });
	            }

	            highlighted = true;
	            this.writeDistances(coordX, coordY);
	        };

	        ellipse.onLeave = function(coordX, coordY) {
	            focusLine1.animate({opacity: 0.0}, 100);
	            focusLine2.animate({opacity: 0.0}, 100);
	            $('#problemarea div.focus-instructions').show();
	            $('#problemarea div.focus-distances').hide();
	            highlighted = false;
	        };
	    }

	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(10);
	__webpack_require__(27);

	$.extend(KhanUtil, {
	    Polynomial: function(minDegree, maxDegree, coefs, variable, name) {
	        var term = function(coef, vari, degree) {

	            // sort of a weird error behavior
	            if (typeof coef === "undefined" || coef === 0) {
	                return null;
	            }

	            if (degree === 0) {
	                return coef;
	            } else if (degree === 1) {
	                return ["*", coef, vari];
	            } else {
	                return ["*", coef, ["^", vari, degree]];
	            }

	        };

	        // inverse of term.    Given an expression it returns the coef and degree.
	        // calculus needs this for hints
	        var extractFromExpr = function(expr) {
	            var coef, degree;
	            if (typeof expr === "number") {
	                coef = expr;
	                degree = 0;
	            } else if (_.isArray(expr) && !_.isArray(expr[2])) {
	                coef = expr[1];
	                degree = 1;
	            } else if (_.isArray(expr) && _.isArray(expr[2])) {
	                coef = expr[1];
	                degree = expr[2][2];
	            }
	            return {
	                coef: coef,
	                degree: degree
	            };
	        };

	        // These seem royally useless to me
	        if (maxDegree >= minDegree) {
	            this.minDegree = minDegree;
	            this.maxDegree = maxDegree;
	        } else {
	            this.minDegree = maxDegree;
	            this.maxDegree = minDegree;
	        }

	        this.coefs = coefs || KhanUtil.randCoefs(this.minDegree, this.maxDegree);

	        this.variable = (typeof variable !== "undefined") ? variable : "x";

	        this.name = name || "f";

	        this.findMaxDegree = function(coefs) {
	            if (!coefs) {
	                for (var i = this.maxDegree; i >= this.minDegree; i--) {
	                    if (this.coefs[i] !== 0) {
	                        return i;
	                    }
	                }
	            } else {
	                for (var i = coefs.length - 1; i >= 0; i--) {
	                    if (coefs[i] !== 0) {
	                        return i;
	                    }
	                }
	                return -1;
	            }
	        };

	        this.findMinDegree = function(coefs) {
	            if (!coefs) {
	                for (var i = this.minDegree; i <= this.maxDegree; i++) {
	                    if (this.coefs[i] !== 0) {
	                        return i;
	                    }
	                }
	            } else {
	                for (var i = 0; i < coefs.length; i++) {
	                    if (coefs[i] !== 0) {
	                        return i;
	                    }
	                }
	                return -1;
	            }
	        };

	        this.expr = function(vari) {
	            if (typeof vari === "undefined") {
	                vari = this.variable;
	            }

	            var expr = ["+"];

	            for (var i = this.maxDegree; i >= this.minDegree; i--) {
	                var theTerm = term(this.coefs[i], vari, i);

	                if (theTerm != null) {
	                    expr.push(theTerm);
	                }
	            }

	            return expr;
	        };

	        this.getNumberOfTerms = function() {

	            // -1 as the first term in the expression for a polynomial is always a "+"
	            return this.expr().length - 1;

	        };

	        this.getCoefAndDegreeForTerm = function(termIndex) {

	            //returns the coef and degree for a particular term
	            var numberOfTerms = this.getNumberOfTerms();

	            //mod twice to always get positive
	            termIndex = ((termIndex % numberOfTerms) + numberOfTerms) % numberOfTerms;

	            //upshift by one due to "+" sign at the front of the expression
	            return extractFromExpr(this.expr()[termIndex + 1]);

	        };

	        this.text = function() {
	            return KhanUtil.expr(this.expr(this.variable));
	        };


	        // Return a string that the expression editor can understand
	        // Probably a better way to do this than string replacements
	        this.parsableText = function() {
	            var s = this.text();
	            s = s.replace(/{/g, "(").replace(/}/g, ")");
	            return s;
	        };

	        this.toString = this.text;

	        this.hintEvalOf = function(val) {
	            return KhanUtil.expr(this.expr(val));
	        };

	        this.evalOf = function(val) {
	            return KhanUtil.expr(this.expr(val), true);
	        };

	        this.hint = function(val) {
	            var hints = [];
	            hints.push("<p><code>" + this.name + "(" + val + ") = " +
	                this.hintEvalOf(val) + "</code></p>");
	            // We don't need to evalate the expression if it's just a constant
	            if (this.findMaxDegree(this.coefs) > 0) {
	                hints.push("<p><code>" + this.name + "(" + val + ") = " +
	                    this.evalOf(val) + "</code></p>");
	            }

	            return hints;
	        };

	        this.derivative = function() {
	            var ddxCoefs = [];

	            for (var i = this.maxDegree; i >= this.minDegree; i--) {
	                ddxCoefs[i - 1] = i * this.coefs[i];
	            }

	            // if the term's degree is zero, the derivative degree is not
	            // decremented
	            var ddxMinDegree = this.minDegree ? this.minDegree - 1 : 0;
	            var ddxMaxDegree = this.maxDegree ? this.maxDegree - 1 : 0;

	            return new KhanUtil.Polynomial(ddxMinDegree, ddxMaxDegree, ddxCoefs, this.variable);
	        };

	        /**
	         * Add this polynomial to a number or other polynomial.
	         *
	         * Assumes the second polynomial's variable is the same as the first
	         * polynomial's.
	         *
	         * Does not change the polynomials, returns the result.
	         */
	        this.add = function(addend) {
	            var coefs = [];

	            if (typeof addend === "number") {
	                addend = new KhanUtil.Polynomial(0, 0, [addend], this.variable);
	            }

	            // Assume if it's not a number it's a polynomial
	            var minDegree = Math.min(this.minDegree, addend.minDegree);
	            var maxDegree = Math.max(this.maxDegree, addend.maxDegree);
	            for (var i = minDegree; i <= maxDegree; i++) {
	                var value = 0;

	                value += i <= this.maxDegree ? this.coefs[i] : 0;
	                value += i <= addend.maxDegree ? addend.coefs[i] : 0;

	                coefs[i] = value;
	            }

	            return new KhanUtil.Polynomial(minDegree, maxDegree, coefs, this.variable);
	        };

	        /**
	         * Subtracts a number or other polynomial from this polynomial.
	         *
	         * Assumes the second polynomial's variable is the same as the first
	         * polynomial's.
	         *
	         * Does not change the polynomials, returns the result.
	         */
	        this.subtract = function(addend) {
	            if (typeof addend === "number") {
	                return this.add(-addend);
	            } else {
	                return this.add(addend.multiply(-1));
	            }
	        };

	        /**
	         * Multiplies this polynomial by a number or other polynomial.
	         *
	         * Assumes the second polynomial's variable is the same as the first
	         * polynomial's.
	         *
	         * Does not change the polynomials, returns the result.
	         */
	        this.multiply = function(value) {
	            var coefs = [];
	            if (typeof value === "number") {

	                for (var i = 0; i < this.coefs.length; i++) {
	                    coefs[i] = this.coefs[i] * value;
	                }

	                return new KhanUtil.Polynomial(this.minDegree, this.maxDegree, coefs, this.variable);

	            // Assume if it's not a number it's a polynomial
	            } else {
	                for (var i = this.minDegree; i <= this.maxDegree; i++) {
	                    if (this.coefs[i] === 0) {
	                        continue;
	                    }
	                    for (var j = value.minDegree; j <= value.maxDegree; j++) {
	                        if (value.coefs[j] === 0) {
	                            continue;
	                        }

	                        var coef = this.coefs[i] * value.coefs[j];

	                        if (coefs[i + j] === undefined) {
	                            coefs[i + j] = coef;
	                        } else {
	                            coefs[i + j] += coef;
	                        }
	                    }
	                }

	                // Fill in any missing values of coefs with 0s
	                for (var i = 0; i < coefs.length; i++) {
	                    if (coefs[i] === undefined) {
	                        coefs[i] = 0;
	                    }
	                }

	                return new KhanUtil.Polynomial(Math.min(this.minDegree, value.minDegree), coefs.length - 1, coefs, this.variable);
	            }
	        };

	        // Scale or shift a polynomial
	        // Example: f(x) = Ax^2 + Bx + C ==>
	        //          f(mx + b) = A(mx + b)^2 + B(mx + b) + C
	        this.scale = function(m, b) {

	            // v = mx + b
	            var v = new KhanUtil.Polynomial(0, 1, [b, m]);

	            var n = this.getNumberOfTerms();

	            // nothing to scale of the polynomial is y = 0
	            if (n === 0) {
	                return this;
	            }

	            // expand each substituted term of the polynomial
	            var self = this;
	            var termPolys = _.map(_.range(0, n), function(i) {
	                var term = self.getCoefAndDegreeForTerm(i);

	                // start with the coefficient in front of the term
	                var termPoly = new KhanUtil.Polynomial(0, 0, [term.coef]);

	                // expand the substituted term
	                // ex: A(mx + b)^3 = A(mx + b)(mx + b)(mx + b)
	                _.times(term.degree, function(j) {
	                    termPoly = termPoly.multiply(v);
	                });
	                return termPoly;
	            });

	            // add all of the substituted terms
	            var scaledPoly = _.reduce(termPolys, function(memo, curr) {
	                return memo.add(curr);
	            });

	            return scaledPoly;
	        };

	        return this;
	    },

	    CompositePolynomial: function(minDegree, maxDegree, coefs, variable, name,
	            composed, composedCoef) {
	        var base = new KhanUtil.Polynomial(
	            minDegree, maxDegree, coefs, variable, name);

	        $.extend(this, base);

	        if (!composedCoef) {
	            composedCoef = KhanUtil.randRangeNonZero(-5, 5);
	        }
	        var composedFunc = composed.name + "(" + this.variable + ")";

	        var tackOn = function(expr, tack) {
	            expr = $.merge([], expr);

	            if (expr[0] === "+") {
	                expr.push(tack);
	            } else {
	                expr = ["+", expr, tack];
	            }

	            return expr;
	        };

	        this.expr = function(vari) {
	            return tackOn(base.expr(vari), ["*", composedCoef, composedFunc]);
	        };

	        this.text = function() {
	            return KhanUtil.expr(this.expr(this.variable));
	        };

	        this.toString = this.text;

	        this.hintEvalOf = function(val, evalInner) {
	            if (evalInner) {

	                return KhanUtil.expr(tackOn(base.expr(val),
	                    ["*", composedCoef, composed.evalOf(val)]));

	            } else {

	                return KhanUtil.expr(tackOn(base.expr(val),
	                    ["*", composedCoef, composed.name + "(" + val + ")"]));

	            }
	        };

	        this.evalOf = function(val) {
	            return base.evalOf(val) + composedCoef * composed.evalOf(val);
	        };

	        this.hint = function(val) {
	            var hints = [];
	            hints.push("<p><code>" + this.name + "(" + val + ") = " +
	                this.hintEvalOf(val) + "</code></p>");

	            var composedFuncWithVal = composed.name + "(" + val + ")";

	            hints.push(
	                $._("<p>To solve for the value of <code>%(name)s</code>, we " +
	                "need to solve for the value of " +
	                "<code>%(composedFuncWithVal)s</code>.</p>",
	                {name: this.name, composedFuncWithVal: composedFuncWithVal}));

	            hints = hints.concat(composed.hint(val));

	            hints.push($._("<p>That means <code>%(name)s(%(val)s) = " +
	                "%(hintEvalOf)s</code></p>",
	                {name: this.name, val: val,
	                    hintEvalOf: this.hintEvalOf(val, true)}));

	            hints.push("<p><code>" + this.name + "(" + val + ") = " +
	                this.evalOf(val) + "</code></p>");

	            return hints;

	        };

	        return this;

	    },

	    randCoefs: function randCoefs(minDegree, maxDegree) {
	        var coefs = [];
	        var allZero = true;

	        for (var i = maxDegree; i >= minDegree; i--) {
	            coefs[i] = KhanUtil.randRange(-7, 7);
	            allZero = allZero && coefs[i] === 0;
	        }

	        return allZero ? randCoefs(minDegree, maxDegree) : coefs;
	    },

	    findRootsNumerically: function(fn, range, step) {
	        step = step || 0.05;
	        var x = range[0];
	        var positive = fn(x) > 0;
	        var roots = [];
	        while (x < range[1]) {
	            x += step;
	            if ((fn(x) > 0) !== positive) {
	                roots.push(KhanUtil.roundToNearest(step, x - step));
	                positive = !positive;
	            }
	        }
	        return roots;
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {
	    /* coinFlips(2) returns
	     * [["HH", 2], ["HT", 1], ["TH", 1], ["TT", 0]] */
	    coinFlips: function(n) {
	        if (n === 0) {
	            return [["", 0]];
	        } else {
	            var preceding = KhanUtil.coinFlips(n - 1);

	            var andAHead = $.map(preceding, function(_arg, i) {
	                var seq = _arg[0];
	                var h = _arg[1];
	                // I18N: Represents "heads" on a coin
	                return [[$._("H") + seq, h + 1]];
	            });

	            var andATail = $.map(preceding, function(_arg, i) {
	                var seq = _arg[0];
	                var h = _arg[1];
	                // I18N: Represents "tails" on a coin
	                return [[$._("T") + seq, h]];
	            });

	            return andAHead.concat(andATail);
	        }
	    },

	    /* returns binomial coefficient (n choose k) or
	     * sum of choose(n, i) for i in k:
	     * choose(4, [0, 1, 2]) = 1 + 4 + 6 = 11 */
	    choose: function(n, k) {
	        if (typeof k === "number") {
	            if (k * 2 > n) {
	                return KhanUtil.choose(n, n - k);
	            } else if (k > 0.5) {
	                return KhanUtil.choose(n, k - 1) * (n - k + 1) / (k);
	            } else if (Math.abs(k) <= 0.5) {
	                return 1;
	            } else {
	                return 0;
	            }
	        } else {
	            var sum = 0;
	            $.each(k, function(ind, elem) {
	                sum += KhanUtil.choose(n, elem);
	            });
	            return sum;
	        }
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.fn["qhintsLoad"] = function() {

	    var checkAnswer = function(parent, source) {
	        var feedback = parent.find(".qhint-feedback");

	        // if answer already revealed in the feedback, don't do anything
	        if (feedback.length) {
	            return;
	        }

	        // make a new feedback element
	        feedback = $("<p>", { "class": "qhint-feedback" });
	        var answer = $(parent.find(".qhint-answer")).text();
	        var input = parent.find(".qhint-input");
	        var userInput = "";

	        if (source) {
	            var type = source.attr("type");
	            if (type === "text" || type === "submit") {
	                userInput = $(parent.find("input:text")).val();
	            } else if (type === "button") {
	                userInput = source.val();
	            } else if (source.is("a")) {
	                userInput = source.text();
	            }
	        }

	        // hide input element and instead show the feedback element
	        input.hide();

	        if (!source) {
	            feedback.text(answer);
	        } else if (userInput === answer) {
	            feedback.text($._("Correct! The answer is %(answer)s.",
	                {answer: answer})).addClass("correct");
	        } else {
	            feedback.text($._("Incorrect. The answer is %(answer)s.",
	                {answer: answer})).addClass("incorrect");
	        }

	        parent.append(feedback);
	    };

	    var handleCheck = function(e) {
	        var parent = $(e.currentTarget).parents(".qhint");
	        checkAnswer(parent, $(e.currentTarget));
	    };

	    var selectors =
	        ".qhint input:submit, .qhint input:button, .qhint a.qhint-button";
	    $("body").on("click", selectors, handleCheck);

	    // check hint when user presses enter
	    $("body").on("keydown", ".qhint input:text", function(e) {
	        // enter is pressed
	        if (e.keyCode === 13) {
	            handleCheck(e);
	        }
	    });

	    $(Khan).on("hintUsed", function() {
	        var lastQhElem = $(".qhint").last();
	        if (lastQhElem.length) {
	            checkAnswer(lastQhElem, null);
	        }
	    });
	};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {

	    getPermutations: function(arr) {
	        var permArr = [];
	        var usedChars = [];

	        function permute(input) {
	            for (var i = 0; i < input.length; i++) {
	                var term = input.splice(i, 1)[0];
	                usedChars.push(term);
	                if (input.length === 0) {
	                    permArr.push(usedChars.slice());
	                }
	                permute(input);
	                input.splice(i, 0, term);
	                usedChars.pop();
	            }
	            return permArr;
	        }

	        return permute(arr);
	    },

	    writeExpressionFraction: function(numerator, denominator) {
	        if (denominator.toString() === '1') {
	            return numerator.toString();
	        }
	        if (denominator.toString() === '-1') {
	            return numerator.multiply(-1).toString();
	        }
	        if (numerator.isNegative()) {
	            return "-\\dfrac{" + numerator.multiply(-1).toString() + "}{" + denominator.toString() + "}";
	        }
	        if (denominator.isNegative()) {
	            return "-\\dfrac{" + numerator.toString() + "}{" + denominator.multiply(-1).toString() + "}";
	        }
	        return "\\dfrac{" + numerator.toString() + "}{" + denominator.toString() + "}";
	    },

	    /*
	    Term in an expression
	    Takes an array. The first value is the coefficient
	    and subsequent values are variables and their degree
	    e.g. Term(5) = 5
	         Term(5, 'x') = 5x
	         Term(5, 'xy') = 5xy
	         Term(5, {'x': 1}) = 5x
	         Term(5, {'x': 2}) = 5x^2
	         Term(5, {'x': 1, 'y': 2}) = 5xy^2
	    */
	    Term: function(coefficient, variables, degree) {
	        this.coefficient = coefficient;
	        this.variables = {};

	        if (degree === undefined) {
	            degree = 1;
	        }

	        if (typeof variables === 'string') {
	            for (var i = 0; i < variables.length; i++) {
	                this.variables[variables.charAt(i)] = degree;
	            }
	        } else if (variables !== undefined){
	            this.variables = variables;
	        }

	        // Create a string representing the term
	        // e.g. 5yx^2 = 5y1x2
	        // Used for hashing
	        this.variableString = '';
	        for (var vari in this.variables) {
	            if (this.variables[vari] !== 0) {
	                this.variableString += vari + this.variables[vari];
	            } else {
	                delete this.variables[vari];
	            }
	        }

	        this.isNegative = function() {
	            return this.coefficient < 0;
	        };

	        // Return a RationalExpression object representing the sum of this term with the passed object
	        this.add = function(expression) {
	            // Copy self so don't mutate original term
	            var copy = [this.coefficient, this.variables];

	            if (expression instanceof KhanUtil.RationalExpression) {
	                return expression.add(this);
	            } else if (expression instanceof KhanUtil.Term) {
	                return new KhanUtil.RationalExpression([copy, [expression.coefficient, expression.variables]]);
	            } else {
	                return new KhanUtil.RationalExpression([copy, expression]);
	            }
	        };


	        this.isOne = function() {
	            return this.toString() === '1';
	        };

	        // Given a mapping of variable to value, {'x' : 2}, evaulate the term
	        // Or give a number and all variables will be given that value
	        // TODO: Make this work for multi-variable terms
	        // when only the value of one variable is given
	        this.evaluate = function(values) {
	            var value = this.coefficient;

	            if (typeof values === 'number') {
	                _.each(this.variables, function(v) {
	                    value *= Math.pow(values, v);
	                });
	            } else {
	                _.each(this.variables, function(v, i) {
	                    value *= Math.pow(values[i], v);
	                });
	            }
	            return value;
	        };

	        // Return a new term representing this term multiplied by another term or a number
	        this.multiply = function(term) {
	            if (term instanceof KhanUtil.RationalExpression) {
	                return term.multiply(this);
	            }

	            var coefficient = this.coefficient;
	            var variables = _.clone(this.variables);

	            if (typeof term === 'number') {
	                coefficient *= term;
	            } else {
	                coefficient *= term.coefficient;
	                for (var i in term.variables) {
	                    if (variables[i] != null) {
	                        variables[i] += term.variables[i];
	                    } else {
	                        variables[i] = term.variables[i];
	                    }
	                }
	            }

	            return new KhanUtil.Term(coefficient, variables);
	        };

	        // Return a new term representing this term divided by another term or a number
	        this.divide = function(term) {
	            var coefficient = this.coefficient;
	            var variables = _.clone(this.variables);

	            if (typeof term === 'number') {
	                coefficient /= term;
	            } else {
	                coefficient /= term.coefficient;
	                for (var i in term.variables) {
	                    if (variables[i]) {
	                        variables[i] -= term.variables[i];
	                    } else {
	                        variables[i] = -term.variables[i];
	                    }
	                }
	            }

	            return new KhanUtil.Term(coefficient, variables);
	        };

	        // Return a Term object representing the greatest common factor between this term and another
	        this.getGCD = function(expression) {
	            if (expression instanceof KhanUtil.RationalExpression) {
	                return expression.getGCD(this);
	            }

	            if (typeof expression === 'number') {
	                return KhanUtil.getGCD(this.coefficient, expression);
	            }

	            var coefficient = KhanUtil.getGCD(this.coefficient, expression.coefficient);
	            var variables = {};

	            for (var i in this.variables) {
	                if (expression.variables[i]) {
	                    variables[i] = Math.min(this.variables[i], expression.variables[i]);
	                }
	            }

	            return new KhanUtil.Term(coefficient, variables);
	        };

	        // includeSign if term is not the first in an expression
	        this.toString = function(includeSign) {
	            if (this.coefficient === 0) {
	                return '';
	            }

	            var s = '';

	            if (includeSign) {
	                s += this.coefficient >= 0 ? ' + ' : ' - ';
	            } else if (this.coefficient < 0) {
	                s += '-';
	            }

	            var coefficient = Math.abs(this.coefficient);
	            if (!(coefficient === 1 && this.variableString !== "")) {
	                s += coefficient;
	            }

	            _.each(this.variables, function(degree, i) {
	                if (degree === 0) {
	                    return; // continue
	                }
	                s += i;
	                if (degree !== 1) {
	                    s += '^' + degree;
	                }
	            });
	            return s;
	        };

	        // Just so Terms can be treated like RationalExpressions
	        this.toStringFactored = function() {
	            return this.toString();
	        };

	        // Return a string showing how the term should be evaluated with a given value
	        // e.g. 5x^2 evalated with 3 returns 5(3)^2
	        // If color is defined, the value representing the variable is colored
	        this.getEvaluateString = function(values, includeSign, color) {
	            var s = '';

	            if (includeSign) {
	                s += this.coefficient >= 0 ? ' + ' : ' - ';
	            } else if (this.coefficient < 0) {
	                s += '-';
	            }

	            var coefficient = Math.abs(this.coefficient);
	            if (!(coefficient === 1 && this.variableString !== '')) {
	                s += coefficient;
	                if (this.variableString !== '') {
	                    s += '\\cdot';
	                }
	            }

	            _.each(this.variables, function(degree, i) {
	                var value = (typeof values === 'number') ? values : values[i];
	                if (color !== undefined) {
	                    value = '\\' + color + '{' + value + '}';
	                }

	                s += (value < 0 || degree === 1) ? value : '(' + value + ')^' + degree;
	            });

	            return s;
	        };

	        // Return a regex that will capture this term
	        // If includeSign is true, then 4x is captured by +4x
	        this.regex = function() {
	            return '^' + this.regexForExpression() + '$';
	        };

	        // Return a regex that will capture this term
	        // If includeSign is true, then 4x is captured by +4x
	        this.regexForExpression = function(includeSign) {
	            if (this.coefficient === 0) {
	                return '';
	            }

	            var regex;

	            // Include leading space if there are earlier terms
	            if (this.coefficient < 0){
	                regex = includeSign ? '[-\\u2212]\\s*' : '\\s*[-\\u2212]\\s*';
	            } else {
	                regex = includeSign ? '\\+\\s*' : '\\s*';
	            }

	            if (!(Math.abs(this.coefficient) === 1 && this.variableString !== '')) {
	                regex += Math.abs(this.coefficient);
	            }

	            // Add all permutations of variables
	            var variable_array = [];
	            for (var vari in this.variables) {
	                if (degree !== 0) {
	                    variable_array.push([vari, this.variables[vari]]);
	                }
	            }

	            if (variable_array.length > 1) {
	                var permutations = KhanUtil.getPermutations(variable_array);

	                regex += "(?:";
	                for (var p=0; p<permutations.length; p++) {
	                    var variables = permutations[p];

	                    regex += "(?:";
	                    for (var i=0; i<variables.length; i++) {
	                        var vari = variables[i][0];
	                        var degree = variables[i][1];
	                        regex += degree > 1 ? vari + "\\s*\\^\\s*" + degree : vari;
	                    }
	                    regex += p < permutations.length - 1 ? ")|" : ")";
	                }
	                regex += ")";

	            } else if (variable_array.length === 1) {
	                var vari = variable_array[0][0];
	                var degree = variable_array[0][1];
	                regex += degree > 1 ? vari + "\\s*\\^\\s*" + degree : vari;
	            }

	            return regex + '\\s*';
	        };

	    },

	    /*
	        A flat (i.e. no parentheses), multi-variable polynomial expression
	        Represented as an array of terms that are added together
	        Terms can be numbers or an array representing [coefficient, variable]
	        e.g. [5, [1, 'x']] = 5 + x
	        e.g. [5, [2, {'x': 2}] = 5 + 2x^2
	        e.g. [5, [2, {'x': 2, 'y': 1}]] = 5 + 2x^2y
	    */
	    RationalExpression: function(terms) {
	        this.terms = [];

	        for (var i = 0; i < terms.length; i++) {
	            var term = terms[i];
	            var newTerm;
	            if (typeof term === 'number') {
	                newTerm = new KhanUtil.Term(term);
	            } else if (term instanceof KhanUtil.Term) {
	                newTerm = new KhanUtil.Term(term.coefficient, term.variables);
	            } else {
	                newTerm = new KhanUtil.Term(term[0], term[1]);
	            }
	            if (newTerm.coefficient !== 0) {
	                this.terms.push(newTerm);
	            }
	        }

	        // Given a term, e.g. x1, return the coefficient of that term
	        this.getCoefficient = function(variable) {
	            var coefficient = 0;
	            for (var i = 0; i < this.terms.length; i++) {
	                if (this.terms[i].variableString === variable) {
	                    coefficient += this.terms[i].coefficient;
	                }
	            }
	            return coefficient;
	        };

	        // Combine any terms that have the same variable and remove any with a coefficient of 0
	        this.combineLikeTerms = function() {
	            var variables = {};

	            for (var i = 0; i < this.terms.length; i++) {
	                var term = this.terms[i];
	                var s = term.variableString;

	                if (variables[s]) {
	                    variables[s].coefficient += term.coefficient;
	                } else {
	                    variables[s] = term;
	                }
	            }

	            this.terms = [];
	            for (var v in variables) {
	                if (variables[v].coefficient !== 0) {
	                    this.terms.push(variables[v]);
	                }
	            }
	        };
	        this.combineLikeTerms();

	        // Test whether this expressions is equal to the one passed in
	        // Assumes the like terms in both expressions have been combined
	        this.isEqualTo = function(that) {
	            var n1 = this.terms.length;
	            var n2 = that.terms.length;

	            if (n1 !== n2) {
	                return false;
	            }

	            for (var i=0; i<n1; i++) {
	                var t1 = this.terms[i];
	                var found = false;

	                for (var j=0; j<n2; j++) {
	                    var t2 = that.terms[j];
	                    if (t1.coefficient === t2.coefficient && t1.variableString === t2.variableString) {
	                        found = true;
	                        break;
	                    }
	                }
	                if (!found) {
	                    return false;
	                }
	            }

	            return true;
	        };

	        this.isNegative = function() {
	            return this.terms[0].coefficient < 0;
	        };

	        // Return the coefficient of term contain variable to the degree power
	        // e.g. for 5x^2 + x + 2, getCoefficentOfTerm('x', 2) will return 5
	        // getCoefficentOfTerm('x',) will return 1
	        // getCoefficentOfTerm() will return 2
	        this.getCoefficentOfTerm = function(variable, degree) {
	            var variableString = "";

	            if (variable === '') {
	                variableString = '';
	            } else if (variable !== undefined && degree !== 0) {
	                degree = degree || 1;
	                variableString = variable + degree;
	            }

	            for (var i = 0; i < this.terms.length; i++) {
	                if (this.terms[i].variableString === variableString) {
	                    return this.terms[i].coefficient;
	                }
	            }

	            return 0;
	        };

	        this.evaluate = function(values) {
	            var value = 0;
	            for (var i = 0; i < this.terms.length; i++) {
	                value += this.terms[i].evaluate(values);
	            }
	            return value;
	        };

	        // Return a new expression which is the sum of this one and the one passed in
	        this.add = function(expression) {
	            var terms = [];

	            // Copy own terms
	            for (var i = 0; i < this.terms.length; i++) {
	                var term = this.terms[i];
	                terms.push([term.coefficient, term.variables]);
	            }

	            if (expression instanceof KhanUtil.Term) {
	                // Add single term
	                terms.push(new KhanUtil.Term(expression.coefficient, expression.variables));
	            } else if (typeof expression === 'number') {
	                // Add single digit
	                terms.push(new KhanUtil.Term(expression));
	            } else {
	                // Add all terms from another expression
	                for (var i = 0; i < expression.terms.length; i++) {
	                    var term = expression.terms[i];
	                    terms.push([term.coefficient, term.variables]);
	                }
	            }

	            var result = new KhanUtil.RationalExpression(terms);
	            result.combineLikeTerms();

	            return result;
	        };

	        // Return a new expression representing the product of this one and the one passed in
	        this.multiply = function(expression) {
	            var multiplyTerms;
	            if (expression instanceof KhanUtil.RationalExpression) {
	                multiplyTerms = expression.terms;
	            } else if (typeof expression === 'number' || expression instanceof KhanUtil.Term) {
	                multiplyTerms = [expression];
	            } else {
	                // Assume it's a variable name
	                multiplyTerms = [new KhanUtil.Term(1, expression)];
	            }

	            var terms = [];

	            for (var i = 0; i < multiplyTerms.length; i++) {
	                var value = multiplyTerms[i];

	                for (var j = 0; j < this.terms.length; j++) {
	                    terms.push(this.terms[j].multiply(value));
	                }
	            }

	            return new KhanUtil.RationalExpression(terms);
	        };

	        // Return a new expression representing this one divided by another expression
	        // Assumes this expression can be factored to remove the one passed in
	        this.divide = function(expression) {
	            if (expression instanceof KhanUtil.RationalExpression) {
	                if (expression.terms.length === 1) {
	                    return this.divide(expression.terms[0]);
	                }

	                var factors1 = this.factor();
	                var factors2 = expression.factor();

	                if (factors1[1].isEqualTo(factors2[1])) {
	                    var value = factors1[0].divide(factors2[0]);
	                    return new KhanUtil.RationalExpression([value]);
	                } else if (factors1[1].isEqualTo(factors2[1].multiply(-1))) {
	                    var value = factors1[0].divide(factors2[0]).multiply(-1);
	                    return new KhanUtil.RationalExpression([value]);
	                } else {
	                    // Cannot divide by this expression
	                    // Can be used to check whether expression have a common factor
	                    return false;
	                }

	            } else {
	                var terms = [];

	                for (var i = 0; i < this.terms.length; i++) {
	                    terms.push(this.terms[i].divide(expression));
	                }

	                return new KhanUtil.RationalExpression(terms);
	            }
	        };

	        // Return a Term object representing the greatest common factor between this expression and another
	        this.getGCD = function(that) {
	            var t1 = this.getTermsGCD();
	            var GCD;

	            if (that instanceof KhanUtil.Term) {
	                GCD = t1.getGCD(that);
	            } else if (that instanceof KhanUtil.RationalExpression) {
	                GCD = t1.getGCD(that.getTermsGCD());
	            } else {
	                return KhanUtil.getGCD(that, t1.coefficient);
	            }

	            if (GCD.coefficient < 0) {
	                GCD.coefficient *= -1;
	            }
	            return GCD;
	        };

	        // Return a Term object representing the greatest common divisor of all the terms in this expression
	        this.getTermsGCD = function() {
	            var GCD = this.terms[0];

	            for (var i=0; i<this.terms.length; i++) {
	                GCD = GCD.getGCD(this.terms[i]);
	            }

	            if (this.isNegative()) {
	                GCD = GCD.multiply(-1);
	            }

	            return GCD;
	        };

	        // Factor out the GCD of all terms and return [GCD, remaining expression]
	        // e.g. 6x + 4x^2 => [2x, 3 + 2x]
	        this.factor = function() {
	            var gcd = this.getTermsGCD();
	            var factor = this.divide(gcd);
	            return [gcd, factor];
	        };

	        this.toString = function() {
	            if (this.terms.length === 0) {
	                return '0';
	            }

	            var s = this.terms[0].toString();
	            for (var i = 1; i < this.terms.length; i++) {
	                s += this.terms[i].toString(s !== '');
	            }

	            return s !== '' ? s : '0';
	        };

	        // Return a string of the factored expression
	        this.toStringFactored = function(parenthesise) {
	            var factors = this.factor();

	            if (this.terms.length === 1 || factors[0].isOne()) {
	                if (parenthesise) {
	                   return "(" + this.toString() + ")";
	                } else {
	                    return this.toString();
	                }
	            }

	            var s = (factors[0].toString() === '-1') ? '-' : factors[0].toString();
	            s += "(" + factors[1].toString() + ")";

	            return s;
	        };

	        // Returns a string showing the expression with variable substituted.
	        this.getEvaluateString = function(values, color) {
	            var s = this.terms[0].getEvaluateString(values, false, color);

	            for (var i = 1; i < this.terms.length; i++) {
	                s += this.terms[i].getEvaluateString(values, true, color);
	            }

	            return s !== "" ? s : '0';
	        };

	        // Returns a regex that captures all permutation passed in
	        this.getTermsRegex = function(permutations, start, stop) {
	            var regex = "";

	            start = start ?  "|(?:^" + start : "|(?:^";
	            stop = stop ?  stop + "$)" : "$)";

	            for (var p = 0; p < permutations.length; p++) {
	                regex += start;

	                var terms = permutations[p];
	                for (var i = 0; i < terms.length; i++) {
	                    regex += terms[i].regexForExpression(i);
	                }

	                regex += stop;
	            }
	            return regex;
	        };

	        // Returns a single regex to capture this expression.
	        // It will capture every permutations of terms so is
	        // not recommended for expressions with more than 3 terms
	        // If allowFactors is true, 3(x + 4) will match 3x + 12
	        this.regex = function(allowFactors) {
	            var permutations = KhanUtil.getPermutations(this.terms);
	            var regex = this.getTermsRegex(permutations).slice(1);

	            if (!allowFactors || this.terms.length === 1) {
	                return regex;
	            }

	            // Generate regex factored expression
	            // If GCD is 1, will accept parenthesised expression
	            // e.g. p - 5 will accept (p - 5)
	            var factors = this.factor();
	            permutations = KhanUtil.getPermutations(factors[1].terms);

	            if (factors[0].isOne()) {
	                regex += this.getTermsRegex(permutations, "\\s*\\(", "\\)\\s*");
	            } else if (factors[0].toString() === '-1') {
	                regex += this.getTermsRegex(permutations, "\\s*[-\\u2212]\\s*\\(", "\\)\\s*");
	            } else {
	                regex += this.getTermsRegex(permutations, factors[0].regexForExpression() + "\\*?\\s*\\(", "\\)\\s*");
	            }

	            // Factor out a negative
	            factors[0] = factors[0].multiply(-1);
	            factors[1] = factors[1].multiply(-1);
	            permutations = KhanUtil.getPermutations(factors[1].terms);

	            if (factors[0].isOne()) {
	                regex += this.getTermsRegex(permutations, "\\s*\\(", "\\)\\s*");
	            } else if (factors[0].toString === '-1') {
	                regex += this.getTermsRegex(permutations, "\\s*[-\\u2212]\\s*\\(", "\\)\\s*");
	            } else {
	                regex += this.getTermsRegex(permutations, factors[0].regexForExpression() + "\\*?\\s*\\(", "\\)\\s*");
	            }

	            return regex;
	        };
	    }

	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(16);

	window.DrawingScratchpad = function(elem) {
	    var pen = "M25.31,2.872l-3.384-2.127c-0.854-0.536-1.979-0.278-2.517,0.576l-1.334,2.123l6.474,4.066l1.335-2.122C26.42,4.533,26.164,3.407,25.31,2.872zM6.555,21.786l6.474,4.066L23.581,9.054l-6.477-4.067L6.555,21.786zM5.566,26.952l-0.143,3.819l3.379-1.787l3.14-1.658l-6.246-3.925L5.566,26.952z";
	    var erase = "M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248";
	    var undo = "M12.981,9.073V6.817l-12.106,6.99l12.106,6.99v-2.422c3.285-0.002,9.052,0.28,9.052,2.269c0,2.78-6.023,4.263-6.023,4.263v2.132c0,0,13.53,0.463,13.53-9.823C29.54,9.134,17.952,8.831,12.981,9.073z";

	    var rainbow = "0-#00ff00-#ff0000:50-#0000ff";

	    var nextRainbowStroke = (function() {
	        var freq = 0.05;
	        var iter = 0;
	        return function() {
	            var red   = Math.sin(freq * iter + -3) * 127 + 128;
	            var green = Math.sin(freq * iter + -1) * 127 + 128;
	            var blue  = Math.sin(freq * iter + 1) * 127 + 128;
	            iter++;
	            return "rgb(" + red + "," + green + "," + blue + ")";
	        };
	    })();

	    if (!elem) {
	        throw new Error("No element provided to DrawingScratchpad");
	    }

	    var container = $(elem);

	    var pad = Raphael(container[0], container.width(), container.height());

	    this.resize = function() {
	        pad.setSize(container.width(), container.height());
	    };

	    var palette = pad.set(), stroke = rainbow, colors = [rainbow, "#000000", "#3f3f3f", "#7f7f7f", "#bfbfbf", "#ff0000", "#ff7f00", "#ffff00", "#00ff00", "#00ffff", "#007fff", "#0000ff", "#7f00ff"];
	    for (var i = 0; i < colors.length; i++) {
	        (function(color) {
	            var setcolor = function(e) {
	                stroke = color;
	                palette.animate({y: 7}, 100);
	                this.animate({y: 15}, 100);
	                penclick();
	            };
	            palette.push(pad.rect(90 + i * 27, 7, 24, 24).attr({
	                fill: color,
	                stroke: "#ccc"
	                }).touchstart(setcolor).click(setcolor));
	        })(colors[i]);
	    }
	    palette[0].attr({y: 15});

	    var selected = pad.rect(2, 2, 30, 30).attr({
	        r: 5,
	        stroke: "",
	        fill: "rgba(30, 157, 186, 0.5)"
	    });

	    var line_default = {
	        "stroke-width": 2,
	        "stroke-linecap": "round",
	        "stroke-linejoin": "round"};

	    var shapes = pad.set();
	    var undoHistory = [[]];

	    function saveState() {
	        for (var i = 0, state = []; i < shapes.length; i++) {
	            if (!shapes[i].removed) {
	                if (shapes[i].type === "path") {
	                    state.push({
	                        path: shapes[i].attr("path").toString(),
	                        stroke: shapes[i].attr("stroke"),
	                        type: "path"
	                    });
	                }
	            }
	        }
	        undoHistory.push(state);
	    }

	    function loadState(state) {
	        shapes.remove();
	        for (var i = 0; i < state.length; i++) {
	            if (state[i].type === "path") {
	                shapes.push(pad.path(state[i].path).attr(line_default).attr({
	                    stroke: state[i].stroke,
	                    "clip-rect": [0, 40, pad.width, pad.height - 40]
	                }));
	            }
	        }
	    }

	    /*
	    * Hi. I did this with VectorEdtor, so I guess I'll try to do the same here with scratchpad
	    * If someone is there, reading this code, in the distant future, say, the year 2012 and you
	    * are, as any sensible human would, be preparing for the mayan-predicted impending apocalypse,
	    * (or not) it doesn't matter. You should totally email me at antimatter15@gmail.com because,
	    * it's always an interesting feeling.
	    */

	    var tools = pad.set();

	    tools.push(pad.path(pen).scale(0.8).translate(0, 0));
	    tools.push(pad.path(erase).translate(30, 0));
	    tools.push(pad.path(undo).scale(0.7).translate(60, 1));

	    var tool = "draw";
	    function penclick() {
	        selected.animate({x: 2}, 100);
	        tool = "draw";
	    }
	    pad.rect(2, 2, 30, 30)
	        .attr({
	            stroke: "",
	            fill: "black",
	            "fill-opacity": 0
	        })
	        .click(penclick).touchstart(penclick);
	    function eraseclick() {
	        selected.animate({x: 2 + 30}, 100);
	        tool = "erase";
	    }
	    pad.rect(2 + 30, 2, 30, 30)
	        .attr({
	            stroke: "",
	            fill: "black",
	            "fill-opacity": 0
	        })
	        .click(eraseclick).touchstart(eraseclick);
	    function undoclick() {
	        if (undoHistory.length) {
	            loadState(undoHistory.pop());
	        }
	    }
	    pad.rect(2 + 30 * 2, 2, 30, 30)
	        .attr({
	            stroke: "",
	            fill: "black",
	            "fill-opacity": 0
	        })
	        .click(undoclick).touchstart(undoclick);

	    tools.attr({fill: "#000", stroke: "none"});
	    var path = null, pathstr = "", prevPen;
	    var eraser = null;

	    function mousedown(X, Y, e) {
	        if (!X || !Y || !e) {
	            return;
	        }
	        if (Y <= 40) {
	            return;
	        }

	        if (eraser) {
	            eraser.remove();
	            eraser = null;
	        }

	        if (tool === "draw") {
	            saveState();
	            startPen(X, Y);
	        } else if (tool === "erase") {
	            eraser = pad.rect(X, Y, 0, 0).attr({
	                "fill-opacity": 0.15,
	                "stroke-opacity": 0.5,
	                "fill": "#ff0000",  // oh noes! its red and gonna asplodes!
	                "stroke": "#ff0000"
	            });
	            eraser.sx = X;
	            eraser.sy = Y;
	        }
	    }

	    function startPen(x, y) {
	        var singleColorStroke = (stroke === rainbow) ?
	            nextRainbowStroke() :
	            stroke;
	        path = pad.path("M" + x + "," + y).attr(line_default).attr({
	            stroke: singleColorStroke,
	            "clip-rect": [0, 40, pad.width, pad.height - 40]
	        });
	        pathstr = path.attr("path");
	        shapes.push(path);
	        prevPen = {x: x, y: y};
	    }

	    function rectsIntersect(r1, r2) {
	        return r2.x < (r1.x + r1.width) &&
	            (r2.x + r2.width) > r1.x &&
	            r2.y < (r1.y + r1.height) &&
	            (r2.y + r2.height) > r1.y;
	    }


	    function mouseup(x, y) {
	        if (tool === "draw" && path) {
	            pathstr += "L" + x + "," + y;
	            prevPen = null;
	            path.attr("path", pathstr);
	        }
	        path = null;
	        if (tool === "erase" && eraser) {
	            saveState();
	            var actuallyErased = false;
	            var ebox = eraser.getBBox();
	            for (var i = 0; i < shapes.length; i++) {
	                if (rectsIntersect(ebox, shapes[i].getBBox())) {
	                    actuallyErased = true;
	                    shapes[i].remove();
	                }
	            }
	            if (!actuallyErased) {
	                undoHistory.pop();
	            }
	            var e = eraser;
	            eraser = null;
	            e.animate({opacity: 0}, 100, function() {
	                e.remove();
	            });
	        }

	    }

	    function mousemove(X, Y) {
	        if (tool === "draw" && path) {
	            pathstr += "Q" + prevPen.x + "," + prevPen.y + "," +
	                (prevPen.x + X) / 2 + "," + (prevPen.y + Y) / 2;
	            prevPen = {x: X, y: Y};
	            path.attr("path", pathstr);
	        } else if (tool === "erase" && eraser) {
	            var x1 = Math.min(X, eraser.sx),
	                x2 = Math.max(X, eraser.sx),
	                y1 = Math.max(40, Math.min(Y, eraser.sy)),
	                y2 = Math.max(40, Math.max(Y, eraser.sy));
	            eraser.attr({
	                x: x1,
	                y: y1,
	                width: x2 - x1,
	                height: y2 - y1
	            });
	        }
	    }

	    var handleMousemove = function(e) {
	        var offset = $(container).offset();
	        mousemove(e.pageX - offset.left, e.pageY - offset.top);
	        e.preventDefault();
	    };
	    $(container).on("vmousedown", function(e) {
	        var offset = $(container).offset();
	        mousedown(e.pageX - offset.left, e.pageY - offset.top, e);
	        e.preventDefault();

	        $(document).on("vmousemove", handleMousemove);
	        $(document).one("vmouseup", function(e) {
	            mouseup(e.pageX - offset.left, e.pageY - offset.top, e);
	            e.preventDefault();
	            $(document).off("vmousemove", handleMousemove);
	        });
	    });

	    this.clear = function() {
	        shapes.remove();
	        undoHistory = [[]];
	    };
	};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	// Helper for fractions_cut_and_copy_1 and fractions_cut_and_copy_2
	$.extend(KhanUtil, {
	    initSliceClone: function(goalBlocks) {
	        KhanUtil.pieces = 1;
	        KhanUtil.times = {};
	        for (var i = 0; i < goalBlocks.length; i++) {
	            KhanUtil.times[goalBlocks[i]] = 1;
	        }
	    },

	    // Change the number of pieces the starting block
	    // is sliced into.
	    changePieces: function(increase) {
	        if (KhanUtil.pieces === 1 && !increase) {
	            return;
	        }

	        KhanUtil.pieces += (increase) ? 1 : -1;

	        $("#pieces").text(KhanUtil.plural(KhanUtil.pieces, "piece"));

	        KhanUtil.currentGraph = $("#problemarea").find("#parent_block").data("graphie");
	        rectchart([1, KhanUtil.pieces - 1], ["#e00", "#999"]);

	        KhanUtil.updateGraphAndAnswer();
	    },

	    // Change the number of times the slice is copied.
	    changeTimes: function(increase, id) {
	        if (KhanUtil.times[id] === 1 && !increase) {
	            return;
	        }

	        KhanUtil.times[id] += (increase) ? 1 : -1;

	        $("#" + id + "_times").text(KhanUtil.plural(KhanUtil.times[id], "time"));

	        KhanUtil.updateGraphAndAnswer();
	    },

	    updateGraphAndAnswer: function() {
	        var pieces = KhanUtil.pieces;
	        _.each(KhanUtil.times, function(times, id) {
	            KhanUtil.currentGraph = $("#problemarea").find("#" + id).data("graphie");
	            KhanUtil.currentGraph.raphael.clear();
	            KhanUtil.currentGraph.init({ range: [[0, 1], [0, 1]], scale: [500 / pieces * times, 25] });
	            rectchart([times, 0], ["#e00", "#999"]);
	            $("#" + id + "_answer input").val(KhanUtil.roundTo(3, times / pieces));
	        });
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {
	    spin: function(content) {
	        // First find all top-level blocks and spin them
	        var startingBracePos = -1;
	        var nestingLevel = 0;

	        for (var i = 0; i < content.length; i++) {
	            if (content.charAt(i) === "{") {

	                // We encounter our first "{"
	                if (startingBracePos === -1) {
	                    startingBracePos = i;

	                // We are already inside a top-level block, this starts a nested block
	                } else {
	                    nestingLevel++;
	                }

	            // We encounter a "}" and have seen a "{" before
	            } else if (content.charAt(i) === "}" && startingBracePos !== -1) {

	                // This is the closing brace for a top-level block
	                if (nestingLevel === 0) {
	                    // Spin the top-level block
	                    var spun = KhanUtil.spin(content.substring(startingBracePos + 1, i));
	                    content = content.substring(0, startingBracePos) + spun + content.substring(i + 1);
	                    i -= (i - startingBracePos) - spun.length + 1;
	                    startingBracePos = -1;

	                // This brace closes a nested block
	                } else {
	                    nestingLevel--;
	                }
	            }
	        }

	        return KhanUtil.randFromArray(content.split("|"));
	    }
	});


	$.fn.spin = function() {
	    this.find(".spin").each(function() {
	        var spun = KhanUtil.spin($(this).html());
	        $(this).html(spun);
	    });
	};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(10);

	$.extend(KhanUtil, {
	    sum: function(values) {
	        var sum = 0;

	        $.each(values, function(index, value) {
	            sum += value;
	        });
	        return sum;
	    },

	    mean: function(values) {
	        return KhanUtil.sum(values) / values.length;
	    },

	    median: function(values) {
	        var sortedInts, median;
	        sortedInts = KhanUtil.sortNumbers(values);

	        if (values.length % 2 === 0) {
	            median = KhanUtil.roundTo(1,
	                (sortedInts[(values.length / 2) - 1] + sortedInts[values.length / 2]) / 2);
	        } else {
	            median = sortedInts[Math.floor(values.length / 2)];
	        }
	        return median;
	    },

	    mode: function(values) {
	        var numInstances = [];
	        var modeInstances = -1;

	        var mode;
	        for (var i = 0; i < values.length; i++) {
	            if (!numInstances[values[i]]) {
	                numInstances[values[i]] = 1;
	            } else {
	                numInstances[values[i]] += 1;
	                if (numInstances[values[i]] > modeInstances) {
	                    modeInstances = numInstances[values[i]];
	                    mode = values[i];
	                }
	            }
	        }

	        // iterate again to check for 'no mode'
	        for (var i = 0; i < numInstances.length; i++) {
	            if (numInstances[i]) {
	                if (i !== mode && numInstances[i] >= modeInstances) {
	                    return false;
	                }
	            }
	        }

	        return mode;
	    },

	    variance: function(values) {
	        var xbar = KhanUtil.mean(values);
	        var n = values.length;

	        var sum = 0;
	        $.each(values, function(i, x_i) {
	            sum += (x_i - xbar) * (x_i - xbar);
	        });
	        return sum / (n - 1);
	    },

	    variancePop: function(values) {
	        var xbar = KhanUtil.mean(values);
	        var N = values.length;

	        var sum = 0;
	        $.each(values, function(i, x_i) {
	            sum += (x_i - xbar) * (x_i - xbar);
	        });
	        return sum / N;
	    },

	    stdDev: function(values) {
	        return Math.sqrt(KhanUtil.variance(values));
	    },

	    stdDevPop: function(values) {
	        return Math.sqrt(KhanUtil.variancePop(values));
	    },

	    // Gaussian distribution using Box-Muller transform
	    // defaults to standard normal unless target mean and stddev are passed
	    // Pass "count" to get an array of data
	    randGaussian: function(tgtMean, tgtStdDev, count) {
	        if (count == null) {
	            var x1, x2, rad;

	            do {
	                x1 = 2 * KhanUtil.random() - 1;
	                x2 = 2 * KhanUtil.random() - 1;
	                rad = x1 * x1 + x2 * x2;
	            } while (rad >= 1 || rad === 0);

	            var c = Math.sqrt(-2 * Math.log(rad) / rad);

	            return x1 * c * (tgtStdDev || 1) + (tgtMean || 0);
	        } else {
	            return $.map(new Array(count), function() {
	                return KhanUtil.randGaussian(tgtMean, tgtStdDev);
	            });
	        }
	    },

	    gaussianPDF: function(mean, stddev, x) {
	        return (1 / Math.sqrt(2 * Math.PI * stddev * stddev)) * Math.exp(-((x - mean) * (x - mean)) / (2 * stddev * stddev));
	    },

	    zScores: function(z) {
	        return ({
	            "0": 0.5, "1": 0.504, "2": 0.508, "3": 0.512, "4": 0.516,
	            "5": 0.5199, "6": 0.5239, "7": 0.5279, "8": 0.5319, "9": 0.5359,
	            "10": 0.5398, "11": 0.5438, "12": 0.5478, "13": 0.5517, "14": 0.5557,
	            "15": 0.5596, "16": 0.5636, "17": 0.5675, "18": 0.5714, "19": 0.5753,
	            "20": 0.5793, "21": 0.5832, "22": 0.5871, "23": 0.591, "24": 0.5948,
	            "25": 0.5987, "26": 0.6026, "27": 0.6064, "28": 0.6103, "29": 0.6141,
	            "30": 0.6179, "31": 0.6217, "32": 0.6255, "33": 0.6293, "34": 0.6331,
	            "35": 0.6368, "36": 0.6406, "37": 0.6443, "38": 0.648, "39": 0.6517,
	            "40": 0.6554, "41": 0.6591, "42": 0.6628, "43": 0.6664, "44": 0.67,
	            "45": 0.6736, "46": 0.6772, "47": 0.6808, "48": 0.6844, "49": 0.6879,
	            "50": 0.6915, "51": 0.695, "52": 0.6985, "53": 0.7019, "54": 0.7054,
	            "55": 0.7088, "56": 0.7123, "57": 0.7157, "58": 0.719, "59": 0.7224,
	            "60": 0.7257, "61": 0.7291, "62": 0.7324, "63": 0.7357, "64": 0.7389,
	            "65": 0.7422, "66": 0.7454, "67": 0.7486, "68": 0.7517, "69": 0.7549,
	            "70": 0.758, "71": 0.7611, "72": 0.7642, "73": 0.7673, "74": 0.7704,
	            "75": 0.7734, "76": 0.7764, "77": 0.7794, "78": 0.7823, "79": 0.7852,
	            "80": 0.7881, "81": 0.791, "82": 0.7939, "83": 0.7967, "84": 0.7995,
	            "85": 0.8023, "86": 0.8051, "87": 0.8078, "88": 0.8106, "89": 0.8133,
	            "90": 0.8159, "91": 0.8186, "92": 0.8212, "93": 0.8238, "94": 0.8264,
	            "95": 0.8289, "96": 0.8315, "97": 0.834, "98": 0.8365, "99": 0.8389,
	            "100": 0.8413, "101": 0.8438, "102": 0.8461, "103": 0.8485, "104": 0.8508,
	            "105": 0.8531, "106": 0.8554, "107": 0.8577, "108": 0.8599, "109": 0.8621,
	            "110": 0.8643, "111": 0.8665, "112": 0.8686, "113": 0.8708, "114": 0.8729,
	            "115": 0.8749, "116": 0.877, "117": 0.879, "118": 0.881, "119": 0.883,
	            "120": 0.8849, "121": 0.8869, "122": 0.8888, "123": 0.8907, "124": 0.8925,
	            "125": 0.8944, "126": 0.8962, "127": 0.898, "128": 0.8997, "129": 0.9015,
	            "130": 0.9032, "131": 0.9049, "132": 0.9066, "133": 0.9082, "134": 0.9099,
	            "135": 0.9115, "136": 0.9131, "137": 0.9147, "138": 0.9162, "139": 0.9177,
	            "140": 0.9192, "141": 0.9207, "142": 0.9222, "143": 0.9236, "144": 0.9251,
	            "145": 0.9265, "146": 0.9279, "147": 0.9292, "148": 0.9306, "149": 0.9319,
	            "150": 0.9332, "151": 0.9345, "152": 0.9357, "153": 0.937, "154": 0.9382,
	            "155": 0.9394, "156": 0.9406, "157": 0.9418, "158": 0.9429, "159": 0.9441,
	            "160": 0.9452, "161": 0.9463, "162": 0.9474, "163": 0.9484, "164": 0.9495,
	            "165": 0.9505, "166": 0.9515, "167": 0.9525, "168": 0.9535, "169": 0.9545,
	            "170": 0.9554, "171": 0.9564, "172": 0.9573, "173": 0.9582, "174": 0.9591,
	            "175": 0.9599, "176": 0.9608, "177": 0.9616, "178": 0.9625, "179": 0.9633,
	            "180": 0.9641, "181": 0.9649, "182": 0.9656, "183": 0.9664, "184": 0.9671,
	            "185": 0.9678, "186": 0.9686, "187": 0.9693, "188": 0.9699, "189": 0.9706,
	            "190": 0.9713, "191": 0.9719, "192": 0.9726, "193": 0.9732, "194": 0.9738,
	            "195": 0.9744, "196": 0.975, "197": 0.9756, "198": 0.9761, "199": 0.9767,
	            "200": 0.9772, "201": 0.9778, "202": 0.9783, "203": 0.9788, "204": 0.9793,
	            "205": 0.9798, "206": 0.9803, "207": 0.9808, "208": 0.9812, "209": 0.9817,
	            "210": 0.9821, "211": 0.9826, "212": 0.983, "213": 0.9834, "214": 0.9838,
	            "215": 0.9842, "216": 0.9846, "217": 0.985, "218": 0.9854, "219": 0.9857,
	            "220": 0.9861, "221": 0.9864, "222": 0.9868, "223": 0.9871, "224": 0.9875,
	            "225": 0.9878, "226": 0.9881, "227": 0.9884, "228": 0.9887, "229": 0.989,
	            "230": 0.9893, "231": 0.9896, "232": 0.9898, "233": 0.9901, "234": 0.9904,
	            "235": 0.9906, "236": 0.9909, "237": 0.9911, "238": 0.9913, "239": 0.9916,
	            "240": 0.9918, "241": 0.992, "242": 0.9922, "243": 0.9925, "244": 0.9927,
	            "245": 0.9929, "246": 0.9931, "247": 0.9932, "248": 0.9934, "249": 0.9936,
	            "250": 0.9938, "251": 0.994, "252": 0.9941, "253": 0.9943, "254": 0.9945,
	            "255": 0.9946, "256": 0.9948, "257": 0.9949, "258": 0.9951, "259": 0.9952,
	            "260": 0.9953, "261": 0.9955, "262": 0.9956, "263": 0.9957, "264": 0.9959,
	            "265": 0.996, "266": 0.9961, "267": 0.9962, "268": 0.9963, "269": 0.9964,
	            "270": 0.9965, "271": 0.9966, "272": 0.9967, "273": 0.9968, "274": 0.9969,
	            "275": 0.997, "276": 0.9971, "277": 0.9972, "278": 0.9973, "279": 0.9974,
	            "280": 0.9974, "281": 0.9975, "282": 0.9976, "283": 0.9977, "284": 0.9977,
	            "285": 0.9978, "286": 0.9979, "287": 0.9979, "288": 0.998, "289": 0.9981,
	            "290": 0.9981, "291": 0.9982, "292": 0.9982, "293": 0.9983, "294": 0.9984,
	            "295": 0.9984, "296": 0.9985, "297": 0.9985, "298": 0.9986, "299": 0.9986,
	            "300": 0.9987, "301": 0.9987, "302": 0.9987, "303": 0.9988, "304": 0.9988,
	            "305": 0.9989, "306": 0.9989, "307": 0.9989, "308": 0.999, "309": 0.999
	        }[z]);
	    }

	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	var getSubHints = function(id, title, subHints) {
	    var str = "[<a href='#' class='show-subhint' data-subhint='" + id + "'>" + title + "</a>]</p>";
	    str += "<div class='subhint' id='" + id + "'>";
	    for (var iHint = 0; iHint < subHints.length; iHint++) {
	        str += "<p>" + subHints[iHint] + "</p>";
	    }
	    str += "</div>";
	    return str;
	};

	$(document).on("click", "a.show-subhint", function(event) {
	    var subhint = $("#" + $(this).data("subhint"));
	    var visibleText = $(this).data("visible-text") || $(this).text();
	    var hiddenText = $(this).data("hidden-text") || "Hide explanation";
	    $(this).data({ "visible-text": visibleText, "hidden-text": hiddenText });

	    if (subhint.is(":visible")) {
	        $(this).text(visibleText);
	    } else {
	        // write to KALOG capturing the subhint-expand
	        // click
	        $(Exercises).trigger("subhintExpand", [$(this).data("subhint")]);
	        $(this).text(hiddenText);
	    }

	    var $el = $("#" + $(this).data("subhint"));
	    $el.toggle(200, function() {
	        // TODO(alpert): This flashes when the subhint is revealed.
	        // Flashing is better than the alternative, though:
	        // https://uploads.hipchat.com/6574/33523/6qxvb1j5sh88vjv/upload.png
	        $el.find("code").each(function(i, code) {
	            KhanUtil.processMath(code, null, true);
	        });
	    });

	    return false;
	});

	$(document).on("mouseenter mouseleave", "a.show-definition", function(event) {
	    $("#" + $(this).data("definition")).toggle(200);
	    return false;
	});

	$.extend(KhanUtil, {
	    getSubHints: getSubHints
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {
	    addAnalogClock: function(options) {
	        var analogClock = $.extend(true, {
	            graph: KhanUtil.currentGraph,
	            set: KhanUtil.currentGraph.raphael.set(),
	            hands: KhanUtil.currentGraph.raphael.set(),
	            center: [0, 0],
	            radius: 3.5,
	            showLabels: true,
	            hour: null,
	            minute: null
	        }, options);

	        analogClock.drawLabels = function() {
	            var self = this;
	            _(12).times(function(n) {
	                n += 1;
	                var coord = self.graph.scalePoint([
	                        self.center[0] + 0.78 * self.radius * Math.sin(2 * Math.PI * n / 12),
	                        self.center[1] + 0.78 * self.radius * Math.cos(2 * Math.PI * n / 12)]);
	                // Use raphael text rather than mathjax labels so the hands can
	                // be drawn on top. Also, the sans-serif font better fits the
	                // stylish look of this sleek, modern clock.
	                var lbl = self.graph.raphael.text(coord[0], coord[1], n);
	                lbl.attr({
	                    color: KhanUtil.GRAY,
	                    fill: KhanUtil.GRAY,
	                    "font-size": 14
	                });
	                self.set.push(lbl);
	            });
	            self.hands.toFront();
	        };

	        analogClock.drawHands = function() {
	            var self = this;
	            self.graph.style({
	                fill: "#333",
	                stroke: "none"
	            }, function() {
	                var hourHand = self.graph.path([
	                        [self.center[0] - 0.15 * self.radius, self.center[1] + 0.035 * self.radius],
	                        [self.center[0] + 0.45 * self.radius, self.center[1] + 0.020 * self.radius],
	                        [self.center[0] + 0.45 * self.radius, self.center[1] - 0.020 * self.radius],
	                        [self.center[0] - 0.15 * self.radius, self.center[1] - 0.035 * self.radius],
	                        true]);
	                hourHand.rotate(-KhanUtil.timeToDegrees((self.hour + self.minute/60) * 5),
	                        self.graph.scalePoint(self.center)[0], self.graph.scalePoint(self.center)[1]);
	                self.hands.push(hourHand);

	                var minuteHand = self.graph.path([
	                        [self.center[0] - 0.15 * self.radius, self.center[0] + 0.035 * self.radius],
	                        [self.center[0] + 0.85 * self.radius, self.center[0] + 0.017 * self.radius],
	                        [self.center[0] + 0.85 * self.radius, self.center[0] - 0.017 * self.radius],
	                        [self.center[0] - 0.15 * self.radius, self.center[0] - 0.035 * self.radius],
	                        true]);
	                minuteHand.rotate(-KhanUtil.timeToDegrees(self.minute),
	                        self.graph.scalePoint(self.center)[0], self.graph.scalePoint(self.center)[1]);
	                self.hands.push(minuteHand);
	            });
	            self.set.push(self.hands);
	        };

	        analogClock.draw = function() {
	            var self = this;
	            self.graph.style({
	                stroke: KhanUtil.GRAY,
	                fill: "#fff",
	                strokeWidth: 5
	            }, function() {
	                self.set.push(self.graph.circle(self.center, self.radius));
	            });
	            self.graph.style({
	                stroke: KhanUtil.GRAY,
	                strokeWidth: 4
	            }, function() {
	                _(12).times(function(n) {
	                    var tick = self.graph.line(
	                            [self.center[0] + self.radius - 4 / self.graph.scale[0], self.center[1]],
	                            [self.center[0] + self.radius - 8 / self.graph.scale[0], self.center[1]]);
	                    tick.rotate(n * 30, self.graph.scalePoint(self.center)[0], self.graph.scalePoint(self.center)[1]);
	                    self.set.push(tick);
	                });
	            });
	            self.graph.style({
	                stroke: KhanUtil.GRAY,
	                strokeWidth: 1
	            }, function() {
	                _(60).times(function(n) {
	                    var tick = self.graph.line(
	                            [self.center[0] + self.radius - 4 / self.graph.scale[0], self.center[1]],
	                            [self.center[0] + self.radius - 8 / self.graph.scale[0], self.center[1]]);
	                    tick.rotate(n * 6, self.graph.scalePoint(self.center)[0], self.graph.scalePoint(self.center)[1]);
	                    self.set.push(tick);
	                });
	            });
	            if (self.showLabels) {
	                self.drawLabels();
	            }
	            if (self.hour != null && self.minute != null) {
	                self.drawHands();
	            }
	            return self.set;
	        };

	        return analogClock;
	    },

	    addInteractiveAnalogClock: function(options) {
	        options = $.extend(true, {
	            minuteSnapPoints: 12,
	            minuteIncrement: 5,
	            minuteStartAngle: 90,
	            hourStartAngle: 60
	        }, options);

	        var interactiveAnalogClock = KhanUtil.addAnalogClock(options);
	        var graph = interactiveAnalogClock.graph;

	        var hourSnapPoints = 12 * 60 / interactiveAnalogClock.minuteIncrement;
	        var outerPointRadius = interactiveAnalogClock.radius * 1.10;
	        interactiveAnalogClock.minuteRadius = interactiveAnalogClock.radius * 0.65;
	        interactiveAnalogClock.hourRadius = interactiveAnalogClock.radius * 0.45;

	        var minuteSnapDegrees = 360 / interactiveAnalogClock.minuteSnapPoints;
	        var hourSnapDegrees = 360 / hourSnapPoints;

	        interactiveAnalogClock.draw();
	        graph.addMouseLayer();

	        var redStyle = { fill: KhanUtil.RED, stroke: KhanUtil.RED };
	        var blueStyle = { fill: KhanUtil.BLUE, stroke: KhanUtil.BLUE };

	        var movePartnerPoint = function (options) {
	            var x = options.x;
	            var y = options.y;
	            var point = options.point;
	            var outerPoint = options.outerPoint;
	            var isOuterPoint = options.isOuterPoint;

	            var ratio = outerPoint.constraints.fixedDistance.dist / point.constraints.fixedDistance.dist;

	            if (isOuterPoint) {
	                ratio = 1 / ratio;
	                point.setCoord([x * ratio , y * ratio]);
	                outerPoint.setCoord([x, y]);
	            } else {
	                point.setCoord([x, y]);
	                outerPoint.setCoord([x * ratio, y * ratio]);
	            }

	            point.updateLineEnds();
	            return true;
	        };

	        interactiveAnalogClock.minutePoint = graph.addMovablePoint({
	            graph: graph,
	            coord: graph.polar(interactiveAnalogClock.minuteRadius, interactiveAnalogClock.minuteStartAngle),
	            constraints: {
	                fixedDistance: {
	                    dist: interactiveAnalogClock.minuteRadius,
	                    point: [0, 0],
	                    snapPoints: 12
	                }
	            },
	            onMove: function(x, y) {
	                return movePartnerPoint({
	                    x: x,
	                    y: y,
	                    point: this,
	                    outerPoint: interactiveAnalogClock.outerMinutePoint,
	                    isOuterPoint: false
	                });
	            },
	            normalStyle: redStyle,
	            highlightStyle: redStyle
	        });

	        interactiveAnalogClock.outerMinutePoint = graph.addMovablePoint({
	            graph: graph,
	            coord: graph.polar(outerPointRadius, interactiveAnalogClock.minuteStartAngle),
	            constraints: {
	                fixedDistance: {
	                    dist: outerPointRadius,
	                    point: [0, 0],
	                    snapPoints: 12
	                }
	            },
	            onMove: function(x, y) {
	                return movePartnerPoint({
	                    x: x,
	                    y: y,
	                    point: interactiveAnalogClock.minutePoint,
	                    outerPoint: this,
	                    isOuterPoint: true
	                });
	            },
	            normalStyle: redStyle,
	            highlightStyle: redStyle
	        });

	        interactiveAnalogClock.hourPoint = graph.addMovablePoint({
	            graph: graph,
	            coord: graph.polar(interactiveAnalogClock.hourRadius, interactiveAnalogClock.hourStartAngle),
	            constraints: {
	                fixedDistance: {
	                    dist: interactiveAnalogClock.hourRadius,
	                    point: [0, 0],
	                    snapPoints: hourSnapPoints
	                }
	            },
	            onMove: function(x, y) {
	                return movePartnerPoint({
	                    x: x,
	                    y: y,
	                    point: this,
	                    outerPoint: interactiveAnalogClock.outerHourPoint,
	                    isOuterPoint: false
	                });
	            },
	            normalStyle: blueStyle,
	            highlightStyle: blueStyle
	        });

	        interactiveAnalogClock.outerHourPoint = graph.addMovablePoint({
	            graph: graph,
	            coord: graph.polar(outerPointRadius, interactiveAnalogClock.hourStartAngle),
	            constraints: {
	                fixedDistance: {
	                    dist: outerPointRadius,
	                    point: [0, 0],
	                    snapPoints: hourSnapPoints
	                }
	            },
	            onMove: function(x, y) {
	                return movePartnerPoint({
	                    x: x,
	                    y: y,
	                    point: interactiveAnalogClock.hourPoint,
	                    outerPoint: this,
	                    isOuterPoint: true
	                });
	            },
	            normalStyle: blueStyle,
	            highlightStyle: blueStyle
	        });

	        interactiveAnalogClock.minuteHand = graph.addMovableLineSegment({
	            graph: graph,
	            pointA: interactiveAnalogClock.minutePoint,
	            coordZ: [0, 0],
	            fixed: true,
	            normalStyle: {
	                stroke: KhanUtil.RED,
	                "stroke-width": 10
	            }
	        });

	        interactiveAnalogClock.hourHand = graph.addMovableLineSegment({
	            graph: graph,
	            pointA: interactiveAnalogClock.hourPoint,
	            coordZ: [0, 0],
	            fixed: true,
	            normalStyle: {
	                stroke: KhanUtil.BLUE,
	                "stroke-width": 10
	            }
	        });

	        var centerPoint = graph.addMovablePoint({
	            graph: graph,
	            coord: [0, 0],
	            constraints: {
	                fixed: true
	            },
	            normalStyle: {
	                fill: "#fff",
	                stroke: "#000",
	                "stroke-width": 2
	            }
	        });

	        // Return the position of the minute and hour hands
	        interactiveAnalogClock.getHandPositions = function() {
	            return [interactiveAnalogClock.minutePoint.coord, interactiveAnalogClock.hourPoint.coord];
	        };

	        // Test whether the clock is set to correctMinute and correctHour
	        interactiveAnalogClock.validate = function(guess, correctMinute, correctHour) {
	            var minuteAngle = graph.cartToPolar(guess[0])[1];
	            var hourAngle = graph.cartToPolar(guess[1])[1];

	            minuteAngle = KhanUtil.roundToNearest(minuteSnapDegrees, minuteAngle);
	            hourAngle = KhanUtil.roundToNearest(hourSnapDegrees, hourAngle);

	            // If hands have not been moved, return `""`
	            if (minuteAngle === interactiveAnalogClock.minuteStartAngle && hourAngle === interactiveAnalogClock.hourStartAngle) {
	                return "";
	            }

	            var correctMinuteAngle = KhanUtil.timeToDegrees(correctMinute);
	            var correctHourAngle = KhanUtil.timeToDegrees(5 * (correctHour + correctMinute / 60));
	            correctMinuteAngle = KhanUtil.roundToNearest(minuteSnapDegrees, correctMinuteAngle);
	            correctHourAngle = KhanUtil.roundToNearest(hourSnapDegrees, correctHourAngle);

	            if ((minuteAngle !== correctMinuteAngle) || (hourAngle !== correctHourAngle)) {
	                if ((minuteAngle === correctHourAngle) && (hourAngle === correctMinuteAngle)) {
	                    return $._("Remember the hour hand is the short hand and the minute hand is the long hand");
	                }
	                else if ((minuteAngle === correctMinuteAngle) && (hourAngle !== correctHourAngle) &&
	                         (hourAngle === KhanUtil.roundToNearest(hourSnapDegrees, KhanUtil.timeToDegrees(5 * correctHour)))) {
	                    return $._("Remember the hour hand needs to move over the course of the hour");
	                }
	                return false;
	            }
	            return true;
	        };

	        // Show semi-transparent hands set at the correct time
	        interactiveAnalogClock.showCorrectTime = function(correctMinute, correctHour) {
	            var correctMinuteAngle = KhanUtil.timeToDegrees(correctMinute);
	            var correctHourAngle = KhanUtil.timeToDegrees(5 * (correctHour + correctMinute / 60));
	            correctMinuteAngle = KhanUtil.roundToNearest(minuteSnapDegrees, correctMinuteAngle);
	            correctHourAngle = KhanUtil.roundToNearest(hourSnapDegrees, correctHourAngle);

	            var minuteCoord = graph.polar(interactiveAnalogClock.minuteRadius, correctMinuteAngle);
	            var hourCoord = graph.polar(interactiveAnalogClock.hourRadius, correctHourAngle);

	            var dotOpacity = 0.4;
	            var handOpacity = 0.3;

	            interactiveAnalogClock.graph.addMovableLineSegment({
	                coordA: minuteCoord,
	                coordZ: [0, 0],
	                fixed: true,
	                normalStyle: {
	                    stroke: KhanUtil.RED,
	                    "stroke-width": 10,
	                    "stroke-dasharray": ".",
	                    "stroke-linecap": "round",
	                    "stroke-opacity": dotOpacity
	                }
	            });

	            interactiveAnalogClock.graph.addMovableLineSegment({
	                coordA: minuteCoord,
	                coordZ: [0, 0],
	                fixed: true,
	                normalStyle: {
	                    stroke: KhanUtil.RED,
	                    "stroke-width": 10,
	                    "stroke-linecap": "round",
	                    "stroke-opacity": handOpacity
	                }
	            });

	            interactiveAnalogClock.graph.addMovableLineSegment({
	                coordA: hourCoord,
	                coordZ: [0, 0],
	                fixed: true,
	                normalStyle: {
	                    stroke: KhanUtil.BLUE,
	                    "stroke-width": 10,
	                    "stroke-dasharray": ".",
	                    "stroke-linecap": "round",
	                    "stroke-opacity": dotOpacity
	                }
	            });

	            interactiveAnalogClock.graph.addMovableLineSegment({
	                coordA: hourCoord,
	                coordZ: [0, 0],
	                fixed: true,
	                normalStyle: {
	                    stroke: KhanUtil.BLUE,
	                    "stroke-width": 10,
	                    "stroke-linecap": "round",
	                    "stroke-opacity": handOpacity
	                }
	            });

	            // for some reason this doesn't work, so for now, create another center point
	            // centerPoint.toFront();
	            interactiveAnalogClock.graph.addMovablePoint({
	                coord: [0, 0],
	                constraints: {
	                    fixed: true
	                },
	                normalStyle: {
	                    fill: "#fff",
	                    stroke: "#000",
	                    "stroke-dasharray": "",
	                    "stroke-width": 2,
	                    "stroke-opacity": 1
	                }
	            });
	        };

	        return interactiveAnalogClock;
	    },

	    /* Map time in minutes to angle in degrees
	     * - Minutes start at positive y-axis and increase clockwise
	     * - Angle starts at positive x-axis and increases counterclockwise
	     * - (e.g., 0 minutes => 90 degrees; 15 minutes => 0 degrees;
	     *   30 minutes => 270 degrees; 45 minutes => 180 degrees)
	     * - Will return angle in radians if `angleInRadians` is specified as
	     *   truthy.
	     */
	    timeToDegrees: function(minutes, angleInRadians) {
	        // p is the proportion of total time
	        var p = minutes / 60;
	        var angleProportion;

	        if (p <= 0.25) {
	            angleProportion = (0.25 - p);
	        } else {
	            angleProportion = (1.25 - p);
	        }

	        if (angleInRadians) {
	            return 2 * Math.PI * angleProportion;
	        }
	        return 360 * angleProportion;
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {

	    initCongruence: function(options) {
	        options = $.extend({
	            ticks: [],
	            numArcs: [0, 0, 0],
	            reflected: false
	        }, options);

	        options.sides = options.triangle.sideLengths.slice();
	        options.angles = options.triangle.angles.slice();

	        var randomAngle = function(current) {
	            var angle = current;
	            while (Math.abs(angle - current) < 10) {
	                angle = Math.floor(KhanUtil.random() * 70) + 10;
	            }
	            return angle;
	        };

	        var randomSide = function(current) {
	            var side = current;
	            while (Math.abs(side - current) < 1) {
	                side = KhanUtil.random() * 30 / 10 + 1;
	            }
	            return side;
	        };


	        var triangle;
	        //
	        // Side-Side-Side
	        //
	        if (options.type === "SSS") {
	            options.angles[0] = randomAngle(options.angles[0]);
	            options.angles[1] = randomAngle(options.angles[1]);
	            options.angles[2] = randomAngle(options.angles[2]);
	            options.ticks = [1, 2, 3];
	            triangle = KhanUtil.addInteractiveTriangle(options);

	            // Point 0 is a fixed distance from point 1
	            triangle.points[0].constraints.fixedDistance = { dist: options.sides[0], point: triangle.points[1] };

	            // Point 1 can be used to rotate the shape
	            triangle.setRotationPoint(1);

	            // Point 2 can be used to rotate the shape
	            triangle.setRotationPoint(2);

	            // Point 3 is a fixed distance from point 2
	            triangle.points[3].constraints.fixedDistance = { dist: options.sides[2], point: triangle.points[2] };

	            // When point 0 moves, check if it's close enough to point 3 to make a triangle
	            triangle.points[0].onMove = function(coordX, coordY) {
	                triangle.points[0].coord = [coordX, coordY];
	                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.3) {
	                    triangle.snapCorrect();
	                }
	                triangle.update();
	                return triangle.points[0].coord;
	            };

	            // When point 3 moves, check if it's close enough to point 0 to make a triangle
	            triangle.points[3].onMove = function(coordX, coordY) {
	                triangle.points[3].coord = [coordX, coordY];
	                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.3) {
	                    triangle.snapCorrect();
	                }
	                triangle.update();
	                return triangle.points[3].coord;
	            };

	            triangle.snapCorrect = function() {
	                // Check to see if SSS was 'reflected' by being turned inside out
	                if (Math.abs(((options.triangle.angles[1] * (triangle.reflected ? -1 : 1) + 360) % 360) - ((KhanUtil.findAngle(this.points[0].coord, this.points[2].coord, this.points[1].coord) + 360) % 360)) > 90) {
	                    triangle.reflected = !triangle.reflected;
	                }
	                this.points[0].setCoord(this.points[0].applyConstraint(this.points[0].coord, {
	                    fixedAngle: {
	                        angle: options.triangle.angles[1] * (triangle.reflected ? -1 : 1),
	                        vertex: this.points[1],
	                        ref: this.points[2]
	                    }
	                }));
	                this.points[3].setCoord(this.points[3].applyConstraint(this.points[3].coord, {
	                    fixedAngle: {
	                        angle: options.triangle.angles[2] * (triangle.reflected ? 1 : -1),
	                        vertex: this.points[2],
	                        ref: this.points[1]
	                    }
	                }));
	            };


	        //
	        // Side-Side-Angle
	        //
	        } else if (options.type === "SSA") {
	            options.angles[0] = randomAngle(options.angles[0]);
	            options.angles[1] = randomAngle(options.angles[1]);
	            options.sides[2] = randomSide(options.sides[2]);
	            options.ticks = [1, 2, 0];
	            options.numArcs = [0, 1, 0];
	            triangle = KhanUtil.addInteractiveTriangle(options);

	            // Point 0 is a fixed distance from point 1
	            triangle.points[0].constraints.fixedDistance = { dist: options.sides[0], point: triangle.points[1] };

	            // Point 1 can be used to rotate the shape
	            triangle.setRotationPoint(1);

	            // Point 2 is a fixed distance from point 1
	            triangle.points[2].constraints.fixedDistance = { dist: options.sides[1], point: triangle.points[1] };

	            // Point 3 is a fixed angle from points 1 and 2
	            triangle.points[3].constraints.fixedAngle = { angle: options.angles[2] * (triangle.reflected ? 1 : -1), vertex: triangle.points[2], ref: triangle.points[1] };

	            // When point 0 moves, check if it's close enough to point 3 to make a triangle
	            triangle.points[0].onMove = function(coordX, coordY) {
	                triangle.points[0].coord = [coordX, coordY];
	                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.2) {
	                    triangle.snapCorrect();
	                }
	                triangle.update();
	                return triangle.points[0].coord;
	            };

	            // When point 2 moves, point 3 moves along with it
	            triangle.points[2].onMove = function(coordX, coordY) {
	                var origCoord = triangle.points[2].coord;
	                triangle.points[2].coord = [coordX, coordY];
	                triangle.points[3].setCoord(triangle.points[3].applyConstraint(triangle.points[3].coord, {
	                    fixedDistance: {
	                        dist: KhanUtil.getDistance(triangle.points[3].coord, origCoord),
	                        point: triangle.points[2]
	                    }
	                }));
	                // Check if point 3 ends up close enough to point 0 to make a triangle
	                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.2) {
	                    triangle.snapCorrect();
	                }
	                triangle.update();
	            };

	            // When point 3 moves, check if it's close enough to point 0 to make a triangle
	            triangle.points[3].onMove = function(coordX, coordY) {
	                triangle.points[3].coord = [coordX, coordY];
	                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.2) {
	                    triangle.snapCorrect();
	                }
	                triangle.update();
	                return triangle.points[3].coord;
	            };

	            triangle.snapCorrect = function() {
	                var angle1 = options.triangle.angles[1] * (triangle.reflected ? -1 : 1);
	                // SSA has two possible shapes: See which one we're closest to'
	                if (Math.abs(KhanUtil.getDistance(triangle.points[2].coord, triangle.points[3].coord) - options.triangle.sideLengths[2]) > 1.0) {
	                    this.isCongruent = false;
	                    angle1 = Math.abs(angle1);
	                    var angle2 = Math.abs(options.triangle.angles[2] * (triangle.reflected ? -1 : 1));
	                    angle1 = (180 - 2 * angle2 - angle1) * (triangle.reflected ? -1 : 1);
	                } else {
	                    this.isCongruent = true;
	                }
	                this.points[0].setCoord(this.points[0].applyConstraint(this.points[0].coord, {
	                    fixedAngle: {
	                        angle: angle1,
	                        vertex: this.points[1],
	                        ref: this.points[2]
	                    }
	                }));
	                this.points[3].setCoord(this.points[0].coord);
	            };


	        //
	        // Side-Angle-Side
	        //
	        } else if (options.type === "SAS") {
	            options.angles[0] = randomAngle(options.angles[0]);
	            options.sides[2] = randomSide(options.sides[2]);
	            options.angles[2] = randomAngle(options.angles[2]);
	            options.ticks = [1, 2, 0];
	            options.numArcs = [1, 0, 0];
	            triangle = KhanUtil.addInteractiveTriangle(options);

	            // Point 0 can be used to rotate the shape
	            triangle.setRotationPoint(0);

	            // Point 1 is a fixed distance from point 2
	            triangle.points[1].constraints.fixedDistance = { dist: options.sides[1], point: triangle.points[2] };

	            // Point 2 can be used to rotate the shape
	            triangle.setRotationPoint(2);

	            // Point 3 is unconstrained

	            // When point 1 moves, point 0 moves along with it
	            triangle.points[1].onMove = function(coordX, coordY) {
	                triangle.points[1].coord = [coordX, coordY];
	                triangle.points[0].setCoord(triangle.points[0].applyConstraint(triangle.points[0].coord, {
	                    fixedDistance: {
	                        dist: options.sides[0],
	                        point: triangle.points[1]
	                    },
	                    fixedAngle: {
	                        angle: options.angles[1] * (triangle.reflected ? -1 : 1),
	                        vertex: triangle.points[1],
	                        ref: triangle.points[2]
	                    }
	                }));
	                // Check if point 0 ends up close enough to point 3 to make a triangle
	                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.2) {
	                    triangle.snapCorrect();
	                }
	                triangle.update();
	                return triangle.points[1].coord;
	            };

	            // When point 3 moves, check if it's close enough to point 0 to make a triangle
	            triangle.points[3].onMove = function(coordX, coordY) {
	                triangle.points[3].coord = [coordX, coordY];
	                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.2) {
	                    triangle.snapCorrect();
	                }
	                triangle.update();
	                return triangle.points[3].coord;
	            };

	            triangle.snapCorrect = function() {
	                this.points[3].setCoord(this.points[0].coord);
	            };


	        //
	        // Side-Side-Angle
	        //
	        } else if (options.type === "SAA") {
	            options.angles[0] = randomAngle(options.angles[0]);
	            options.sides[1] = randomSide(options.sides[1]);
	            options.sides[2] = randomSide(options.sides[2]);
	            options.ticks = [1, 0, 0];
	            options.numArcs = [1, 2, 0];
	            triangle = KhanUtil.addInteractiveTriangle(options);

	            // Point 0 can be used to rotate the shape
	            triangle.setRotationPoint(0);

	            // Point 1 is a fixed angle from points 3 and 2
	            triangle.points[1].constraints.fixedAngle = { angle: options.angles[2] * (triangle.reflected ? -1 : 1), vertex: triangle.points[2], ref: triangle.points[3] };

	            // Point 2 can be used to rotate the shape
	            triangle.setRotationPoint(2);

	            // Point 3 is a fixed angle from points 1 and 2
	            triangle.points[3].constraints.fixedAngle = { angle: options.angles[2] * (triangle.reflected ? 1 : -1), vertex: triangle.points[2], ref: triangle.points[1] };

	            // When point 1 moves, point 0 moves along with it
	            triangle.points[1].onMove = function(coordX, coordY) {
	                triangle.points[1].coord = [coordX, coordY];
	                triangle.points[0].setCoord(triangle.points[0].applyConstraint(triangle.points[0].coord, {
	                    fixedDistance: {
	                        dist: options.sides[0],
	                        point: triangle.points[1]
	                    },
	                    fixedAngle: {
	                        angle: options.angles[1] * (triangle.reflected ? -1 : 1),
	                        vertex: triangle.points[1],
	                        ref: triangle.points[2]
	                    }
	                }));
	                // Check if point 0 ends up close enough to point 3 to make a triangle
	                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.3) {
	                    triangle.snapCorrect();
	                }
	                triangle.update();
	                return triangle.points[1].coord;
	            };

	            // When point 3 moves, check if it's close enough to point 0 to make a triangle
	            triangle.points[3].onMove = function(coordX, coordY) {
	                triangle.points[3].coord = [coordX, coordY];
	                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.3) {
	                    triangle.snapCorrect();
	                }
	                triangle.update();
	                return triangle.points[3].coord;
	            };

	            triangle.snapCorrect = function() {
	                this.points[1].setCoord(this.points[1].applyConstraint(this.points[1].coord, {
	                    fixedDistance: {
	                        dist: options.triangle.sideLengths[1],
	                        point: this.points[2]
	                    }
	                }));
	                this.points[0].setCoord(this.points[0].applyConstraint(this.points[0].coord, {
	                    fixedDistance: {
	                        dist: options.triangle.sideLengths[0],
	                        point: this.points[1]
	                    },
	                    fixedAngle: {
	                        angle: options.angles[1] * (this.reflected ? -1 : 1),
	                        vertex: this.points[1],
	                        ref: this.points[2]
	                    }
	                }));
	                this.points[3].setCoord(this.points[3].applyConstraint(this.points[3].coord, {
	                    fixedDistance: {
	                        dist: options.triangle.sideLengths[2],
	                        point: this.points[2]
	                    }
	                }));
	            };


	        //
	        // Angle-Side-Angle
	        //
	        } else if (options.type === "ASA") {
	            options.sides[0] = randomSide(options.sides[0]);
	            options.angles[0] = randomAngle(options.angles[0]);
	            options.sides[2] = randomSide(options.sides[2]);
	            options.ticks = [0, 1, 0];
	            options.numArcs = [1, 2, 0];
	            triangle = KhanUtil.addInteractiveTriangle(options);

	            // Point 0 is a fixed angle from points 2 and 1
	            triangle.points[0].constraints.fixedAngle = { angle: options.angles[1] * (triangle.reflected ? -1 : 1), vertex: triangle.points[1], ref: triangle.points[2] };

	            // Point 1 can be used to rotate the shape
	            triangle.setRotationPoint(1);

	            // Point 2 can be used to rotate the shape
	            triangle.setRotationPoint(2);

	            // Point 3 is a fixed angle from points 1 and 2
	            triangle.points[3].constraints.fixedAngle = { angle: options.angles[2] * (triangle.reflected ? 1 : -1), vertex: triangle.points[2], ref: triangle.points[1] };

	            // When point 0 moves, check if it's close enough to point 3 to make a triangle
	            triangle.points[0].onMove = function(coordX, coordY) {
	                triangle.points[0].coord = [coordX, coordY];
	                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.3) {
	                    triangle.snapCorrect();
	                }
	                triangle.update();
	                return triangle.points[0].coord;
	            };

	            // When point 3 moves, check if it's close enough to point 0 to make a triangle
	            triangle.points[3].onMove = function(coordX, coordY) {
	                triangle.points[3].coord = [coordX, coordY];
	                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.3) {
	                    triangle.snapCorrect();
	                }
	                triangle.update();
	                return triangle.points[3].coord;
	            };

	            triangle.snapCorrect = function() {
	                this.points[0].setCoord(this.points[0].applyConstraint(this.points[0].coord, {
	                    fixedDistance: {
	                        dist: options.triangle.sideLengths[0],
	                        point: this.points[1]
	                    }
	                }));
	                this.points[3].setCoord(this.points[3].applyConstraint(this.points[3].coord, {
	                    fixedDistance: {
	                        dist: options.triangle.sideLengths[2],
	                        point: this.points[2]
	                    }
	                }));
	            };


	        //
	        // Angle-Angle-Angle
	        //
	        } else if (options.type === "AAA") {
	            var scale = KhanUtil.random() < 0.5 ? 1 : KhanUtil.random() > 0.5 ? KhanUtil.random() * 0.4 + 1.2 : KhanUtil.random() * 0.2 + 0.6;
	            options.sides[0] *= scale;
	            options.sides[1] *= scale;
	            options.sides[2] *= scale;
	            options.numArcs = [2, 3, 1];
	            triangle = KhanUtil.addInteractiveTriangle(options);
	            triangle.isCongruent = scale === 1;

	            // The shape is always a triangle, so we don't need 4 points visible
	            triangle.points[0].visibleShape.remove();
	            triangle.points[0].mouseTarget.remove();
	            triangle.points[0].visible = false;

	            // Point 1 can be used to rotate the shape
	            triangle.setRotationPoint(1);

	            // Point 2 can be used to rotate the shape
	            triangle.setRotationPoint(2);

	            // Point 3 is a fixed angle from the centroid
	            triangle.points[3].constraints.fixedAngle = {
	                angle: KhanUtil.findAngle(triangle.points[3].coord, triangle.points[1].coord, triangle.rotationPoint.coord),
	                vertex: triangle.rotationPoint,
	                ref: triangle.points[1]
	            };

	            // When point 3 moves, scale the entire triangle
	            triangle.points[3].onMove = function(coordX, coordY) {
	                triangle.points[3].coord = [coordX, coordY];
	                triangle.points[0].setCoord([coordX, coordY]);
	                var scaleFactor = KhanUtil.getDistance([coordX, coordY], triangle.rotationPoint.coord) / triangle.radii[3];
	                triangle.points[1].setCoord(triangle.points[1].applyConstraint(triangle.points[1].coord, {
	                    fixedDistance: {
	                        dist: triangle.radii[1] * scaleFactor,
	                        point: triangle.rotationPoint
	                    }
	                }));
	                triangle.points[2].setCoord(triangle.points[2].applyConstraint(triangle.points[2].coord, {
	                    fixedDistance: {
	                        dist: triangle.radii[2] * scaleFactor,
	                        point: triangle.rotationPoint
	                    }
	                }));
	                // Check if the triangle is close enough to congruent to make it easier/possible to get wrong
	                if (Math.abs(KhanUtil.getDistance(triangle.points[0].coord, triangle.points[1].coord) - options.triangle.sideLengths[0]) < 0.3) {
	                    triangle.snapCorrect();
	                    triangle.isCongruent = true;
	                } else {
	                    triangle.isCongruent = false;
	                }
	                triangle.update();
	                return triangle.points[3].coord;
	            };

	            triangle.snapCorrect = function() {
	                this.points[3].setCoord(this.points[0].applyConstraint(this.points[0].coord, {
	                    fixedDistance: {
	                        dist: KhanUtil.getDistance(options.triangle.points[0], options.triangle.centroid),
	                        point: this.rotationPoint
	                    }
	                }));
	                this.points[0].setCoord(this.points[3].coord);
	                this.points[1].setCoord(this.points[1].applyConstraint(this.points[1].coord, {
	                    fixedDistance: {
	                        dist: KhanUtil.getDistance(options.triangle.points[1], options.triangle.centroid),
	                        point: this.rotationPoint
	                    }
	                }));
	                this.points[2].setCoord(this.points[2].applyConstraint(this.points[2].coord, {
	                    fixedDistance: {
	                        dist: KhanUtil.getDistance(options.triangle.points[2], options.triangle.centroid),
	                        point: this.rotationPoint
	                    }
	                }));
	            };


	        }
	        KhanUtil.currentGraph.interactiveTriangle = triangle;

	    },


	    addInteractiveTriangle: function(options) {
	        var triangle = $.extend({
	            points: [],
	            lines: [],
	            numArcs: options.numArcs,
	            arcs: [],
	            radii: [],
	            reflected: false,
	            animating: false,
	            isCongruent: true,
	            isTriangle: false
	        }, options);

	        // Redraw/refresh the triangle
	        triangle.update = function() {
	            if (!KhanUtil.dragging) {
	                // if the shape is a triangle, rotate around the centroid, otherwise use the center of the bounding box
	                if (Math.abs(triangle.points[0].coord[0] - triangle.points[3].coord[0]) < 0.001 && Math.abs(triangle.points[0].coord[1] - triangle.points[3].coord[1]) < 0.001) {
	                    triangle.isTriangle = true;
	                    triangle.rotationPoint.setCoord([
	                        1 / 3 * (triangle.points[0].coord[0] + triangle.points[1].coord[0] + triangle.points[2].coord[0]),
	                        1 / 3 * (triangle.points[0].coord[1] + triangle.points[1].coord[1] + triangle.points[2].coord[1])
	                    ]);
	                } else {
	                    triangle.isTriangle = false;
	                    var minX = Math.min(triangle.points[0].coord[0], triangle.points[1].coord[0], triangle.points[2].coord[0], triangle.points[3].coord[0]);
	                    var maxX = Math.max(triangle.points[0].coord[0], triangle.points[1].coord[0], triangle.points[2].coord[0], triangle.points[3].coord[0]);
	                    var minY = Math.min(triangle.points[0].coord[1], triangle.points[1].coord[1], triangle.points[2].coord[1], triangle.points[3].coord[1]);
	                    var maxY = Math.max(triangle.points[0].coord[1], triangle.points[1].coord[1], triangle.points[2].coord[1], triangle.points[3].coord[1]);

	                    triangle.rotationPoint.setCoord([(maxX - minX) / 2 + minX, (maxY - minY) / 2 + minY]);
	                }

	                for (var point = 0; point < 4; ++point) {
	                    triangle.radii[point] = KhanUtil.getDistance(triangle.points[point].coord, triangle.rotationPoint.coord);
	                    if (triangle.points[point].isRotationPoint) {
	                        triangle.points[point].constraints.fixedDistance = { dist: triangle.radii[point], point: triangle.rotationPoint };
	                    }
	                }
	            }

	            var graph = KhanUtil.currentGraph;
	            graph.style({ stroke: KhanUtil.BLUE, opacity: 1.0, "stroke-width": 2 });
	            for (var angle = 0; angle < 2; ++angle) {
	                $(triangle.arcs[angle]).each(function() { this.remove(); });
	                triangle.arcs[angle] = graph.drawArcs(triangle.points[angle].coord, triangle.points[angle + 1].coord, triangle.points[angle + 2].coord, options.numArcs[angle]);
	            }
	            if (options.numArcs[2]) {
	                $(triangle.arcs[2]).each(function() { this.remove(); });
	                triangle.arcs[angle] = graph.drawArcs(triangle.points[2].coord, triangle.points[3].coord, triangle.points[1].coord, options.numArcs[2]);
	            }

	            $(triangle.lines).each(function() {
	                this.transform(true);
	                this.toFront();
	            });
	            $(triangle.points).each(function() { this.toFront(); });
	        };

	        // Call to set one of the points to rotate the entire shape
	        triangle.setRotationPoint = function(point) {
	            triangle.points[point].isRotationPoint = true;
	            triangle.points[point].normalStyle = { fill: KhanUtil.BLUE, stroke: KhanUtil.BLUE, scale: 1 };
	            triangle.points[point].highlightStyle = { fill: KhanUtil.BLUE, stroke: KhanUtil.BLUE, scale: 1.5 };
	            triangle.points[point].visibleShape.attr(triangle.points[point].normalStyle);
	            triangle.points[point].constraints.fixedDistance = { dist: triangle.radii[point], point: triangle.rotationPoint };

	            triangle.points[point].onMove = function(coordX, coordY) {
	                var dAngle = KhanUtil.findAngle([coordX, coordY], triangle.points[point].coord, triangle.rotationPoint.coord) * Math.PI / 180;
	                for (var i = 0; i < 4; ++i) {
	                    if (i !== point) {
	                        triangle.points[i].setCoord([
	                            (triangle.points[i].coord[0] - triangle.rotationPoint.coord[0]) * Math.cos(dAngle) - (triangle.points[i].coord[1] - triangle.rotationPoint.coord[1]) * Math.sin(dAngle) + triangle.rotationPoint.coord[0],
	                            (triangle.points[i].coord[0] - triangle.rotationPoint.coord[0]) * Math.sin(dAngle) + (triangle.points[i].coord[1] - triangle.rotationPoint.coord[1]) * Math.cos(dAngle) + triangle.rotationPoint.coord[1]
	                        ]);
	                    }
	                }
	                triangle.points[point].coord = [coordX, coordY];
	                triangle.update();
	            };
	        };

	        $(".question").prepend("<button id='reflect' type='button'>" +
	            $._("Reflect shape") + "</button>");
	        $("button#reflect").bind("click", function(event) {
	            this.blur();
	            if (!triangle.animating) {
	                triangle.animating = true;
	                var startPoints = $.map(triangle.points, function(pt) { return [pt.coord.slice()]; });
	                var xMin = Math.min.apply(Math, $.map(startPoints, function(x) { return x[0]; }));
	                var xMax = Math.max.apply(Math, $.map(startPoints, function(x) { return x[0]; }));
	                var xMid = (xMin + xMax) / 2;
	                var endPoints = $.map(triangle.points, function(pt) { return [[xMid - pt.coord[0] + xMid, pt.coord[1]]]; });

	                // flip the angles around
	                $(triangle.points).each(function(n, point) {
	                    if (typeof point.constraints.fixedAngle.angle === "number") {
	                        point.constraints.fixedAngle.angle *= -1;
	                    }
	                });
	                triangle.reflected = !triangle.reflected;

	                // remove the angle arc decorations since (without some effort) they look funny during the animation
	                $(triangle.arcs[0]).each(function() { this.remove(); });
	                $(triangle.arcs[1]).each(function() { this.remove(); });
	                $(triangle.arcs[2]).each(function() { this.remove(); });

	                var xCoords = { 0: startPoints[0][0], 1: startPoints[1][0], 2: startPoints[2][0], 3: startPoints[3][0] };
	                $(xCoords).animate({ 0: endPoints[0][0], 1: endPoints[1][0], 2: endPoints[2][0], 3: endPoints[3][0] }, {
	                    duration: 500,
	                    easing: "linear",
	                    step: function(now, fx) {
	                        $(triangle.points).each(function(n) { this.setCoord([xCoords[n], endPoints[n][1]]); });
	                        $(triangle.lines).each(function() { this.transform(true); });
	                    },
	                    complete: function() {
	                        $(triangle.points).each(function(n) { this.setCoord(endPoints[n]); });
	                        triangle.update();
	                        triangle.animating = false;
	                    }
	                });
	            }
	        });

	        // Flip the angles around if the triangle starts out reflected
	        var angles = options.angles.slice();

	        if (!options.reflected) {
	            $(angles).each(function(n) {
	                angles[n] *= -1;
	            });
	        }

	        var graphie = KhanUtil.currentGraph;
	        // Start at 0,0 and build the shape, logo-style
	        var coord = [0, 0];
	        triangle.points.push(graphie.addMovablePoint({ coord: coord }));

	        coord[0] += options.sides[0] * Math.cos(angles[0] * Math.PI / 180);
	        coord[1] += options.sides[0] * Math.sin(angles[0] * Math.PI / 180);
	        triangle.points.push(graphie.addMovablePoint({ coord: coord, bounded: false }));

	        coord[0] += options.sides[1] * Math.cos(-(180 - angles[1] - angles[0]) * Math.PI / 180);
	        coord[1] += options.sides[1] * Math.sin(-(180 - angles[1] - angles[0]) * Math.PI / 180);
	        triangle.points.push(graphie.addMovablePoint({ coord: coord, bounded: false }));

	        coord[0] += options.sides[2] * Math.cos((angles[2] + angles[1] + angles[0]) * Math.PI / 180);
	        coord[1] += options.sides[2] * Math.sin((angles[2] + angles[1] + angles[0]) * Math.PI / 180);
	        triangle.points.push(graphie.addMovablePoint({ coord: coord, bounded: false }));

	        triangle.lines.push(graphie.addMovableLineSegment({ pointA: triangle.points[0], pointZ: triangle.points[1], ticks: options.ticks[0], highlightStyle: { "stroke": KhanUtil.BLUE, "stroke-width": 4 } }));
	        triangle.lines.push(graphie.addMovableLineSegment({ pointA: triangle.points[1], pointZ: triangle.points[2], ticks: options.ticks[1], highlightStyle: { "stroke": KhanUtil.BLUE, "stroke-width": 4 } }));
	        triangle.lines.push(graphie.addMovableLineSegment({ pointA: triangle.points[2], pointZ: triangle.points[3], ticks: options.ticks[2], highlightStyle: { "stroke": KhanUtil.BLUE, "stroke-width": 4 } }));

	        triangle.rotationPoint = graphie.addMovablePoint({ visible: false });

	        // Translate the triangle so it's all visible
	        var xlateX = 4 - Math.max(triangle.points[0].coord[0], triangle.points[1].coord[0], triangle.points[2].coord[0], triangle.points[3].coord[0]);
	        var xlateY = 4 - Math.max(triangle.points[0].coord[1], triangle.points[1].coord[1], triangle.points[2].coord[1], triangle.points[3].coord[1]);
	        $(triangle.points).each(function() { this.setCoord([this.coord[0] + xlateX, this.coord[1] + xlateY]); });

	        // Dragging the lines translates the entire shape
	        for (var line = 0; line < 3; ++line) {
	            triangle.lines[line].onMove = function(dX, dY) {
	                $(triangle.points).each(function() { this.setCoord([this.coord[0] + dX, this.coord[1] + dY]); });
	                triangle.update();
	            };
	            triangle.lines[line].onMoveEnd = function() {
	                triangle.update();
	            };
	        }

	        // Always redraw the triangle after a point moves
	        for (var point = 0; point < 4; ++point) {
	            triangle.points[point].onMoveEnd = function(coordX, coordY) {
	                triangle.update();
	            };
	        }

	        triangle.update();
	        return triangle;
	    },



	    addTriangleDecorations: function(triangle, type) {
	        var ticks = [0, 0, 0];
	        var arcs = [0, 0, 0];
	        if (type === "SSS") {
	            ticks = [1, 2, 3];
	        } else if (type === "SSA") {
	            arcs = [0, 0, 1];
	            ticks = [1, 2, 0];
	        } else if (type === "SAS") {
	            arcs = [0, 1, 0];
	            ticks = [1, 2, 0];
	        } else if (type === "SAA") {
	            arcs = [0, 1, 2];
	            ticks = [1, 0, 0];
	        } else if (type === "ASA") {
	            arcs = [0, 1, 2];
	            ticks = [0, 1, 0];
	        } else if (type === "AAA") {
	            arcs = [1, 2, 3];
	        }

	        var graphie = KhanUtil.currentGraph;
	        graphie.addMovableLineSegment({ coordA: triangle.points[0], coordZ: triangle.points[1], fixed: true, ticks: ticks[0], normalStyle: { stroke: "#b1c9f5", "stroke-width": 2 } });
	        graphie.addMovableLineSegment({ coordA: triangle.points[1], coordZ: triangle.points[2], fixed: true, ticks: ticks[1], normalStyle: { stroke: "#b1c9f5", "stroke-width": 2 } });
	        graphie.addMovableLineSegment({ coordA: triangle.points[2], coordZ: triangle.points[0], fixed: true, ticks: ticks[2], normalStyle: { stroke: "#b1c9f5", "stroke-width": 2 } });
	        graphie.drawArcs(triangle.points[2], triangle.points[0], triangle.points[1], arcs[0]);
	        graphie.drawArcs(triangle.points[0], triangle.points[1], triangle.points[2], arcs[1]);
	        graphie.drawArcs(triangle.points[1], triangle.points[2], triangle.points[0], arcs[2]);
	        $(triangle.set).each(function() { this.toBack(); });
	    }

	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(16);

	$.extend(KhanUtil, {
	    initUnitCircle: function(degrees) {
	        var graph = KhanUtil.currentGraph;

	        // Create a properly scaled 600x600px graph
	        var options = {
	            xpixels: 514,
	            ypixels: 514,
	            range: [[-1.2, 1.2], [-1.2, 1.2]]
	        };
	        options.scale = [options.xpixels / (options.range[0][1] - options.range[0][0]),
	                          options.ypixels / (options.range[1][1] - options.range[1][0])];
	        graph.init(options);

	        // Attach the metrics to the graph for later reference
	        graph.xpixels = options.xpixels;
	        graph.ypixels = options.ypixels;
	        graph.range = options.range;
	        graph.scale = options.scale;

	        graph.angle = 0;
	        graph.revolutions = 0;
	        graph.quadrant = 1;

	        graph.dragging = false;
	        graph.highlight = false;
	        graph.degrees = degrees;

	        // Axes and circle
	        graph.style({
	            stroke: "#ddd",
	            strokeWidth: 1,
	            arrows: "->"
	        }, function() {
	            graph.circle([0, 0], 1);
	            graph.line([-1.2, 0], [1.2, 0]);
	            graph.line([0, -1.2], [0, 1.2]);
	            graph.line([1.2, 0], [-1.2, 0]);
	            graph.line([0, 1.2], [0, -1.2]);
	        });

	        // Tick marks at -1, 1
	        graph.style({
	            strokeWidth: 2
	        }, function() {
	            graph.line([-1, -5 / graph.scale[0]], [-1, 5 / graph.scale[0]]);
	            graph.line([1, -5 / graph.scale[0]], [1, 5 / graph.scale[0]]);
	            graph.line([-5 / graph.scale[0], -1], [5 / graph.scale[0], -1]);
	            graph.line([-5 / graph.scale[0], 1], [5 / graph.scale[0], 1]);
	        });

	        // Declare all the graphic elements that get manipulated each time the angle changes
	        graph.triangle = KhanUtil.bogusShape;
	        graph.rightangle = KhanUtil.bogusShape;
	        graph.spiral = KhanUtil.bogusShape;
	        graph.arrow = KhanUtil.bogusShape;
	        graph.cosLabel = KhanUtil.bogusShape;
	        graph.sinLabel = KhanUtil.bogusShape;
	        graph.radiusLabel = KhanUtil.bogusShape;
	        graph.angleLabel = KhanUtil.bogusShape;
	        graph.angleLines = KhanUtil.bogusShape;

	        KhanUtil.initMouseHandlers();
	        KhanUtil.setAngle(graph.angle);
	    },

	    // Not all shapes are needed to depict every angle. If a shape isn't
	    // needed, it's replaced with bogusShape which just has stub methods
	    // that successfully do nothing.
	    // The alternative would be 'if..typeof' checks all over the place.
	    bogusShape: {
	        animate: function() {},
	        attr: function() {},
	        remove: function() {}
	    },


	    initMouseHandlers: function() {
	        var graph = KhanUtil.currentGraph;

	        // Another SVG element on top of everything else where we can add
	        // invisible shapes with mouse handlers wherever we want.
	        graph.mouselayer = Raphael("unitcircle", graph.xpixels, graph.ypixels);
	        $(graph.mouselayer.canvas).css("z-index", 1);
	        Khan.scratchpad.disable();

	        // Visible orange point that gets dragged
	        graph.style({
	            stroke: KhanUtil.ORANGE,
	            fill: KhanUtil.ORANGE
	        }, function() {
	            graph.dragPoint = graph.circle([1, 0], 4 / graph.scale[0]);
	        });

	        // The invisible circle that gets mouse events.
	        graph.mouseTarget = graph.mouselayer.circle(
	                (1 - graph.range[0][0]) * graph.scale[0],
	                (graph.range[1][1] - 0) * graph.scale[1], 15);
	        graph.mouseTarget.attr({fill: "#000", "opacity": 0.0});

	        $(graph.mouseTarget[0]).css("cursor", "move");
	        $(graph.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function(event) {
	            var graph = KhanUtil.currentGraph;
	            if (event.type === "vmouseover") {
	                graph.highlight = true;
	                if (!graph.dragging) {
	                    KhanUtil.highlightAngle();
	                }

	            } else if (event.type === "vmouseout") {
	                graph.highlight = false;
	                if (!graph.dragging) {
	                    KhanUtil.unhighlightAngle();
	                }

	            } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
	                event.preventDefault();
	                $(document).bind("vmousemove vmouseup", function(event) {
	                    event.preventDefault();
	                    graph.dragging = true;

	                    // mouseY is in pixels relative to the SVG; coordY is the scaled y-coordinate value
	                    var mouseY = event.pageY - $("#unitcircle").offset().top;
	                    var mouseX = event.pageX - $("#unitcircle").offset().left;
	                    var coordX = (mouseX / graph.scale[0]) + graph.range[0][0];
	                    var coordY = graph.range[1][1] - mouseY / graph.scale[1];

	                    if (event.type === "vmousemove") {
	                        // Find the angle from the origin to the mouse pointer
	                        var angle;
	                        if (coordX) {
	                            angle = Math.atan(coordY / coordX);
	                        } else {
	                            // Fill in where atan is undefined
	                            if (coordY > 0) {
	                                angle = -Math.PI / 2;
	                            } else {
	                                angle = -Math.PI / 2;
	                            }
	                        }

	                        // Round the angle to the nearest 5 degree increment
	                        angle = Math.round(angle / (Math.PI / 36)) * (Math.PI / 36);

	                        // Figure out what quadrant the mouse is in. Since atan
	                        // is only defined in Q1 and Q4 (and is negative in Q4),
	                        // adjust the angle appropriately to represent the correct
	                        // positive angle in the unit circle.
	                        //
	                        // If moving between Q1 and Q4, keep track of the number of revolutions.
	                        if (coordX > 0 && coordY >= 0) {
	                            if (graph.quadrant === 4) {
	                                ++graph.revolutions;
	                            }
	                            graph.quadrant = 1;

	                        } else if (coordX <= 0 && coordY > 0) {
	                            angle += Math.PI;
	                            graph.quadrant = 2;

	                        } else if (coordX < 0 && coordY <= 0) {
	                            angle += Math.PI;
	                            graph.quadrant = 3;

	                        } else if (coordX >= 0 && coordY < 0) {
	                            angle += 2 * Math.PI;
	                            if (graph.quadrant === 1) {
	                                --graph.revolutions;
	                            }
	                            graph.quadrant = 4;
	                        }

	                        // Limit the number of revolutions to 2 in either direction.
	                        if (graph.revolutions <= -3) {
	                            graph.revolutions = -3;
	                            angle = 2 * Math.PI;
	                        } else if (graph.revolutions >= 2) {
	                            graph.revolutions = 2;
	                            angle = 0;
	                        }

	                        // Now ((2pi * revolutions) + angle) represents the full angle
	                        // Redraw the angle only if it's changed
	                        if (graph.angle !== angle + (graph.revolutions * 2 * Math.PI)) {
	                            KhanUtil.setAngle(angle + (graph.revolutions * 2 * Math.PI));
	                        }

	                    } else if (event.type === "vmouseup") {
	                        $(document).unbind("vmousemove vmouseup");
	                        graph.dragging = false;
	                        if (!graph.highlight) {
	                            KhanUtil.unhighlightAngle();
	                        }
	                    }
	                });
	            }
	        });

	    },


	    highlightAngle: function() {
	        var graph = KhanUtil.currentGraph;
	        graph.dragPoint.animate({ scale: 2 }, 50);
	        graph.angleLines.animate({ stroke: KhanUtil.ORANGE }, 100);
	        graph.spiral.animate({ stroke: KhanUtil.ORANGE }, 100);
	        graph.arrow.animate({ fill: KhanUtil.ORANGE }, 100);
	        $(graph.angleLabel).animate({ color: KhanUtil.ORANGE }, 100);
	        //$(graph.angleLabel).css({ color: KhanUtil.ORANGE });
	    },


	    unhighlightAngle: function() {
	        var graph = KhanUtil.currentGraph;
	        graph.dragPoint.animate({ scale: 1 }, 50);
	        graph.angleLines.animate({ stroke: KhanUtil.BLUE }, 100);
	        graph.spiral.animate({ stroke: KhanUtil.BLUE }, 100);
	        graph.arrow.animate({ fill: KhanUtil.BLUE }, 100);
	        $(graph.angleLabel).animate({ color: KhanUtil.BLUE }, 100);
	        //$(graph.angleLabel).css({ color: KhanUtil.BLUE });
	    },


	    // Redraw the angle
	    setAngle: function(angle) {
	        var graph = KhanUtil.currentGraph;
	        graph.angle = angle;

	        graph.quadrant = (Math.floor((angle + 10 * Math.PI) / (Math.PI / 2)) % 4) + 1;
	        graph.revolutions = Math.floor(angle / (2 * Math.PI));

	        // Remove everything dynamic. It should be safe to call remove()
	        // on everything since unused stuff should be instances of bogusShape
	        graph.triangle.remove();
	        graph.rightangle.remove();
	        graph.spiral.remove();
	        graph.arrow.remove();
	        graph.cosLabel.remove();
	        graph.sinLabel.remove();
	        graph.radiusLabel.remove();
	        graph.angleLabel.remove();
	        graph.angleLines.remove();

	        var highlightColor = KhanUtil.BLUE;
	        if (graph.dragging || graph.highlight) {
	            highlightColor = KhanUtil.ORANGE;
	        }

	        // Draw the bold angle lines
	        graph.style({ stroke: highlightColor, strokeWidth: 3 });
	        graph.angleLines = graph.path([[1, 0], [0, 0], [Math.cos(angle), Math.sin(angle)]]);


	        graph.style({ stroke: KhanUtil.BLUE, strokeWidth: 1 });
	        graph.triangle = graph.path([[0, 0], [Math.cos(angle), 0], [Math.cos(angle), Math.sin(angle)], [0, 0]]);

	        var cosText = KhanUtil.roundTo(3, Math.cos(angle));
	        var sinText = KhanUtil.roundTo(3, Math.sin(angle));

	        // Include radicals for common 45-45-90 and 30-60-90 values
	        var prettyAngles = {
	            "0.866": "\\frac{\\sqrt{3}}{2}\\;(0.866)",
	            "-0.866": "-\\frac{\\sqrt{3}}{2}\\;(-0.866)",
	            "0.707": "\\frac{\\sqrt{2}}{2}\\;(0.707)",
	            "-0.707": "-\\frac{\\sqrt{2}}{2}\\;(-0.707)",
	            "0.5": "\\frac{1}{2}\\;(0.5)",
	            "-0.5": "-\\frac{1}{2}\\;(-0.5)"
	        };

	        cosText = prettyAngles[cosText] ? prettyAngles[cosText] : cosText;
	        sinText = prettyAngles[sinText] ? prettyAngles[sinText] : sinText;

	        // Position the distance labels and right-angle marker based on quadrant
	        if (angle % Math.PI === 0) {
	            graph.cosLabel = graph.label([Math.cos(angle) / 2, 0], cosText, "below");
	        } else if (angle % (Math.PI / 2) === 0) {
	            graph.sinLabel = graph.label([Math.cos(angle), Math.sin(angle) / 2], sinText, "right");
	        } else if (graph.quadrant === 1) {
	            graph.cosLabel = graph.label([Math.cos(angle) / 2, 0], cosText, "below");
	            graph.sinLabel = graph.label([Math.cos(angle), Math.sin(angle) / 2], sinText, "right");
	            graph.radiusLabel = graph.label([Math.cos(angle) / 2, Math.sin(angle) / 2], 1, "above left");
	            graph.rightangle = graph.path([[Math.cos(angle) - 0.04, 0], [Math.cos(angle) - 0.04, 0.04], [Math.cos(angle), 0.04]]);
	        } else if (graph.quadrant === 2) {
	            graph.cosLabel = graph.label([Math.cos(angle) / 2, 0], cosText, "below");
	            graph.sinLabel = graph.label([Math.cos(angle), Math.sin(angle) / 2], sinText, "left");
	            graph.radiusLabel = graph.label([Math.cos(angle) / 2, Math.sin(angle) / 2], 1, "above right");
	            graph.rightangle = graph.path([[Math.cos(angle) + 0.04, 0], [Math.cos(angle) + 0.04, 0.04], [Math.cos(angle), 0.04]]);
	        } else if (graph.quadrant === 3) {
	            graph.cosLabel = graph.label([Math.cos(angle) / 2, 0], cosText, "above");
	            graph.sinLabel = graph.label([Math.cos(angle), Math.sin(angle) / 2], sinText, "left");
	            graph.radiusLabel = graph.label([Math.cos(angle) / 2, Math.sin(angle) / 2], 1, "below right");
	            graph.rightangle = graph.path([[Math.cos(angle) + 0.04, 0], [Math.cos(angle) + 0.04, -0.04], [Math.cos(angle), -0.04]]);
	        } else if (graph.quadrant === 4) {
	            graph.cosLabel = graph.label([Math.cos(angle) / 2, 0], cosText, "above");
	            graph.sinLabel = graph.label([Math.cos(angle), Math.sin(angle) / 2], sinText, "right");
	            graph.radiusLabel = graph.label([Math.cos(angle) / 2, Math.sin(angle) / 2], 1, "below left");
	            graph.rightangle = graph.path([[Math.cos(angle) - 0.04, 0], [Math.cos(angle) - 0.04, -0.04], [Math.cos(angle), -0.04]]);
	        }

	        // Draw the spiral angle indicator
	        var points = [];
	        for (var i = 0; i <= 50; ++i) {
	            points.push([Math.cos(i * angle / 50) * (0.1 + ((i * Math.abs(angle) / 50 / Math.PI) * 0.02)),
	                          Math.sin(i * angle / 50) * (0.1 + ((i * Math.abs(angle) / 50 / Math.PI) * 0.02))]);
	        }
	        graph.style({ strokeWidth: 2, stroke: highlightColor });

	        graph.spiral = graph.path(points);

	        // Draw an arrow at the end of the spiral angle indicator
	        var spiralEndX = points[50][0];
	        var spiralEndY = points[50][1];
	        graph.style({ stroke: false, fill: highlightColor }, function() {
	            if (angle > Math.PI / 12) {
	                // positive angles big enough to need an arrow
	                graph.arrow = graph.path([[spiralEndX, spiralEndY - 0.005],
	                                           [spiralEndX - 0.02, spiralEndY - 0.03],
	                                           [spiralEndX + 0.02, spiralEndY - 0.03],
	                                           [spiralEndX, spiralEndY - 0.005]]);
	                graph.arrow.rotate((angle - Math.PI / 20) * (-180 / Math.PI), (spiralEndX - graph.range[0][0]) * graph.scale[0], (graph.range[1][1] - spiralEndY) * graph.scale[1]);
	            } else if (angle < -Math.PI / 12) {
	                // negative angles "big" enough to need an arrow
	                graph.arrow = graph.path([[spiralEndX, spiralEndY + 0.005],
	                                           [spiralEndX - 0.02, spiralEndY + 0.03],
	                                           [spiralEndX + 0.02, spiralEndY + 0.03],
	                                           [spiralEndX, spiralEndY + 0.005]]);
	                graph.arrow.rotate((angle + Math.PI / 20) * (-180 / Math.PI), (spiralEndX - graph.range[0][0]) * graph.scale[0], (graph.range[1][1] - spiralEndY) * graph.scale[1]);
	            } else {
	                // no room for an arrow
	                graph.arrow = KhanUtil.bogusShape;
	            }
	        });


	        // Figure out how to display the angle
	        var angleText = angle;
	        if (graph.degrees) {
	            angleText *= (180 / Math.PI);
	            angleText = Math.round(angleText);
	            angleText += "^{\\circ}";
	        } else if (-15 < angle && angle < 15 && angle !== 0) {
	            angleText = KhanUtil.piFraction(angle);
	        }

	        // Put the angle value somewhere obvious, but not in the way of anything else. This
	        // could probably be improved, but it at least prevents text on top of other text.
	        if (angle < -3.5 * Math.PI) {
	            graph.angleLabel = graph.label([-0.2, 0.2], angleText, "center");
	        } else if (angle < -0.15 * Math.PI) {
	            graph.angleLabel = graph.label([Math.cos(angle / 2) / 5, Math.sin(angle / 2) / 5], angleText, "center");
	        } else if (angle < 0.15 * Math.PI) {
	            graph.angleLabel = graph.label([0, 0], angleText, "left");
	        } else if (angle < 3.5 * Math.PI) {
	            graph.angleLabel = graph.label([Math.cos(angle / 2) / 5, Math.sin(angle / 2) / 5], angleText, "center");
	        } else {
	            graph.angleLabel = graph.label([-0.2, -0.2], angleText, "center");
	        }
	        $(graph.angleLabel).css("color", highlightColor);


	        // Reposition the mouse target and indicator
	        graph.mouseTarget.attr("cx", (Math.cos(angle) - graph.range[0][0]) * graph.scale[0]);
	        graph.mouseTarget.attr("cy", (graph.range[1][1] - Math.sin(angle)) * graph.scale[1]);
	        graph.dragPoint.attr("cx", (Math.cos(angle) - graph.range[0][0]) * graph.scale[0]);
	        graph.dragPoint.attr("cy", (graph.range[1][1] - Math.sin(angle)) * graph.scale[1]);
	        graph.angleLines.toFront();
	        graph.dragPoint.toFront();
	    },


	    goToAngle: function(angle) {
	        var graph = KhanUtil.currentGraph;
	        if (graph.degrees) {
	            angle *= (Math.PI / 180);
	        }
	        var duration = 1000 * Math.abs(angle - graph.angle) / Math.PI;
	        $(graph).animate({
	            angle: angle
	        }, {
	            duration: duration,
	            easing: "linear",
	            step: function(now, fx) {
	                KhanUtil.setAngle(now);
	            }
	        });
	    },


	    showCoordinates: function(angle, highlightCoord) {
	        var graph = KhanUtil.currentGraph;
	        if (graph.degrees) {
	            angle *= (Math.PI / 180);
	        }

	        graph.style({stroke: 0, fill: KhanUtil.BLUE}, function() {
	            graph.circle([Math.cos(angle), Math.sin(angle)], 4 / graph.scale[0]);
	        });
	        graph.dragPoint.toFront();

	        var xCoord = KhanUtil.roundTo(3, Math.cos(angle));
	        var yCoord = KhanUtil.roundTo(3, Math.sin(angle));
	        
	        if (highlightCoord === 'x') {
	            xCoord = "\\pink{" + xCoord + "}";
	        }

	        if (highlightCoord === 'y') {
	            yCoord = "\\pink{" + yCoord + "}";
	        }

	        var coordText = "(" + xCoord + ", " + yCoord + ")";

	        if (Math.floor(angle / Math.PI) % 2) {
	            graph.coordLabel = graph.label([Math.cos(angle), Math.sin(angle)], coordText, "below");
	        } else {
	            graph.coordLabel = graph.label([Math.cos(angle), Math.sin(angle)], coordText, "above");
	        }

	    }

	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	$.extend(KhanUtil, {

	    PiecewiseFunction: function(options) {
	        options = $.extend(true, {
	            INTERVAL_WIDTH: 2,
	            fnArray: [],
	            rangeArray: [],
	            _paths: {}
	        }, options);

	        $.extend(this, options);
	        _.bindAll(this);

	        this.length = function() {
	            return this.fnArray.length;
	        };

	        this.width = function() {
	            var n = this.length();
	            return this.rangeArray[n - 1][1] - this.rangeArray[0][0];
	        };

	        this.toTextArray = function(fnArray) {
	            if (!fnArray) {
	                fnArray = this.fnArray;
	            }
	            return _.map(fnArray, function(fn) {
	                return fn.text();
	            });
	        };

	        this._shiftArray = function() {
	            var w = this.INTERVAL_WIDTH;
	            return _.map(this.rangeArray, function(range, i) {
	                // shift by the original interval start points
	                // (before trimming if the problem is offset)
	                return Math.floor(range[0] / w) * w;
	            });
	        };

	        this._shiftFnArray = function() {
	            var shiftArray = this._shiftArray();
	            return _.map(this.fnArray, function(fn, i) {
	                return fn.scale(1, -shiftArray[i]);
	            });
	        };

	        this.derivative = function(fnArray) {
	            if (!fnArray) {
	                fnArray = this.fnArray;
	            }
	            return _.map(fnArray, function(fn, i) {
	                return fn.derivative();
	            });
	        };

	        this.translate = function(dx, dy) {
	            // dx changes rangeArray
	            if (dx) {
	                this.rangeArray = _.map(this.rangeArray, function(range) {
	                    return _.map(range, function(x) {
	                        return x + dx;
	                    });
	                });
	            }

	            // dy changes functions
	            if (dy) {
	                this.fnArray = _.map(this.fnArray, function(fn) {
	                    var result = fn.add(dy);
	                    return result;
	                });
	            }
	        };

	        // shift rangeArray so that it starts at x = 0
	        // shift fnArray so that smallest value is at y = 0
	        this.calibrate = function() {
	            var dx = this.rangeArray[0][0];

	            var w = this.INTERVAL_WIDTH;
	            var dy = this.fnArray[0].evalOf(0);
	            _.each(this.fnArray, function(fn) {
	                // NOTE: only checks start and endpoints at the moment
	                var start = fn.evalOf(0);
	                var end = fn.evalOf(w);
	                dy = Math.min(dy, start, end);
	            });

	            this.translate(-dx + 2, -dy);
	        };

	        // like w/ JS arrays, startIndex is inclusive, endIndex is exclusive
	        this.slice = function(startIndex, endIndex) {
	            if (startIndex >= endIndex) {
	                return null;
	            }

	            var crop = function(array) {
	                return array.slice(startIndex, endIndex);
	            };

	            return new KhanUtil.PiecewiseFunction({
	                fnArray: crop(this.fnArray),
	                rangeArray: crop(this.rangeArray)
	            });
	        };

	        // returns a new piecewiseFunction
	        this.concat = function(piecewiseFn) {

	            var fnArray = this.fnArray.concat(piecewiseFn.fnArray);

	            // shift the rangeArray of the second function
	            var offset = piecewiseFn.rangeArray[0][0];
	            var start = this.rangeArray[this.rangeArray.length - 1][1];
	            var shiftedRangeArray = _.map(piecewiseFn.rangeArray, function(range) {
	                return _.map(range, function(x) {
	                    return x - offset + start;
	                });
	            });
	            var rangeArray = this.rangeArray.concat(shiftedRangeArray);

	            return new KhanUtil.PiecewiseFunction({
	                fnArray: fnArray,
	                rangeArray: rangeArray
	            });

	        };

	        // find matches w/ piecewiseFunction in this object
	        // only compares fnArray, not rangeArray
	        this.matches = function(piecewiseFunction, useDerivative) {

	            var original = this.fnArray;
	            var other = piecewiseFunction.fnArray;

	            if (useDerivative) {
	                original = this.derivative();
	                other = piecewiseFunction.derivative();
	            }

	            original = this.toTextArray(original);
	            other = this.toTextArray(other);

	            // no matches if the parameter object has more segments than this
	            // object
	            var n = other.length;
	            var diff = original.length - n;
	            if (diff < 0) {
	                return null;
	            }

	            var matches = [];
	            _.times(diff + 1, function(i) {
	                if (_.isEqual(original.slice(i, i + n), other)) {
	                    matches.push(i);
	                }
	            });
	            return matches;
	        };

	        // used in generating the problem graphs
	        // ex: [[0, 1], [1, 2]] with offset == 0.25
	        //          ==> [[0.25, 1], [1, 1.75]]
	        this.trimRangeArrayEnds = function(offset) {
	            // for some reason, an offset of 0 causes this to crash
	            // without this line. ?_?
	            if (offset === 0) {
	                return;
	            }
	            var n = this.length();
	            var offsetAmt = this.INTERVAL_WIDTH * offset;
	            this.rangeArray[0][0] += offsetAmt;
	            this.rangeArray[n - 1][1] += (offsetAmt - this.INTERVAL_WIDTH);
	        };

	        this._makePlotArray = function(fnArray) {
	            if (!fnArray) {
	                fnArray = this.fnArray;
	            }
	            return _.map(fnArray, function(fn, i) {
	                return function(x) {
	                    return fn.evalOf(x);
	                };
	            });
	        };

	        this._plotEndpoints = function(color, plotDerivative, omitEnds) {
	            var shiftedFnArray = this._shiftFnArray();
	            var antiderivFnArray;
	            if (plotDerivative) {
	                antiderivFnArray = shiftedFnArray;
	                shiftedFnArray = this.derivative(shiftedFnArray);
	            }

	            // compute endpoints
	            var emptyEndpoints = [];
	            var filledEndpoints = [];
	            var derivEndpoints = [];

	            var prevX = null;
	            var prevY = null;
	            var prevOrigY = null;
	            var n = this.rangeArray.length;

	            _.each(this.rangeArray, function(range, i) {
	                var fn = shiftedFnArray[i],
	                    origFn;

	                if (plotDerivative) {
	                    origFn = antiderivFnArray[i];
	                }

	                _.each(range, function(x, j) {
	                    var y = fn.evalOf(x);
	                    var origY = plotDerivative ? origFn.evalOf(x) : null;

	                    if (i > 0 && j === 0) {
	                        // if the graph is not connected, add endpoints
	                        if (y !== prevY || x !== prevX) {
	                            // arbitrarily always set "earlier" endpoint as
	                            // filled
	                            filledEndpoints.push([prevX, prevY]);
	                            emptyEndpoints.push([x, y]);

	                        } else {
	                            // don't add endpoints to derivative if both the
	                            // graph and derivative are continuous at (x, y)
	                            if (origY !== prevOrigY || x !== prevX) {
	                                derivEndpoints.push([x, y]);
	                            }
	                        }
	                    }

	                    // start off with an empty first endpoint
	                    // omit first and last endpoints in a cropped window
	                    if (i === 0 && j === 0 && !omitEnds) {
	                        emptyEndpoints.push([x, y]);
	                    }

	                    // end with a filled endpoint
	                    if (i === n - 1 && j === 1 && !omitEnds) {
	                        filledEndpoints.push([x, y]);
	                    }

	                    prevX = x;
	                    prevY = y;
	                    prevOrigY = origY;
	                });
	            });

	            // all endpoints are undefined (empty) in a derivative graph
	            if (plotDerivative) {
	                emptyEndpoints = derivEndpoints.concat(emptyEndpoints)
	                                               .concat(filledEndpoints);
	                filledEndpoints = [];
	            }

	            // plot endpoints
	            var self = this;

	            this._paths["emptyEndpoints"] = this.graphie.style({
	                stroke: color,
	                strokeWidth: 3,
	                fill: "#FFFFFF"
	            }, function() {
	                return self.graphie.plotEndpointCircles(emptyEndpoints);
	            });

	            this._paths["filledEndpoints"] = this.graphie.style({
	                stroke: color,
	                strokeWidth: 3,
	                fill: color
	            }, function() {
	                return self.graphie.plotEndpointCircles(filledEndpoints);
	            });
	        };

	        this._plotSegments = function(color, plotDerivative) {
	            var shiftedFnArray = this._shiftFnArray();
	            if (plotDerivative) {
	                shiftedFnArray = this.derivative(shiftedFnArray);
	            }

	            var plotArray = this._makePlotArray(shiftedFnArray);

	            var self = this;
	            this._paths["segments"] = this.graphie.style({
	                stroke: color,
	                strokeWidth: 3
	            }, function() {
	                return self.graphie.plotPiecewise(plotArray, self.rangeArray);
	            });
	        };

	        this.plot = function(options) {
	            options = $.extend(true, {
	                color: KhanUtil.GREEN,
	                plotDerivative: false,
	                omitEnds: false
	            }, options);

	            this.graphie = options.graphie || KhanUtil.currentGraph;

	            // plot segments
	            this._plotSegments(options.color, options.plotDerivative);

	            // plot endpoints
	            this._plotEndpoints(options.color, options.plotDerivative, options.omitEnds);
	        };

	        this.translatePlot = function(dx, dy) {
	            var scaled = this.graphie.scaleVector([dx, dy]);
	            _.each(this._paths, function(pathSet) {
	                pathSet.translate(scaled[0], scaled[1]);
	            });
	        };

	        // simply changes the opacity of the segment and endpoint paths so
	        // they aren't visible
	        this.hide = function(speed) {
	            if (this.hidden) {
	                return;
	            }

	            speed = speed || 100;

	            _.each(this._paths, function(pathSet) {
	                if (pathSet.length === 0) {
	                    return;
	                }
	                pathSet.animate({
	                    "fill-opacity": 0,
	                    "opacity": 0
	                }, speed);
	            });

	            this.hidden = true;
	        };

	        // make paths visible again
	        this.show = function(speed) {
	            if (!this.hidden) {
	                return;
	            }

	            speed = speed || 100;

	            _.each(this._paths, function(pathSet) {
	                if (pathSet.length === 0) {
	                    return;
	                }
	                pathSet.animate({
	                    "fill-opacity": 1,
	                    "opacity": 1
	                }, speed);
	            });

	            this.hidden = false;
	        };

	        this.toFront = function() {
	            _.each(this._paths, function(pathSet) {
	                pathSet.toFront();
	            });
	        };

	        this.cleanup = function() {
	            _.each(this._paths, function(pathSet) {
	                pathSet.remove();
	            });
	            this._paths = {};
	        };
	    },

	    PiecewiseFunctionGenerator: {

	        _init: (function() {
	            _.bindAll(KhanUtil.PiecewiseFunctionGenerator);
	        })(),

	        // UTILITY FUNCTIONS
	        _isInRange: function(ylims, val) {
	            return !(val <= ylims[0] || val >= ylims[1]);
	        },

	        // create an n-length array
	        _scramble: function(n) {
	            var newIndices = [];
	            _.times(n, function(i) {
	                var newIndex = KhanUtil.randRangeExclude(0, n - 1, newIndices);
	                newIndices.push(newIndex);
	            });
	            return newIndices;
	        },

	        // add new piecewise functions here
	        curveTypes: {
	            "line": {
	                // slopes
	                params: {
	                    m: [-1, -0.5, 0, 0.5, 1]
	                },
	                // convert from f(x) = m(x - a) + b
	                // to f(x) = Ax + B
	                // return [B, A]
	                generate: function(m, b) {
	                    var coefs = [b, m];
	                    return new KhanUtil.Polynomial(0, 1, coefs);
	                }
	            },
	            "curve": {
	                params: {
	                    isLeftCurve: [true, false],
	                    m: [-1, 1]
	                },
	                // convert from f(x) = m(x - a)^2 + b
	                // to f(x) = Ax^2 + Bx + C
	                // return [C, B, A]
	                generate: function(isLeftCurve, m, b, intervalWidth) {
	                    b = isLeftCurve ? b - m * intervalWidth : b;
	                    var a = isLeftCurve ? intervalWidth : 0;
	                    m = m / intervalWidth;
	                    var coefs = [Math.pow(a, 2) * m + b, -2 * a * m, m];
	                    return new KhanUtil.Polynomial(0, 2, coefs);
	                }
	            }
	        },

	        // converts curveTypes into an array of options used in the
	        // recursive generator function
	        makeCombinations: function() {

	            // [[1,2,3], ["one", "two", "three"], ["a", "b", "c"]];
	            var makeParamSets = function(curveTypes) {
	                var paramSets = [];

	                _.each(curveTypes, function(curveType, key) {
	                    // since key is a string, it needs to be wrapped in
	                    // an array
	                    var paramSet = [[key]];
	                    _.each(curveType.params, function(val) {
	                        paramSet.push(val);
	                    });
	                    paramSets.push(paramSet);
	                });

	                return paramSets;
	            };

	            var addParam = function(currList, paramSet, paramIndex) {
	                if (paramIndex === paramSet.length) {
	                    combinations.push(currList);
	                    return;
	                }

	                var params = paramSet[paramIndex];

	                for (var i = 0; i < params.length; i++) {
	                    currList.push(params[i]);
	                    addParam(currList.slice(), paramSet, paramIndex + 1);
	                    currList.pop();
	                }
	            };

	            var makeCombinations = function() {
	                var paramSets = makeParamSets(self.curveTypes);
	                _.each(paramSets, function(paramSet) {
	                    addParam([], paramSet, 0);
	                });
	            };

	            // POSSIBLE TODO(stephanie): make combinations not a global variable
	            var self = this;
	            var combinations = [];
	            makeCombinations();

	            return combinations;
	        },

	        _randomY: function(ylims, excludes) {
	            return KhanUtil.randRangeExclude(ylims[0], ylims[1], ylims.concat(excludes));
	        },

	        generate: function(options) {
	            options = $.extend(true, {
	                INTERVAL_WIDTH: 2,
	                YLIMS: [],
	                numSegments: 1,
	                startVal: null, // overrides prevSegment start val
	                prevSegment: null,
	                breakIndex: null
	            }, options);

	            if (!this.combinations) {
	                this.combinations = this.makeCombinations();
	            }

	            var self = this;
	            var YLIMS = options.YLIMS;
	            var INTERVAL_WIDTH = options.INTERVAL_WIDTH;

	            var endVal = function(segment) {
	                return segment.evalOf(options.INTERVAL_WIDTH);
	            };

	            // start the segment at startVal
	            var createSegment = function(startVal, prevSegment) {
	                // POSSIBLE TODO(stephanie): add weights to the combinations

	                if (startVal == null) {
	                    if (prevSegment == null) {
	                        startVal = self._randomY(YLIMS);
	                    } else {
	                        startVal = endVal(prevSegment);
	                    }
	                }

	                // iterate through combinations in a random order each time
	                var indices = self._scramble(self.combinations.length);

	                for (var j = 0; j < indices.length; j++) {
	                    var params = self.combinations[indices[j]].slice();

	                    var curveType = self.curveTypes[params[0]];

	                    // add the value of "b" to the params array
	                    params.push(startVal);
	                    params.push(INTERVAL_WIDTH);

	                    var segment = curveType["generate"].apply(null, params.slice(1));

	                    var y = endVal(segment);

	                    // segment is not qualified if it causes the graph to go
	                    // outside the y limits
	                    if (!self._isInRange(YLIMS, y)) {
	                        continue;
	                    }

	                    // segment is not allowed to have the same params as
	                    // the previous one
	                    if (prevSegment) {
	                        var y0 = prevSegment.evalOf(0);
	                        var s0 = prevSegment.subtract(y0).text();
	                        var s1 = segment.subtract(startVal).text();
	                        if (s0 === s1) {
	                            continue;
	                        }
	                    }

	                    // POSSIBLE TODO(stephanie): check for other constraints here
	                    return segment;
	                }
	                return null;
	            };

	            var makePiecewiseGraph = function() {
	                var segments = [];
	                var start = options.startVal;
	                var prev = options.prevSegment;

	                while (segments.length < options.numSegments) {
	                    var len = segments.length;
	                    if (options.breakIndex && len === options.breakIndex) {
	                        start = self._randomY(YLIMS, [start]);
	                    }

	                    var segment = createSegment(start, prev);

	                    // no possible problem with these starting segments,
	                    // so start over completely
	                    if (!segment) {
	                        segments = [];
	                        prev = options.prevSegment;
	                        start = options.startVal;
	                    }

	                    segments.push(segment);
	                    prev = segment;
	                    start = null;
	                }

	                return segments;
	            };

	            var fnArray = makePiecewiseGraph();

	            var rangeArray = [];
	            _.each(fnArray, function(fn, i) {
	                var x = i * options.INTERVAL_WIDTH;
	                rangeArray.push([x, x + options.INTERVAL_WIDTH]);
	            });

	            return new KhanUtil.PiecewiseFunction({
	                fnArray: fnArray,
	                rangeArray: rangeArray
	            });
	        }
	    },

	    VisualizingDerivativesProblem: function(options) {
	        options = $.extend(true, {
	            XLIMS: [0, 14],
	            YLIMS: [-2, 4],
	            GRAPH_LIMS: [[], []],
	            INTERVAL_WIDTH: 2,

	            problem: null,
	            graph: null,

	            nIntervals: 7,
	            nProblemIntervals: 1,
	            offset: 0.5,
	            breakIndex: 3,
	            noSolution: false,
	            moveDerivative: true,

	            fnColor: KhanUtil.BLUE,
	            derivColor: KhanUtil.RED

	        }, options);

	        $.extend(this, options);

	        this._setAxisLims = function() {
	            var width = this.INTERVAL_WIDTH;
	            var n = this.nIntervals;
	            this.XLIMS = [0, width * n];
	            this.YLIMS = [-width, 2 * width];

	            var pad = function(lims, padAmt) {
	                return [lims[0] - padAmt, lims[1] + padAmt];
	            };

	            this.GRAPH_LIMS = [pad(this.XLIMS, width), pad(this.YLIMS, 1)];
	        };

	        this._invalidParams = function(piecewiseFn, startIndex, nIntervals) {
	            var outOfBounds = startIndex + nIntervals > piecewiseFn.length();
	            if (!piecewiseFn || startIndex === null ||
	                nIntervals === 0 || outOfBounds) {
	                return true;
	            }
	            return false;
	        };

	        this.chooseProblemStart = function(totalIntervals, nIntervals, offset) {
	            var upperBound = totalIntervals - (nIntervals + Math.ceil(offset));
	            return KhanUtil.randRange(0, upperBound);
	        };

	        this.matchesToProblemRanges = function(matches, nIntervals, offset) {
	            var w = this.INTERVAL_WIDTH;
	            return _.map(matches, function(matchIndex) {
	                var startIndex = matchIndex + offset;
	                var endIndex = startIndex + nIntervals;
	                return _.map([startIndex, endIndex], function(x) {
	                    return w * x;
	                });
	            });
	        };

	        this.generateProblem = function(piecewiseFn, startIndex, nIntervals, offset) {
	            // we need one more interval if there's an offset
	            nIntervals += (offset === 0) ? 0 : 1;

	            if (this._invalidParams(piecewiseFn, startIndex, nIntervals)) {
	                return null;
	            }

	            var endIndex = startIndex + nIntervals;
	            var problem = piecewiseFn.slice(startIndex, endIndex);

	            // we need to trim the rangeArray if there's an offset
	            problem.trimRangeArrayEnds(offset);

	            return problem;
	        };

	        this.generateBogusProblem = function(piecewiseFn, startIndex, nIntervals, offset) {
	            // we need one more interval if there's an offset
	            nIntervals += (offset === 0) ? 0 : 1;

	            if (this._invalidParams(piecewiseFn, startIndex, nIntervals)) {
	                return null;
	            }

	            var generator = KhanUtil.PiecewiseFunctionGenerator;
	            var bogusProblem;

	            var loopCount = 0;

	            var validBogus = false;
	            while (!validBogus) {
	                // only one interval, so it must be bogus/invalid
	                if (nIntervals === 1) {
	                    bogusProblem = generator.generate({
	                        nIntervals: 1,
	                        INTERVAL_WIDTH: this.INTERVAL_WIDTH,
	                        YLIMS: this.YLIMS
	                    });

	                } else {
	                    // as few as 1 and as many as all but one interval can be
	                    // valid
	                    var nValidIntervals = KhanUtil.randRange(1, nIntervals - 1);

	                    // the rest of the intervals are bogus
	                    var nBogusIntervals = nIntervals - nValidIntervals;

	                    var endIndex = startIndex + nValidIntervals;
	                    var prefixFn = piecewiseFn.slice(startIndex, endIndex);

	                    var n = prefixFn.length();
	                    var prevSegment = prefixFn.fnArray[n - 1];

	                    bogusProblem = generator.generate({
	                        numSegments: nBogusIntervals,
	                        prevSegment: prevSegment,
	                        INTERVAL_WIDTH: this.INTERVAL_WIDTH,
	                        YLIMS: this.YLIMS
	                    });

	                    bogusProblem = prefixFn.concat(bogusProblem);
	                }

	                var matches = piecewiseFn.matches(bogusProblem, true);
	                if (!matches.length) {
	                    validBogus = true;
	                }

	                // if we can't find a valid bogus in a reasonable # of tries,
	                // quit and generate a new problem. 50 is an arbitrary
	                // threshold.
	                if (loopCount > 50) {
	                    return null;
	                }

	                loopCount++;
	            }

	            // we need to trim the rangeArray if there's an offset
	            bogusProblem.trimRangeArrayEnds(offset);

	            return bogusProblem;
	        };

	        this.initSlidingWindow = function(options) {
	            this.graphie.addMouseLayer();

	            var problem = options.problem;

	            // compute lims
	            var xlims = this.GRAPH_LIMS[0];
	            var ylims = this.GRAPH_LIMS[1];

	            // window cannot move past (the edges of the graph area - 1)
	            var xmin = xlims[0] + 1;
	            var xmax = xlims[1] - 1;

	            // window extends to the top and bottom edges of the graph area
	            var ymin = ylims[0];
	            var ymax = ylims[1];
	            var height = ymax - ymin;

	            var slidingWindow = this.graphie.addRectGraph({
	                x: xmin,
	                y: ymin,
	                width: problem.width(),
	                height: height,
	                normalStyle: {
	                    area: {
	                        "fill-opacity": 0.08,
	                        fill: options.color
	                    },
	                    edges: {
	                        "stroke-width": 0
	                    },
	                    points: {
	                        opacity: 0
	                    }
	                },
	                hoverStyle: {
	                    area: {
	                        "fill-opacity": 0.14,
	                        fill: options.color
	                    },
	                    points: {
	                        opacity: 0
	                    }
	                },
	                fixed: {
	                    edges: [true, true, true, true],
	                    points: [true, true, true, true]
	                },
	                constraints: {
	                    constrainX: false,
	                    constrainY: true,
	                    xmin: xmin,
	                    xmax: xmax
	                },
	                onMove: function(dx, dy) {
	                    problem.translatePlot(dx, dy);
	                    problem.toFront();
	                },
	                snapX: 1
	            });

	            // number of milliseconds it takes the slidingWindow to fade in/out
	            var speed = 20;

	            slidingWindow.doHide = function() {
	                slidingWindow.hide(speed);
	                problem.hide(speed);
	                options.onHide();
	            };

	            slidingWindow.doShow = function() {
	                slidingWindow.show(speed);
	                problem.show(speed);
	                options.onShow();
	            };

	            // problem graph should be in front of sliding window
	            slidingWindow.toFront();
	            problem.toFront();

	            var xOffset = xmin + -problem.rangeArray[0][0];
	            problem.translatePlot(xOffset, 0);

	            slidingWindow.startRange = [xmin, xmin + problem.width()];

	            // attach sliding window to this object
	            this.slidingWindow = slidingWindow;
	        };

	        this.init = function() {
	            var generator = KhanUtil.PiecewiseFunctionGenerator;

	            // SET AXIS LIMS
	            this._setAxisLims();

	            // MAKE BASE GRAPH
	            this.graph = generator.generate({
	                numSegments: this.nIntervals,
	                breakIndex: this.breakIndex,
	                INTERVAL_WIDTH: this.INTERVAL_WIDTH,
	                YLIMS: this.YLIMS
	            });

	            // MAKE PROBLEM
	            var n = this.nProblemIntervals;
	            var offset = this.offset;
	            var start = this.chooseProblemStart(this.graph.length(), n, offset);

	            if (this.noSolution) {
	                this.problem = this.generateBogusProblem(this.graph, start, n, offset);

	                // if a valid bogus problem could not be generated for this
	                // initial graph, just start all over again
	                if (this.problem === null) {
	                    this.init();
	                    return;
	                }

	            } else {
	                this.problem = this.generateProblem(this.graph, start, n, offset);
	            }

	            // FIND MATCHES
	            var matches = this.graph.matches(this.problem, true);
	            this.problemRanges = this.matchesToProblemRanges(matches, n, offset);
	        };

	        // TODO(stephanie) LATER: refactor this and initAutoscaledGraph in
	        // derivative intuition
	        var initRectAutoscaledGraph = function(range, options) {
	            var graph = KhanUtil.currentGraph;

	            var xlims = range[0];
	            var ylims = range[1];

	            var xrange = xlims[1] - xlims[0];
	            var yrange = ylims[1] - ylims[0];

	            var xpixels = 480;

	            options = $.extend({
	                tickOpacity: 0.6,
	                labelOpacity: 0.6,
	                xpixels: xpixels,
	                ypixels: xpixels * yrange / xrange,
	                xdivisions: xrange,
	                ydivisions: yrange,
	                labels: true,
	                unityLabels: true,
	                range: (typeof range === "undefined" ? [[-10, 10], [-10, 10]] : range)
	            }, options);

	            options.scale = [options.xpixels / xrange,
	                             options.ypixels / yrange];
	            options.gridStep = [xrange / options.xdivisions,
	                                yrange / options.ydivisions];

	            // Attach the resulting metrics to the graph for later reference
	            graph.xpixels = options.xpixels;
	            graph.ypixels = options.ypixels;
	            graph.range = options.range;
	            graph.scale = options.scale;

	            graph.graphInit(options);
	        };

	        this.render = function(options) {

	            // PLOT BASE GRAPH AND PROBLEM GRAPH
	            initRectAutoscaledGraph(this.GRAPH_LIMS, {});

	            // store current graph for use by resetCurrentGraph()
	            this.graphie = KhanUtil.currentGraph;

	            var windowColor = this.derivColor;
	            if (this.moveDerivative) {
	                this.graph.plot({
	                    color: this.fnColor,
	                    graphie: this.graphie
	                });
	                this.problem.plot({
	                    color: this.derivColor,
	                    plotDerivative: true,
	                    omitEnds: false,
	                    graphie: this.graphie
	                });
	            } else {
	                this.graph.plot({
	                    color: this.derivColor,
	                    plotDerivative: true,
	                    graphie: this.graphie
	                });
	                this.problem.plot({
	                    color: this.fnColor,
	                    omitEnds: true,
	                    graphie: this.graphie
	                });
	                windowColor = this.fnColor;
	            }

	            // CREATE SLIDING WINDOW
	            var checkboxIdentifier = ".sol.no-solution :checkbox";
	            this.initSlidingWindow({
	                problem: this.problem,
	                color: windowColor,
	                onHide: function() {
	                    $(checkboxIdentifier).attr("checked", true);
	                },
	                onShow: function() {
	                    $(checkboxIdentifier).attr("checked", false);
	                }
	            });

	            // when user clicks "no solution", hide the sliding window
	            this.bindNoSolutionHide(checkboxIdentifier);

	            return this.slidingWindow;
	        };

	        // after displaying hint, reset KhanUtil.currentGraph to graphie
	        // element containing the problem graph to solve bug whereby the
	        // movable window is less responsive after hint graphs are added to
	        // the page
	        this.resetCurrentGraph = function() {
	            KhanUtil.currentGraph = this.graphie;
	        };

	        this.hints = function() {
	            var hints = [];

	            this.hintproblems = [];

	            var moveDeriv = this.moveDerivative;

	            var self = this;
	            _.each(this.problem.fnArray, function(fn, i) {
	                var nth = i > 0 ?
	                    $._("next") :
	                    $._("first");

	                fn = fn.derivative();

	                var nCoefs = fn.coefs.length;
	                var hint;
	                if (nCoefs === 1) {
	                    var val = "<code>" + fn.coefs[0] + "</code>";
	                    if (moveDeriv) {
	                        hint = $._("The %(nth)s section of the derivative has a constant " +
	                            "value of %(val)s, so it corresponds to an original function with " +
	                            "a constant <b>slope</b> of %(val)s.", {nth: nth, val: val});
	                    } else {
	                        hint = $._("The %(nth)s section of the antiderivative has a constant " +
	                            "slope of %(val)s, so it corresponds to an original function " +
	                            "that has a constant value of %(val)s.", {nth: nth, val: val});
	                    }
	                } else if (nCoefs === 2) {
	                    var inc;
	                    var val = fn.evalOf(0) + fn.evalOf(self.INTERVAL_WIDTH);
	                    if (val >= 0) {
	                        if (fn.coefs[1] > 0) {
	                            inc = $._("increasing and positive");
	                        } else {
	                            inc = $._("decreasing and positive");
	                        }
	                    } else {
	                        if (fn.coefs[1] > 0) {
	                            inc = $._("increasing and negative");
	                        } else {
	                            inc = $._("decreasing and negative");
	                        }
	                    }

	                    if (moveDeriv) {
	                        hint = $._("The %(nth)s section of the derivative is %(inc)s, " +
	                            "so it corresponds to an original function whose " +
	                            "<b>slope</b> is %(inc)s.", {nth: nth, inc: inc});
	                    } else {
	                        hint = $._("The %(nth)s section of the antiderivative has a " +
	                            "%(inc)s slope, so it corresponds to an original " +
	                            "function that is %(inc)s.", {nth: nth, inc: inc});
	                    }
	                }


	                var hintproblem = self.problem.slice(i, i + 1);
	                hintproblem.calibrate();
	                self.hintproblems.push(hintproblem);

	                hints.push("<p>" + hint + "</p><div class='clearfix'> <div class='graphie vis-deriv-hint-graph' id='orig" + i + "'>   PROBLEM.showHint(" + i + ", " + moveDeriv + ");</div>" +
	                    "<div class='graphie vis-deriv-hint-graph' id='orig" + i + "'> PROBLEM.showHint(" + i + ", " + !moveDeriv + ");</div> </div>");
	            });

	            var lastHint;
	            if (this.noSolution) {
	                lastHint = $._("Because these sections do not appear next " +
	                    "to each other in the graph of <code>f(x)</code>, " +
	                    "there is no solution.");
	                hints.push("<p>" + lastHint + "</p>");
	                hints.push("<div class='graphie'> PROBLEM.showNoAnswer(); </div>");
	            } else {
	                var solnText = this.problemRanges.map(function(range) {
	                                return "<code>x \\in [" + range.join(", ") + "]</code>";
	                            }).join(" and ");
	                var fnVar = moveDeriv ? "f'(x)" : "F(x)";
	                lastHint = $._("The function in the window corresponds to " +
	                    "<code>%(fnVar)s</code> where %(solution)s.",
	                    {fnVar: fnVar, solution: solnText});

	                var firstAnswer = this.problemRanges[0][0];
	                hints.push("<p>" + lastHint + "</p>");
	                hints.push("<div class='graphie'> PROBLEM.showAnswer(" + firstAnswer + "); </div>");
	            }

	            return hints;
	        };

	        // TODO(stephanie) LATER: refactor this and initAutoscaledGraph in
	        // derivative intuition
	        var initHintGraph = function(range, options) {
	            var graph = KhanUtil.currentGraph;

	            var xlims = range[0];
	            var ylims = range[1];

	            var xrange = xlims[1] - xlims[0];
	            var yrange = ylims[1] - ylims[0];

	            var xpixels = 480 / 18 * Math.abs(range[0][1] - range[0][0]);

	            options = $.extend({
	                xpixels: xpixels,
	                ypixels: xpixels * yrange / xrange,
	                xdivisions: xrange,
	                ydivisions: yrange,
	                labels: true,
	                unityLabels: true,
	                range: range
	            }, options);

	            options.scale = [options.xpixels / xrange,
	                             options.ypixels / yrange];
	            options.gridStep = [xrange / options.xdivisions,
	                                yrange / options.ydivisions];

	            // Attach the resulting metrics to the graph for later reference
	            graph.xpixels = options.xpixels;
	            graph.ypixels = options.ypixels;
	            graph.range = options.range;
	            graph.scale = options.scale;

	            graph.graphInit(options);

	            return graph;
	        };

	        this.showHint = function(i, deriv) {

	            var segment = this.hintproblems[i];
	            var hintGraphie;
	            if (deriv) {
	                hintGraphie = initHintGraph([[1, 5], [-3, 3]], {
	                    axisOpacity: 1,
	                    labelOpacity: 0.01,
	                    tickOpacity: 0.01
	                });
	                segment.plot({
	                    color: this.derivColor,
	                    plotDerivative: true,
	                    omitEnds: false,
	                    graphie: hintGraphie
	                });
	            } else {
	                hintGraphie = initHintGraph([[1, 5], [-3, 3]], {
	                    axisOpacity: 0.01,
	                    labelOpacity: 0.01,
	                    tickOpacity: 0.01
	                });
	                segment.plot({
	                    color: this.fnColor,
	                    omitEnds: true,
	                    graphie: hintGraphie
	                });
	            }

	            this.resetCurrentGraph();
	        };

	        this.showAnswer = function(firstAnswer) {
	            this.slidingWindow.doShow();
	            this.slidingWindow.moveTo(firstAnswer, 0);
	            this.resetCurrentGraph();
	        };

	        this.showNoAnswer = function() {
	            this.slidingWindow.doHide();
	            this.resetCurrentGraph();
	        };

	        // hide sliding window if "no solution" is selected
	        this.bindNoSolutionHide = function(checkboxIdentifier) {
	            var slidingHidden = false;
	            var sliding = this.slidingWindow;
	            $("body").on("click", checkboxIdentifier, function() {
	                slidingHidden = !slidingHidden;
	                // just switched to being hidden
	                if (slidingHidden) {
	                    sliding.doHide();
	                } else {
	                    sliding.doShow();
	                }
	            });
	        };

	        this.init();
	    }
	});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

	__webpack_require__(10);

	// Example usage:
	// <var>person(1)</var> traveled 5 mi by <var>vehicle(1)</var>. Let
	// <var>his(1)</var> average speed be <var>personVar(1)</var>.
	// Let <var>person(2)</var>'s speed be <var>personVar(2)</var>.
	//
	// Note that initials (-Var) are guaranteed to be unique in each category,
	// but not across them.

	$.extend(KhanUtil, {
	    // TODO(csilvers): I18N: rename serialCommafy and copy from webapp.
	    toSentence: function(items) {
	        var n = items.length;

	        // This seems to be a pretty l10n-aware, actually.  cf.
	        //    http://comments.gmane.org/gmane.comp.audio.musicbrainz.i18n/15
	        // The only possible problem is chinese, which it looks like
	        // prefers a special character to the comma, which we hard-code in
	        // items_with_commas.
	        if (n === 0) {
	            return "";
	        } else if (n === 1) {
	            return items[0];
	        } else if (n === 2) {
	            return $._("%(item1)s and %(item2)s",
	                       {item1: items[0], item2: items[1]});
	        } else {
	            return $._("%(items_with_commas)s, and %(last_item)s",
	                       {items_with_commas: items.slice(0, n - 1).join(", "),
	                        last_item: items[n - 1]});
	        }
	    },

	    toSentenceTex: function(array, highlight, highlightClass) {
	        var wrapped = $.map(array, function(elem) {
	            if ((_.isFunction(highlight) && highlight(elem)) || (highlight !== undefined && elem === highlight)) {
	                return "<code class='" + highlightClass + "'>" + elem + "</code>";
	            }
	            return "<code>" + elem + "</code>";
	        });
	        return KhanUtil.toSentence(wrapped);
	    },

	    capitalize: function(str) {
	        return str.charAt(0).toUpperCase() + str.slice(1);
	    },

	    AMBIGUOUS_PLURAL: function(word, num) {
	        if (typeof console !== "undefined" && console.error) {
	            console.error("Ambiguous plural variable usage: ", String(word));
	        }

	        KhanUtil.debugLog("ERROR: Ambiguous plural variable usage: " +
	            String(word));

	        // Check if the word is pluralizable
	        var plural_word = word && word.plural ?
	            word.plural(num) :
	            (num == null ? this.plural(word) : this.plural(word, num));

	        return "<span class='error'>" + plural_word + "</span>";
	    },

	    plural_form: function(word, num) {
	        // Check if the word is pluralizable
	        if (word && word.plural) {
	            return word.plural(num);
	        }

	        if (typeof console !== "undefined" && console.error) {
	            console.error("Word not in plural dictionary: ", String(word));
	        }

	        KhanUtil.debugLog("ERROR: Word not in plural dictionary: " +
	            String(word));

	        return "<span class='error'>" +
	            (num == null ? this.plural(word) : this.plural(word, num)) +
	            "</span>";
	    },

	    isSingular: function(num) {
	        return num === 1;
	    },

	    // DEPRECATED
	    // pluralization helper.  There are two signatures
	    // - plural(NUMBER, singular):
	    //        - if necessary, magically pluralize <singular>
	    //        - return "NUMBER word"
	    // - plural(NUMBER, singular, plural):
	    //        - return "NUMBER word"
	    // - plural(singular, NUMBER):
	    //        - if necessary, magically pluralize <singular>
	    //        - return "word"
	    // - plural(singular, plural, NUMBER):
	    //        - return "word"
	    plural: (function() {
	        var oneOffs = {
	            "quiz": "quizzes",
	            "shelf": "shelves",
	            "loaf": "loaves",
	            "potato": "potatoes",
	            "person": "people",
	            "is": "are",
	            "was": "were",
	            "foot": "feet",
	            "square foot": "square feet",
	            "tomato": "tomatoes"
	        };

	        var pluralizeWord = function(word) {

	            // Check if this is a new Plural object, and just use that plural
	            if (word && word.plural) {
	                return word.plural(2);
	            }

	            // noone really needs extra spaces at the edges, do they?
	            word = $.trim(word);

	            // determine if our word is all caps.  If so, we'll need to
	            // re-capitalize at the end
	            var isUpperCase = (word.toUpperCase() === word);
	            var oneOff = oneOffs[word.toLowerCase()];
	            var words = word.split(/\s+/);

	            // first handle simple one-offs
	            // ({}).watch is a function in Firefox, blargh
	            if (typeof oneOff === "string") {
	                return oneOff;
	            }

	            // multiple words
	            else if (words.length > 1) {
	                // for 3-word phrases where the middle word is 'in' or 'of',
	                // pluralize the first word
	                if (words.length === 3 && /\b(in|of)\b/i.test(words[1])) {
	                    words[0] = KhanUtil.plural(words[0]);
	                }

	                // otherwise, just pluraize the last word
	                else {
	                    words[words.length - 1] =
	                        KhanUtil.plural(words[words.length - 1]);
	                }

	                return words.join(" ");
	            }

	            // single words
	            else {
	                // "-y" => "-ies"
	                if (/[^aeiou]y$/i.test(word)) {
	                    word = word.replace(/y$/i, "ies");
	                }

	                // add "es"; things like "fish" => "fishes"
	                else if (/[sxz]$/i.test(word) || /[bcfhjlmnqsvwxyz]h$/.test(word)) {
	                    word += "es";
	                }

	                // all the rest, just add "s"
	                else {
	                    word += "s";
	                }

	                if (isUpperCase) {
	                    word = word.toUpperCase();
	                }
	                return word;
	            }
	        };

	        return function(value, arg1, arg2) {
	            if (typeof value === "number") {
	                var usePlural = (value !== 1);

	                // if no extra args, just add "s" (if plural)
	                if (arguments.length === 1) {
	                    return usePlural ? "s" : "";
	                }

	                if (usePlural) {
	                    arg1 = arg2 || pluralizeWord(arg1);
	                }

	                return value + " " + arg1;
	            } else if (typeof value === "string" || typeof value === "object") {
	                // We need to accept objects here as well for new Plural objects
	                var plural = pluralizeWord(value);
	                if (typeof arg1 === "string" && arguments.length === 3) {
	                    plural = arg1;
	                    arg1 = arg2;
	                }
	                var usePlural = (arguments.length < 2 || (typeof arg1 === "number" && arg1 !== 1));
	                return usePlural ? plural : value;
	            }
	        };
	    })()
	});

	var Plural = KhanUtil.Plural = function(plural_fn) {
	    this.plural_fn = plural_fn;
	};

	KhanUtil.Plural.prototype = {
	    plural: function(num) {
	        // There are some cases where plural is called with only a word
	        // (and no number). In this case we just want to return the plural
	        // form of that word, as best as we can. This might have some slight
	        // incongruities across platforms
	        num = num === undefined ? 2 : num;

	        return this.plural_fn(num);
	    },

	    toString: function() {
	        return this.plural_fn(1);
	    }
	};

	KhanUtil.numberPlaceNames = [
	    new Plural(function(num) {
	        return $.ngettext("one", "ones", num);
	    }),
	    new Plural(function(num) {
	        return $.ngettext("ten", "tens", num);
	    }),
	    new Plural(function(num) {
	        return $.ngettext("hundred", "hundreds", num);
	    }),
	    new Plural(function(num) {
	        return $.ngettext("thousand", "thousands", num);
	    }),
	    new Plural(function(num) {
	        return $.ngettext("ten thousand", "ten thousands", num);
	    })
	];

	KhanUtil.decimalPlaceNames = [
	    new Plural(function(num) {
	        return $.ngettext("one", "ones", num);
	    }),
	    new Plural(function(num) {
	        return $.ngettext("tenth", "tenths", num);
	    }),
	    new Plural(function(num) {
	        return $.ngettext("hundredth", "hundredths", num);
	    }),
	    new Plural(function(num) {
	        return $.ngettext("thousandth", "thousandths", num);
	    }),
	    new Plural(function(num) {
	        return $.ngettext("ten thousandth", "ten thousandths", num);
	    })
	];

	KhanUtil.metricUnits = [
	    [$._("m"), new Plural(function(num) {
	        return $.ngettext("meter", "meters", num);
	    })],
	    [$._("cm"), new Plural(function(num) {
	        return $.ngettext("centimeter", "centimeters", num);
	    })]
	];

	KhanUtil.imperialUnits = [
	    ["in", new Plural(function(num) {
	        return $.ngettext("inch", "inches", num);
	    })],
	    ["ft", new Plural(function(num) {
	        return $.ngettext("foot", "feet", num);
	    })]
	];

	KhanUtil.genericUnit = ["", new Plural(function(num) {
	    return $.ngettext("unit", "units", num);
	})];

	$.fn["word-problemsLoad"] = function() {

	    var IncrementalShuffler = function(array) {
	        // Shuffle an array incrementally so we only use as many random calls
	        // as we need, so names can be added/removed without breaking all
	        // random seeds for all word problems
	        // - get(0); get(0); will use only one call
	        // - get(0); get(1); will have each use one random call
	        // - get(1); get(0); will use two random calls then none and each call
	        //   will give the same result as running 0 then 1
	        array = [].slice.call(array, 0);
	        var shuffled = 0;

	        this.get = function(i) {
	            if (i < 0 || i >= array.length) {
	                return undefined;
	            }

	            while (shuffled <= i) {
	                var top = array.length - shuffled,
	                    newEnd = Math.floor(KhanUtil.random() * top),
	                    tmp = array[newEnd];

	                array[newEnd] = array[top - 1];
	                array[top - 1] = tmp;
	                shuffled++;
	            }

	            // Since we shuffle items from the end to the front, return the
	            // items in reverse order
	            return array[array.length - i - 1];
	        };
	    };

	    var names = [
	        // I18N: Female name
	        [$._("Ashley"), "f"],
	        // I18N: Male name
	        [$._("Brandon"), "m"],
	        // I18N: Male name
	        [$._("Ben"), "m"],
	        // I18N: Male name
	        [$._("Christopher"), "m"],
	        // I18N: Male name
	        [$._("Daniel"), "m"],
	        // I18N: Female name
	        [$._("Emily"), "f"],
	        // I18N: Female name
	        [$._("Gabriela"), "f"],
	        // I18N: Male name
	        [$._("Ishaan"), "m"],
	        // I18N: Female name
	        [$._("Jessica"), "f"],
	        // I18N: Male name
	        [$._("Kevin"), "m"],
	        // I18N: Male name
	        [$._("Luis"), "m"],
	        // I18N: Male name
	        [$._("Michael"), "m"],
	        // I18N: Female name
	        [$._("Nadia"), "f"],
	        // I18N: Male name
	        [$._("Omar"), "m"],
	        // I18N: Female name
	        [$._("Stephanie"), "f"],
	        // I18N: Female name
	        [$._("Tiffany"), "f"],
	        // I18N: Female name
	        [$._("Umaima"), "f"],
	        // I18N: Female name
	        [$._("Vanessa"), "f"],
	        // I18N: Male name
	        [$._("William"), "m"]
	    ];

	    // We only want one name per letter of the alphabet, so group people with
	    // the same initial before shuffling the names up
	    var people = _.map(_.groupBy(names, function(name) {
	        return name[0].charAt(0);
	    }), function(group) {
	        return new IncrementalShuffler(group);
	    });
	    people = new IncrementalShuffler(people);

	    // NOTE(jeresig): I18N: These strings are expected to work prefixed with
	    // just the letter "A", as in "A gorilla"
	    var vehicles = new IncrementalShuffler([
	        new Plural(function(num) {
	            return $.ngettext("bike", "bikes", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("car", "cars", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("horse", "horses", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("motorcycle", "motorcycles", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("scooter", "scooters", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("train", "trains", num);
	        })
	    ]);

	    // NOTE(jeresig): I18N: These strings are expected to work prefixed with
	    // just the letter "A", as in "A gorilla"
	    var courses = new IncrementalShuffler([
	        $._("chemistry"),
	        $._("geometry"),
	        $._("history"),
	        $._("math"),
	        $._("physics"),
	        $._("language")
	    ]);

	    var exams = new IncrementalShuffler([
	        new Plural(function(num) {
	            return $.ngettext("exam", "exams", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("test", "tests", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("quiz", "quizzes", num);
	        })
	    ]);

	    var binops = new IncrementalShuffler([
	        "\\barwedge",
	        "\\veebar",
	        "\\odot",
	        "\\oplus",
	        "\\otimes",
	        "\\oslash",
	        "\\circledcirc",
	        "\\boxdot",
	        "\\bigtriangleup",
	        "\\bigtriangledown",
	        "\\dagger",
	        "\\diamond",
	        "\\star",
	        "\\triangleleft",
	        "\\triangleright"
	    ]);

	    var collections = new IncrementalShuffler([
	        [new Plural(function(num) {
	            return $.ngettext("party favor", "party favors", num);
	        }), new Plural(function(num) {
	            return $.ngettext("bag", "bags", num);
	        })],
	        [new Plural(function(num) {
	            return $.ngettext("jelly bean", "jelly beans", num);
	        }), new Plural(function(num) {
	            return $.ngettext("bag", "bags", num);
	        })],
	        [new Plural(function(num) {
	            return $.ngettext("book", "books", num);
	        }), new Plural(function(num) {
	            return $.ngettext("shelf", "shelves", num);
	        })],
	        [new Plural(function(num) {
	            return $.ngettext("can of food", "cans of food", num);
	        }), new Plural(function(num) {
	            return $.ngettext("box", "boxes", num);
	        })]
	    ]);

	    // NOTE(jeresig): I18N: These strings are expected to work prefixed with
	    // just the letter "A", as in "A gorilla"
	    var stores = new IncrementalShuffler([
	        {
	            name: new Plural(function(num) {
	                return $.ngettext("hardware", "hardwares", num);
	            }),
	            items: new IncrementalShuffler([
	                new Plural(function(num) {
	                    return $.ngettext("hammer", "hammers", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("nail", "nails", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("saw", "saws", num);
	                })
	            ])
	        },
	        {
	            name: new Plural(function(num) {
	                return $.ngettext("grocery", "groceries", num);
	            }),
	            items: new IncrementalShuffler([
	                new Plural(function(num) {
	                    return $.ngettext("banana", "bananas", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("loaf of bread", "loaves of bread", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("liter of milk", "liters of milk", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("potato", "potatoes", num);
	                })
	            ])
	        },
	        {
	            name: new Plural(function(num) {
	                return $.ngettext("gift", "gifts", num);
	            }),
	            items: new IncrementalShuffler([
	                new Plural(function(num) {
	                    return $.ngettext("toy", "toys", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("game", "games", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("souvenir", "souvenirs", num);
	                })
	            ])
	        },
	        {
	            name: new Plural(function(num) {
	                return $.ngettext("school supply", "school supplies", num);
	            }),
	            items: new IncrementalShuffler([
	                new Plural(function(num) {
	                    return $.ngettext("pen", "pens", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("pencil", "pencils", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("notebook", "notebooks", num);
	                })
	            ])
	        },
	        {
	            name: new Plural(function(num) {
	                return $.ngettext("toy", "toys", num);
	            }),
	            items: new IncrementalShuffler([
	                new Plural(function(num) {
	                    return $.ngettext("stuffed animal", "stuffed animals", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("video game", "video games", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("race car", "race cars", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("doll", "dolls", num);
	                })
	            ])
	        }
	    ]);

	    var pizzas = new IncrementalShuffler([
	        new Plural(function(num) {
	            return $.ngettext("pizza", "pizzas", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("pie", "pies", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("cake", "cakes", num);
	        })
	    ]);

	    var timesofday = new IncrementalShuffler([
	        $._("in the morning"),
	        $._("around noon"),
	        $._("in the evening"),
	        $._("at night")
	    ]);

	    var exercises = new IncrementalShuffler([
	        new Plural(function(num) {
	            return $.ngettext("push-up", "push-ups", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("sit-up", "sit-ups", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("squat", "squats", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("jumping jack", "jumping jacks", num);
	        })
	    ]);

	    var fruits = new IncrementalShuffler([
	        new Plural(function(num) {
	            return $.ngettext("apple", "apples", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("banana", "bananas", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("coconut", "coconuts", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("eggplant", "eggplants", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("kiwi fruit", "kiwi fruit", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("lemon", "lemons", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("mango", "mangos", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("nectarine", "nectarines", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("orange", "oranges", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("pomegranate", "pomegranates", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("watermelon", "watermelons", num);
	        })
	    ]);

	    var deskItems = new IncrementalShuffler([
	        new Plural(function(num) {
	            return $.ngettext("binder", "binders", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("crayon", "crayons", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("eraser", "erasers", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("folder", "folders", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("glue stick", "glue sticks", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("marker", "markers", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("notebook", "notebooks", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("pencil", "pencils", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("rubber stamp", "rubber stamps", num);
	        })
	    ]);

	    // NOTE(jeresig): I18N: These strings are expected to work prefixed with
	    // just the letter "A", as in "A gorilla"
	    var colors = new IncrementalShuffler([
	        $._("red"),
	        // NOTE(jeresig): I18N: Removed because it begins with a vowel and is
	        // used with an()
	        //"orange",
	        $._("yellow"),
	        $._("green"),
	        $._("blue"),
	        $._("purple"),
	        $._("white"),
	        $._("black"),
	        $._("brown"),
	        $._("silver"),
	        $._("gold"),
	        $._("pink")
	    ]);

	    var schools = new IncrementalShuffler([
	        // I18N: This is a generic school name
	        $._("Loyola"),
	        // I18N: This is a generic school name
	        $._("Gardner Bullis"),
	        // I18N: This is a generic school name
	        $._("Almond"),
	        // I18N: This is a generic school name
	        $._("Covington"),
	        // I18N: This is a generic school name
	        $._("Springer"),
	        // I18N: This is a generic school name
	        $._("Santa Rita"),
	        // I18N: This is a generic school name
	        $._("Oak")
	    ]);

	    var furnitureStore = new IncrementalShuffler([
	        new Plural(function(num) {
	            return $.ngettext("chair", "chairs", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("table", "tables", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("bed frame", "bed frames", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("sofa", "sofas", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("couch", "couches", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("desk", "desks", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("book shelf", "book shelves", num);
	        })
	    ]);

	    var electronicStore = new IncrementalShuffler([
	        new Plural(function(num) {
	            return $.ngettext("television", "televisions", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("computer", "computers", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("laptop", "laptops", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("camera", "cameras", num);
	        })
	    ]);

	    var clothes = new IncrementalShuffler([
	        new Plural(function(num) {
	            return $.ngettext("hat", "hats", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("belt", "belts", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("necklace", "necklaces", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("pair of shoes", "pairs of shoes", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("watch", "watches", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("pair of socks", "pairs of socks", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("sweatshirt", "sweatshirts", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("sweater", "sweaters", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("tie", "ties", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("scarf", "scarves", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("pair of shorts", "pairs of shorts", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("pair of jeans", "pairs of jeans", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("pair of gloves", "pairs of gloves", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("shirt", "shirts", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("pair of suspenders", "pairs of suspenders", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("jacket", "jackets", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("pair of glasses", "pairs of glasses", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("pair of boots", "pairs of boots", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("backpack", "backpacks", num);
	        })
	    ]);

	    var sides = new IncrementalShuffler([
	        "left",
	        "right"
	    ]);

	    var shirtStyles = new IncrementalShuffler([
	        "long-sleeved",
	        "short-sleeved"
	    ]);

	    // animal, avg-lifespan, stddev-lifespan
	    // (data is from cursory google searches and wild guessing)
	    // NOTE(jeresig): I18N: These strings are expected to work prefixed with
	    // just the letter "A", as in "A gorilla"
	    var animals = new IncrementalShuffler([
	        // NOTE(jeresig): I18N: Removed because it begins with a vowel and is
	        // used with an()
	        //["alligator", 68, 20],
	        //["anteater", 15, 10],
	        [new Plural(function(num) {
	            return $.ngettext("bear", "bears", num);
	        }), 40, 20],
	        //["elephant", 60, 10],
	        [new Plural(function(num) {
	            return $.ngettext("gorilla", "gorillas", num);
	        }), 20, 5],
	        [new Plural(function(num) {
	            return $.ngettext("lion", "lions", num);
	        }), 12, 5],
	        [new Plural(function(num) {
	            return $.ngettext("lizard", "lizards", num);
	        }), 3, 1],
	        [new Plural(function(num) {
	            return $.ngettext("meerkat", "meerkats", num);
	        }), 13, 5],
	        [new Plural(function(num) {
	            return $.ngettext("porcupine", "porcupines", num);
	        }), 20, 5],
	        [new Plural(function(num) {
	            return $.ngettext("seal", "seals", num);
	        }), 15, 10],
	        [new Plural(function(num) {
	            return $.ngettext("sloth", "sloths", num);
	        }), 16, 5],
	        [new Plural(function(num) {
	            return $.ngettext("snake", "snakes", num);
	        }), 25, 10],
	        [new Plural(function(num) {
	            return $.ngettext("tiger", "tigers", num);
	        }), 22, 5],
	        [new Plural(function(num) {
	            return $.ngettext("turtle", "turtles", num);
	        }), 100, 20],
	        [new Plural(function(num) {
	            return $.ngettext("zebra", "zebras", num);
	        }), 25, 10]
	    ]);

	    // TODO(emily): I18N: add both "row of CROP" as well as just "CROP" for
	    // pluralization. For example, in Polish, adding "row of" to "tomatoes"
	    // changes the pluralization of "tomatoes".
	    var farmers = new IncrementalShuffler([
	        {
	            farmer: new Plural(function(num) {
	                return $.ngettext("farmer", "farmers", num);
	            }),
	            crops: new IncrementalShuffler([
	                new Plural(function(num) {
	                    return $.ngettext("tomato", "tomatoes", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("potato", "potatoes", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("carrot", "carrots", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("bean", "beans", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("corn stalk", "corn stalks", num);
	                })
	            ]),
	            field: new Plural(function(num) {
	                return $.ngettext("field", "fields", num);
	            })
	        },
	        {
	            farmer: new Plural(function(num) {
	                return $.ngettext("gardener", "gardeners", num);
	            }),
	            crops: new IncrementalShuffler([
	                new Plural(function(num) {
	                    return $.ngettext("rose", "roses", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("tulip", "tulips", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("daisy", "daisies", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("iris", "irises", num);
	                }),
	                new Plural(function(num) {
	                    return $.ngettext("lily", "lilies", num);
	                })
	            ]),
	            field: new Plural(function(num) {
	                return $.ngettext("garden", "gardens", num);
	            })
	        }
	    ]);

	    var distances = new IncrementalShuffler([
	        new Plural(function(num) {
	            return $.ngettext("mile", "miles", num);
	        }),
	        new Plural(function(num) {
	            return $.ngettext("kilometer", "kilometers", num);
	        })
	    ]);

	    // TODO(jeresig): I18N: Kill this.
	    var indefiniteArticle = function(word) {
	        var vowels = ["a", "e", "i", "o", "u"];
	        if (_(vowels).indexOf(word[0].toLowerCase()) > -1) {
	            return "An " + word;
	        }
	        return "A " + word;
	    };

	    $.extend(KhanUtil, {
	        person: function(i) {
	            return people.get(i - 1).get(0)[0];
	        },

	        personVar: function(i) {
	            return people.get(i - 1).get(0)[0].charAt(0).toLowerCase();
	        },

	        // TODO(jeresig): I18N: Kill this.
	        he: function(i) {
	            return people.get(i - 1).get(0)[1] === "m" ? "he" : "she";
	        },

	        // TODO(jeresig): I18N: Kill this.
	        him: function(i) {
	            return people.get(i - 1).get(0)[1] === "m" ? "him" : "her";
	        },

	        isMale: function(i) {
	            return people.get(i - 1).get(0)[1] === "m";
	        },

	        // TODO(jeresig): I18N: Kill this.
	        an: function(word) {
	            return indefiniteArticle(word).toLowerCase();
	        },

	        vehicle: function(i) {
	            return vehicles.get(i - 1);
	        },

	        vehicleVar: function(i) {
	            return vehicles.get(i - 1).charAt(0);
	        },

	        course: function(i) {
	            return courses.get(i - 1);
	        },

	        courseVar: function(i) {
	            return courses.get(i - 1).charAt(0).toLowerCase();
	        },

	        exam: function(i) {
	            return exams.get(i - 1);
	        },

	        binop: function(i) {
	            return binops.get(i - 1);
	        },

	        item: function(i) {
	            return collections.get(i - 1)[0];
	        },

	        group: function(i) {
	            return collections.get(i - 1)[1];
	        },

	        store: function(i) {
	            return stores.get(i).name;
	        },

	        storeItem: function(i, j) {
	            return stores.get(i).items.get(j);
	        },

	        pizza: function(i) {
	            return pizzas.get(i);
	        },

	        exercise: function(i) {
	            return exercises.get(i - 1);
	        },

	        timeofday: function(i) {
	            return timesofday.get(i - 1);
	        },

	        school: function(i) {
	            return schools.get(i - 1);
	        },

	        clothing: function(i) {
	            return clothes.get(i - 1);
	        },

	        color: function(i) {
	            return colors.get(i - 1);
	        },

	        fruit: function(i) {
	            return fruits.get(i);
	        },

	        deskItem: function(i) {
	            return deskItems.get(i);
	        },

	        distance: function(i) {
	            return distances.get(i - 1);
	        },

	        farmer: function(i) {
	            return farmers.get(i - 1).farmer;
	        },

	        crop: function(i) {
	            return farmers.get(i - 1).crops.get(0);
	        },

	        field: function(i) {
	            return farmers.get(i - 1).field;
	        },

	        side: function(i) {
	            return sides.get(i - 1);
	        },

	        shirtStyle: function(i) {
	            return shirtStyles.get(i - 1);
	        },

	        furniture: function(i) {
	            return furnitureStore.get(i - 1);
	        },

	        electronic: function(i) {
	            return electronicStore.get(i - 1);
	        },

	        animal: function(i) {
	            return animals.get(i - 1)[0];
	        },

	        animalAvgLifespan: function(i) {
	            return animals.get(i - 1)[1];
	        },

	        animalStddevLifespan: function(i) {
	            return animals.get(i - 1)[2];
	        }
	    });
	};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	(function ($) {
	    // from http://stackoverflow.com/questions/1891444/how-can-i-get-cursor-position-in-a-textarea?rq=1
	    $.fn.getCursorPosition = function() {
	        var el = $(this).get(0);
	        var pos = 0;
	        if ("selectionStart" in el) {
	            pos = el.selectionStart;
	        } else if ("selection" in document) {
	            el.focus();
	            var sel = document.selection.createRange();
	            var selLength = document.selection.createRange().text.length;
	            sel.moveStart("character", -el.value.length);
	            pos = sel.text.length - selLength;
	        }
	        return pos;
	    };

	    $.fn.isCursorFirst = function() {
	        var pos = $(this).getCursorPosition();
	        return pos === 0;
	    };

	    $.fn.isCursorLast = function() {
	        var pos = $(this).getCursorPosition();
	        var last = $(this).val().length;
	        return pos === last;
	    };
	})(jQuery);


/***/ }
/******/ ])